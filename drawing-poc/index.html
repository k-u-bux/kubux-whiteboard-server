<!DOCTYPE html>
<html>
<head>
  <title>Drawing PoC</title>
  <style>
    body {
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      margin: 0;
      gap: 10px;
    }
    #controls {
      display: flex;
      gap: 10px;
      margin-top: 10px;
    }
    #page-controls {
      display: flex;
      gap: 10px;
    }
    canvas {
      border: 1px solid black;
      cursor: crosshair;
    }
    button {
      padding: 10px;
      font-size: 14px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <h1>Whiteboard <span id="page-info"></span></h1>
  <div id="controls">
    <button id="pen-tool">Pen</button>
    <button id="eraser-tool">Eraser</button>
  </div>
  <canvas id="whiteboard" width="800" height="600"></canvas>
  <div id="page-controls">
    <button id="prev-page">Previous Page</button>
    <button id="next-page">Next Page</button>
    <button id="delete-page">Delete Page</button>
    <button id="insert-page">Insert Page</button>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/uuid/8.3.2/uuid.min.js"></script>
  <script>
    const canvas = document.getElementById('whiteboard');
    const ctx = canvas.getContext('2d');
    const pageInfo = document.getElementById('page-info');
    const penTool = document.getElementById('pen-tool');
    const eraserTool = document.getElementById('eraser-tool');
    const prevPageBtn = document.getElementById('prev-page');
    const nextPageBtn = document.getElementById('next-page');
    const deletePageBtn = document.getElementById('delete-page');
    const insertPageBtn = document.getElementById('insert-page');

    const path = window.location.pathname;
    const ws = new WebSocket(`ws://${window.location.hostname}:3001${path}`);

    let isDrawing = false;
    let currentStrokePoints = [];
    let tool = 'pen';
    
    let localModActions = new Map();
    let currentPageId = '';
    let currentHash = '';
    let pageNr = 0;
    let totalPages = 0;
    
    function calculateHash(state) {
      const data = JSON.stringify(state);
      let hash = 0;
      for (let i = 0; i < data.length; i++) {
        const char = data.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash |= 0;
      }
      return hash.toString();
    }

    function drawStroke(stroke) {
      if (stroke.points.length > 1) {
        ctx.beginPath();
        ctx.moveTo(stroke.points[0].x, stroke.points[0].y);
        ctx.lineWidth = 2;
        ctx.lineCap = 'round';
        ctx.strokeStyle = 'black';
        stroke.points.forEach(point => ctx.lineTo(point.x, point.y));
        ctx.stroke();
      }
    }
    
    function renderCanvas() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      localModActions.forEach(action => {
        if (action.type === 'draw') {
          drawStroke(action.payload);
        }
      });
      updateUI();
    }
    
    function updateUI() {
        pageInfo.textContent = `page ${pageNr} of ${totalPages}`;
        prevPageBtn.disabled = pageNr <= 1;
        nextPageBtn.disabled = pageNr >= totalPages;
        deletePageBtn.disabled = totalPages <= 1;
    }

    function findStrokeAt(x, y) {
      const allStrokes = Array.from(localModActions.values());
      for (const action of allStrokes) {
        if (action.type === 'draw') {
          const points = action.payload.points;
          for (let i = 0; i < points.length - 1; i++) {
            const p1 = points[i];
            const p2 = points[i+1];
            
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            const length = Math.sqrt(dx * dx + dy * dy);
            
            const t = ((x - p1.x) * dx + (y - p1.y) * dy) / (length * length);
            
            let closestX, closestY;
            if (t < 0) {
              closestX = p1.x;
              closestY = p1.y;
            } else if (t > 1) {
              closestX = p2.x;
              closestY = p2.y;
            } else {
              closestX = p1.x + t * dx;
              closestY = p1.y + t * dy;
            }
            
            const dist = Math.sqrt((x - closestX) ** 2 + (y - closestY) ** 2);
            if (dist < 10) {
              return action;
            }
          }
        }
      }
      return null;
    }

    function sendModActionProposal(type, payload) {
      const actionUuid = uuid.v4();
      const proposal = {
        'action-uuid': actionUuid,
        payload: { type: type, ...payload },
        'before-hash': currentHash
      };
      
      ws.send(JSON.stringify({
        type: 'mod-action-proposals',
        'pageUuid': currentPageId,
        'action-uuid': actionUuid,
        ...proposal
      }));
    }

    penTool.addEventListener('click', () => {
      tool = 'pen';
      canvas.style.cursor = 'crosshair';
    });
    eraserTool.addEventListener('click', () => {
      tool = 'eraser';
      canvas.style.cursor = 'cell';
    });

    canvas.addEventListener('mousedown', e => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      if (tool === 'pen') {
        isDrawing = true;
        currentStrokePoints.push({ x, y });
        ctx.beginPath();
        ctx.moveTo(x, y);
      } else if (tool === 'eraser') {
        const erasedAction = findStrokeAt(x, y);
        if (erasedAction) {
          sendModActionProposal('erase', { actionUuid: erasedAction['action-uuid'] });
        }
      }
    });

    canvas.addEventListener('mousemove', e => {
      if (tool === 'pen' && isDrawing) {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        currentStrokePoints.push({ x, y });
        ctx.lineTo(x, y);
        ctx.stroke();
      }
    });

    canvas.addEventListener('mouseup', () => {
      if (tool === 'pen' && isDrawing) {
        if (currentStrokePoints.length > 1) {
          sendModActionProposal('draw', { points: currentStrokePoints });
        }
        currentStrokePoints = [];
        ctx.beginPath();
      }
      isDrawing = false;
    });

    prevPageBtn.addEventListener('click', () => {
        ws.send(JSON.stringify({ type: 'fullPage-requests', 'board-uuid': '1', 'page-uuid': currentPageId, 'Delta': -1, requestId: uuid.v4() }));
    });
    nextPageBtn.addEventListener('click', () => {
        ws.send(JSON.stringify({ type: 'fullPage-requests', 'board-uuid': '1', 'page-uuid': currentPageId, 'Delta': 1, requestId: uuid.v4() }));
    });
    deletePageBtn.addEventListener('click', () => sendModActionProposal('delete page', {}));
    insertPageBtn.addEventListener('click', () => sendModActionProposal('new page', {}));

    ws.onmessage = event => {
      const data = JSON.parse(event.data);
      if (data.type === 'fullPage') {
        localModActions.clear();
        data.state.forEach(stroke => localModActions.set(uuid.v4(), { type: 'draw', payload: stroke }));
        currentPageId = data.page;
        currentHash = data.hash;
        pageNr = data.pageNr;
        totalPages = data.totalPages;
        renderCanvas();
      } else if (data.type === 'accept-message') {
        currentHash = data['after-hash'];
        console.log(`Action ${data['action-uuid']} accepted. Before Hash: ${data['before-hash']}, After Hash: ${data['after-hash']}.`);
      } else if (data.type === 'decline-message') {
        console.warn(`Action ${data['action-uuid']} was declined. Re-syncing...`);
        ws.send(JSON.stringify({ type: 'replay-requests', 'page-uuid': currentPageId, 'before-hash': currentHash, requestId: uuid.v4() }));
      } else if (data.type === 'replay-message') {
        console.log('Replaying missing actions...');
        localModActions.clear();
        data['sequence of mod-actions'].forEach(action => {
          if (action.payload.type === 'draw') {
            localModActions.set(action['action-uuid'], action);
          } else if (action.payload.type === 'erase') {
            localModActions.delete(action.payload.actionUuid);
          }
        });
        currentPageId = data['page-uuid'];
        currentHash = data['sequence of mod-actions'][data['sequence of mod-actions'].length - 1].hashes.after;
        pageNr = data['current page-nr in its board'];
        totalPages = data['current #pages of the board'];
        renderCanvas();
      }
    };
  </script>
</body>
</html>
