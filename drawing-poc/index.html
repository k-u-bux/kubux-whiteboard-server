<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Xournal++ Clone</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      overflow: hidden;
    }
    
    .toolbar {
      display: flex;
      background-color: #f0f0f0;
      padding: 5px;
      border-bottom: 1px solid #ccc;
    }
    
    .tool-section {
      display: flex;
      margin-right: 10px;
      padding-right: 10px;
      border-right: 1px solid #ddd;
    }
    
    .tool-btn {
      width: 30px;
      height: 30px;
      margin: 0 2px;
      cursor: pointer;
      border: 1px solid transparent;
      background-color: transparent;
      border-radius: 4px;
    }
    
    .tool-btn:hover {
      background-color: #e0e0e0;
    }
    
    .tool-btn.active {
      border-color: #3498db;
      background-color: #ebf5fb;
    }
    
    .color-swatch {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      margin: 3px;
      cursor: pointer;
      border: 1px solid #ccc;
    }
    
    .color-swatch.active {
      border-color: #333;
      border-width: 2px;
    }
    
    #canvas-container {
      position: relative;
      flex-grow: 1;
      overflow: hidden;
    }
    
    canvas {
      position: absolute;
      background-color: white;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
    }
    
    .main-content {
      display: flex;
      height: calc(100vh - 42px);
    }
    
    #width-selector {
      width: 100px;
      margin: 0 10px;
    }
    
    .page-controls {
      display: flex;
      align-items: center;
    }
    
    #page-info {
      margin: 0 10px;
    }
    
    .error-banner {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background-color: #f44336;
      color: white;
      padding: 15px;
      text-align: center;
      z-index: 1000;
      display: none;
    }
    
    .error-banner button {
      margin-left: 15px;
      background-color: white;
      color: #f44336;
      border: none;
      padding: 5px 10px;
      cursor: pointer;
      border-radius: 4px;
    }
  </style>
</head>
<body>
  <div class="error-banner" id="error-banner">
    <span id="error-message">Connection error</span>
    <button id="reconnect-button">Reconnect</button>
  </div>
  
  <div class="toolbar">
    <!-- Tools Section -->
    <div class="tool-section">
      <button class="tool-btn active" id="pen-tool" title="Pen">‚úèÔ∏è</button>
      <button class="tool-btn" id="highlighter-tool" title="Highlighter">üñåÔ∏è</button>
      <button class="tool-btn" id="eraser-tool" title="Eraser">üßΩ</button>
    </div>
    
    <!-- Colors Section -->
    <div class="tool-section">
      <div class="color-swatch active" style="background-color: black;" data-color="#000000"></div>
      <div class="color-swatch" style="background-color: red;" data-color="#ff0000"></div>
      <div class="color-swatch" style="background-color: green;" data-color="#00ff00"></div>
      <div class="color-swatch" style="background-color: blue;" data-color="#0000ff"></div>
      <div class="color-swatch" style="background-color: yellow;" data-color="#ffff00"></div>
    </div>
    
    <!-- Width Section -->
    <div class="tool-section">
      <label for="width-selector">Width:</label>
      <input type="range" id="width-selector" min="1" max="10" value="2">
      <span id="width-value">2</span>
    </div>
    
    <!-- Page Controls -->
    <div class="tool-section page-controls">
      <button class="tool-btn" id="prev-page">‚óÄÔ∏è</button>
      <span id="page-info">Page 1 of 1</span>
      <button class="tool-btn" id="next-page">‚ñ∂Ô∏è</button>
      <button class="tool-btn" id="add-page">‚ûï</button>
      <button class="tool-btn" id="delete-page">‚ûñ</button>
    </div>
    
    <!-- Zoom Controls -->
    <div class="tool-section">
      <button class="tool-btn" id="zoom-out">-</button>
      <span id="zoom-level">100%</span>
      <button class="tool-btn" id="zoom-in">+</button>
    </div>
  </div>
  
  <div class="main-content">
    <div id="canvas-container">
      <canvas id="canvas"></canvas>
    </div>
  </div>

  <script src="shared.js"></script>
  <script>
    // Debug logging function
    function debugLog(msg, data) {
      console.log(`[DEBUG] ${msg}`, data || '');
    }

    // Globals for board state
    let ws = null;
    let boardId = null;
    let clientId = shared.generateUuid(); // Unique client identifier
    let currentPageUuid = null;
    let verifiedHash = '';
    let verifiedModActions = [];
    let optimisticUpdates = [];
    let pageNr = 1;
    let totalPages = 1;
    let lastDrawUuid = null;  // Track last drawn stroke UUID for eraser
    let pendingRequests = {}; // Track in-flight requests
    let connectionEstablished = false;
    
    // Drawing state
    let isDrawing = false;
    let currentPath = [];
    let currentStyle = {
      penType: shared.PEN_TYPES.MARKER,
      color: "#000000",
      opacity: 1.0,
      width: 2.0,
      capStyle: shared.CAP_STYLES.ROUND,
      joinStyle: shared.JOIN_STYLES.ROUND,
      dashPattern: [0],
      pressureSensitivity: 1.0,
      layer: 1
    };
    
    // Zoom state
    let zoomLevel = 1;
    
    // Tool state
    let currentTool = 'pen';
    let isErasing = false;
    let eraserRadius = 20;
    
    // DOM elements
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const container = document.getElementById('canvas-container');
    const widthSelector = document.getElementById('width-selector');
    const widthValue = document.getElementById('width-value');
    const zoomLevelDisplay = document.getElementById('zoom-level');
    const pageInfo = document.getElementById('page-info');
    const errorBanner = document.getElementById('error-banner');
    const errorMessage = document.getElementById('error-message');
    const reconnectButton = document.getElementById('reconnect-button');
    
    // Initialize 
    function init() {
      setupCanvas();
      setupWebSocket();
      setupEventListeners();
    }
    
    // Set up canvas size
    function setupCanvas() {
      resizeCanvas();
      window.addEventListener('resize', resizeCanvas);
    }
    
    // Resize canvas to fit window
    function resizeCanvas() {
      canvas.width = container.clientWidth;
      canvas.height = container.clientHeight;
      applyZoom();
      redrawCanvas();
    }
    
    // Apply zoom transform
    function applyZoom() {
      ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset transform
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.setTransform(zoomLevel, 0, 0, zoomLevel, 0, 0);
    }
    
    // Show error message
    function showError(message) {
      errorMessage.textContent = message;
      errorBanner.style.display = 'block';
    }
    
    // Hide error message
    function hideError() {
      errorBanner.style.display = 'none';
    }
    
    // Generate a unique request ID and register it
    function createRequestId() {
      const requestId = shared.generateUuid();
      pendingRequests[requestId] = true;
      return requestId;
    }
    
    // Reconnect WebSocket
    function reconnectWebSocket() {
      if (ws) {
        ws.close();
      }
      setupWebSocket();
      hideError();
    }
    
    // Set up WebSocket connection
    function setupWebSocket() {
      const urlParams = new URLSearchParams(window.location.search);
      boardId = urlParams.get('id') || shared.generateUuid();
      history.replaceState(null, null, `?id=${boardId}`);
      
      // Simplified WebSocket URL - no board ID in the path
      const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      const hostname = window.location.hostname || 'localhost';
      const wsUrl = `${wsProtocol}//${hostname}:3001/ws`;
      
      debugLog('Connecting to WebSocket:', wsUrl);
      
      ws = new WebSocket(wsUrl);
      connectionEstablished = false;
      
      ws.onopen = () => {
        debugLog('WebSocket connection established');
        // Register with the board immediately after connection
        registerBoard();
      };
      
      ws.onclose = () => {
        debugLog('Disconnected from server');
        connectionEstablished = false;
        showError('Connection to server lost. Please reconnect.');
      };
      
      ws.onerror = (error) => {
        console.error('WebSocket error:', error);
        connectionEstablished = false;
        showError('Failed to connect to server. Please check your connection.');
      };
      
      ws.onmessage = (event) => {
        const data = JSON.parse(event.data);
        debugLog('Received message:', data);
        
        // Handle the new board registration message
        if (data.type === shared.MESSAGES.SERVER_TO_CLIENT.BOARD_REGISTERED.TYPE) {
          handleBoardRegistered(data);
          return;
        }
        
        // Handle existing message types
        switch (data.type) {
          case shared.MESSAGES.SERVER_TO_CLIENT.ACCEPT_MESSAGE.TYPE:
            handleAcceptMessage(data);
            break;
          case shared.MESSAGES.SERVER_TO_CLIENT.DECLINE_MESSAGE.TYPE:
            handleDeclineMessage(data);
            break;
          case shared.MESSAGES.SERVER_TO_CLIENT.REPLAY_MESSAGE.TYPE:
            handleReplayMessage(data);
            break;
          case shared.MESSAGES.SERVER_TO_CLIENT.FULL_PAGE.TYPE:
            handleFullPageMessage(data);
            break;
          case shared.MESSAGES.SERVER_TO_CLIENT.PING.TYPE:
            // Just acknowledge pings
            break;
        }
      };
    }
    
    // Register with a board
    function registerBoard() {
      const requestId = createRequestId();
      
      const registerMessage = {
        type: shared.MESSAGES.CLIENT_TO_SERVER.REGISTER_BOARD.TYPE,
        [shared.MESSAGES.CLIENT_TO_SERVER.REGISTER_BOARD.BOARD_ID]: boardId,
        [shared.MESSAGES.CLIENT_TO_SERVER.REGISTER_BOARD.CLIENT_ID]: clientId,
        [shared.MESSAGES.CLIENT_TO_SERVER.REGISTER_BOARD.REQUEST_ID]: requestId
      };
      
      debugLog('Sending board registration:', registerMessage);
      ws.send(JSON.stringify(registerMessage));
    }
    
    // Handle board registration response
    function handleBoardRegistered(data) {
      debugLog('Board registered successfully');
      connectionEstablished = true;
      hideError();
      
      // Remove the request from pending
      const requestId = data[shared.MESSAGES.SERVER_TO_CLIENT.BOARD_REGISTERED.REQUEST_ID];
      delete pendingRequests[requestId];
      
      // Reset local state - server will send us a full page message after registration
      verifiedModActions = [];
      optimisticUpdates = [];
      verifiedHash = '';
      
      // The server might update our boardId (e.g., if we connected with a new one)
      boardId = data[shared.MESSAGES.SERVER_TO_CLIENT.BOARD_REGISTERED.BOARD_ID];
      
      // If the URL doesn't match our boardId, update it
      const urlParams = new URLSearchParams(window.location.search);
      if (urlParams.get('id') !== boardId) {
        history.replaceState(null, null, `?id=${boardId}`);
      }
    }
    
    // Handle accept message from server
    function handleAcceptMessage(data) {
      const acceptedActionUuid = data[shared.MESSAGES.SERVER_TO_CLIENT.ACCEPT_MESSAGE.ACTION_UUID];
      const acceptedAction = optimisticUpdates.find(a => 
        a[shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.ACTION_UUID] === acceptedActionUuid
      );
      
      if (acceptedAction) {
        // Move action from optimistic to verified
        optimisticUpdates = optimisticUpdates.filter(a => 
          a[shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.ACTION_UUID] !== acceptedActionUuid
        );
        
        // Update hash values
        acceptedAction.hashes = {
          [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.BEFORE_HASH]: 
            data[shared.MESSAGES.SERVER_TO_CLIENT.ACCEPT_MESSAGE.BEFORE_HASH],
          [shared.MESSAGES.SERVER_TO_CLIENT.ACCEPT_MESSAGE.AFTER_HASH]: 
            data[shared.MESSAGES.SERVER_TO_CLIENT.ACCEPT_MESSAGE.AFTER_HASH]
        };
        
        verifiedModActions.push(acceptedAction);
        verifiedHash = data[shared.MESSAGES.SERVER_TO_CLIENT.ACCEPT_MESSAGE.AFTER_HASH];
        
        // Update page info
        pageNr = data[shared.MESSAGES.SERVER_TO_CLIENT.ACCEPT_MESSAGE.CURRENT_PAGE_NR];
        totalPages = data[shared.MESSAGES.SERVER_TO_CLIENT.ACCEPT_MESSAGE.CURRENT_TOTAL_PAGES];
        updatePageInfo();
      } else {
        // Request replay if we don't know about this action
        requestReplay(currentPageUuid, verifiedHash);
      }
      
      redrawCanvas();
    }
    
    // Handle decline message from server
    function handleDeclineMessage(data) {
      const declinedActionUuid = data[shared.MESSAGES.SERVER_TO_CLIENT.DECLINE_MESSAGE.ACTION_UUID];
      
      // Remove declined action from optimistic updates
      optimisticUpdates = optimisticUpdates.filter(a => 
        a[shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.ACTION_UUID] !== declinedActionUuid
      );
      
      // Request replay to ensure we're in sync
      requestReplay(currentPageUuid, verifiedHash);
      redrawCanvas();
    }
    
    // Handle replay message from server
    function handleReplayMessage(data) {
      const replayActions = data[shared.MESSAGES.SERVER_TO_CLIENT.REPLAY_MESSAGE.SEQUENCE];
      verifiedHash = data[shared.MESSAGES.SERVER_TO_CLIENT.REPLAY_MESSAGE.AFTER_HASH];
      
      // Apply replayed actions
      if (Array.isArray(replayActions)) {
        verifiedModActions = verifiedModActions.concat(replayActions);
      }
      
      // Update page info
      if (data[shared.MESSAGES.SERVER_TO_CLIENT.REPLAY_MESSAGE.CURRENT_PAGE_NR]) {
        pageNr = data[shared.MESSAGES.SERVER_TO_CLIENT.REPLAY_MESSAGE.CURRENT_PAGE_NR];
      }
      if (data[shared.MESSAGES.SERVER_TO_CLIENT.REPLAY_MESSAGE.CURRENT_TOTAL_PAGES]) {
        totalPages = data[shared.MESSAGES.SERVER_TO_CLIENT.REPLAY_MESSAGE.CURRENT_TOTAL_PAGES];
      }
      updatePageInfo();
      
      redrawCanvas();
    }
    
    // Handle full page message from server
    function handleFullPageMessage(data) {
      const pageUuid = data[shared.MESSAGES.SERVER_TO_CLIENT.FULL_PAGE.PAGE];
      const modActions = data[shared.MESSAGES.SERVER_TO_CLIENT.FULL_PAGE.STATE];
      const afterHash = data[shared.MESSAGES.SERVER_TO_CLIENT.FULL_PAGE.HASH];
      
      // Replace current page data
      currentPageUuid = pageUuid;
      verifiedModActions = Array.isArray(modActions) ? modActions : [];
      optimisticUpdates = [];
      verifiedHash = afterHash;
      
      // Update page info
      pageNr = data[shared.MESSAGES.SERVER_TO_CLIENT.FULL_PAGE.PAGE_NR];
      totalPages = data[shared.MESSAGES.SERVER_TO_CLIENT.FULL_PAGE.TOTAL_PAGES];
      updatePageInfo();
      
      redrawCanvas();
    }
    
    // Send a message to the server
    function sendMessage(message) {
      if (!connectionEstablished) {
        showError('Not connected to server. Please reconnect.');
        return false;
      }
      
      // Add boardId to all outgoing messages
      message.boardId = boardId;
      
      debugLog('Sending message:', message);
      ws.send(JSON.stringify(message));
      return true;
    }
    
    // Set up event listeners
    function setupEventListeners() {
      // Reconnect button
      reconnectButton.addEventListener('click', reconnectWebSocket);
      
      // Tool selection
      document.getElementById('pen-tool').addEventListener('click', () => setTool('pen'));
      document.getElementById('highlighter-tool').addEventListener('click', () => setTool('highlighter'));
      document.getElementById('eraser-tool').addEventListener('click', () => setTool('eraser'));
      
      // Color selection
      const colorSwatches = document.querySelectorAll('.color-swatch');
      colorSwatches.forEach(swatch => {
        swatch.addEventListener('click', () => {
          colorSwatches.forEach(s => s.classList.remove('active'));
          swatch.classList.add('active');
          currentStyle.color = swatch.dataset.color;
        });
      });
      
      // Width selection
      widthSelector.addEventListener('input', () => {
        const width = parseInt(widthSelector.value);
        widthValue.textContent = width;
        currentStyle.width = width;
      });
      
      // Page navigation
      document.getElementById('prev-page').addEventListener('click', () => navigateToPage(pageNr - 1));
      document.getElementById('next-page').addEventListener('click', () => navigateToPage(pageNr + 1));
      document.getElementById('add-page').addEventListener('click', addNewPage);
      document.getElementById('delete-page').addEventListener('click', deletePage);
      
      // Zoom controls
      document.getElementById('zoom-in').addEventListener('click', () => adjustZoom(0.1));
      document.getElementById('zoom-out').addEventListener('click', () => adjustZoom(-0.1));
      
      // Canvas events
      canvas.addEventListener('pointerdown', handlePointerDown);
      canvas.addEventListener('pointermove', handlePointerMove);
      canvas.addEventListener('pointerup', handlePointerUp);
      canvas.addEventListener('pointerleave', handlePointerUp);
      
      // Prevent default touch behaviors
      canvas.addEventListener('touchstart', e => e.preventDefault());
      canvas.addEventListener('touchmove', e => e.preventDefault());
      canvas.addEventListener('touchend', e => e.preventDefault());
    }
    
    // Set current tool
    function setTool(tool) {
      currentTool = tool;
      
      // Update UI
      document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
      document.getElementById(`${tool}-tool`).classList.add('active');
      
      // Set appropriate styles for the tool
      switch (tool) {
        case 'pen':
          currentStyle = {
            ...currentStyle,
            penType: shared.PEN_TYPES.MARKER,
            opacity: 1.0,
            capStyle: shared.CAP_STYLES.ROUND,
            joinStyle: shared.JOIN_STYLES.ROUND
          };
          break;
        case 'highlighter':
          currentStyle = {
            ...currentStyle,
            penType: shared.PEN_TYPES.HIGHLIGHTER,
            opacity: 0.5,
            capStyle: shared.CAP_STYLES.SQUARE,
            joinStyle: shared.JOIN_STYLES.ROUND
          };
          break;
      }
      
      // Update cursor
      switch (tool) {
        case 'pen':
          canvas.style.cursor = 'crosshair';
          break;
        case 'highlighter':
          canvas.style.cursor = 'crosshair';
          break;
        case 'eraser':
          canvas.style.cursor = 'cell';
          break;
      }
    }
    
    // Adjust zoom level
    function adjustZoom(delta) {
      zoomLevel = Math.max(0.5, Math.min(3, zoomLevel + delta));
      zoomLevelDisplay.textContent = `${Math.round(zoomLevel * 100)}%`;
      applyZoom();
      redrawCanvas();
    }
    
    // Update page info display
    function updatePageInfo() {
      pageInfo.textContent = `Page ${pageNr} of ${totalPages}`;
    }
    
    // Handle pointer down event
    function handlePointerDown(event) {
      const rect = canvas.getBoundingClientRect();
      const x = (event.clientX - rect.left) / zoomLevel;
      const y = (event.clientY - rect.top) / zoomLevel;
      const pressure = event.pressure !== undefined ? event.pressure : 1.0;
      
      if (currentTool === 'eraser') {
        isErasing = true;
        
        // Find strokes near this point and erase them
        const strokeUuid = findStrokeToErase(x, y);
        if (strokeUuid) {
          sendEraseAction(strokeUuid);
        }
      } else {
        isDrawing = true;
        currentPath = [];
        
        const point = {
          x: x,
          y: y,
          pressure: pressure,
          timestamp: Date.now()
        };
        
        currentPath.push(point);
      }
    }
    
    // Handle pointer move event
    function handlePointerMove(event) {
      const rect = canvas.getBoundingClientRect();
      const x = (event.clientX - rect.left) / zoomLevel;
      const y = (event.clientY - rect.top) / zoomLevel;
      const pressure = event.pressure !== undefined ? event.pressure : 1.0;
      
      if (currentTool === 'eraser' && isErasing) {
        // Find strokes near this point and erase them
        const strokeUuid = findStrokeToErase(x, y);
        if (strokeUuid) {
          sendEraseAction(strokeUuid);
        }
      } else if (isDrawing) {
        const point = {
          x: x,
          y: y,
          pressure: pressure,
          timestamp: Date.now()
        };
        
        currentPath.push(point);
        drawStroke({
          points: currentPath.slice(-2),
          style: currentStyle
        });
      }
    }
    
    // Handle pointer up event
    function handlePointerUp() {
      if (currentTool === 'eraser') {
        isErasing = false;
      } else if (isDrawing) {
        isDrawing = false;
        
        if (currentPath.length >= 2) {
          const stroke = {
            points: currentPath,
            style: currentStyle
          };
          
          sendStroke(stroke);
        }
        
        currentPath = [];
      }
    }
    
    // Find a stroke to erase at the given position
    function findStrokeToErase(x, y) {
      // Combine verified and optimistic actions
      const allActions = [...verifiedModActions, ...optimisticUpdates];
      
      // Find the most recent DRAW action with a stroke near this point
      for (let i = allActions.length - 1; i >= 0; i--) {
        const action = allActions[i];
        if (!action[shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD]) continue;
        
        const payload = action[shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD];
        if (payload.type === shared.MOD_ACTIONS.DRAW.TYPE) {
          const stroke = payload.stroke;
          if (isPointNearStroke(x, y, stroke)) {
            return action[shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.ACTION_UUID];
          }
        }
      }
      
      return null;
    }
    
    // Check if a point is near a stroke
    function isPointNearStroke(x, y, stroke) {
      if (!stroke || !stroke.points || stroke.points.length < 2) return false;
      
      const threshold = eraserRadius;
      
      // Check each segment of the stroke
      for (let i = 1; i < stroke.points.length; i++) {
        const p1 = stroke.points[i - 1];
        const p2 = stroke.points[i];
        
        // Calculate distance from point to line segment
        const distance = distanceToLineSegment(x, y, p1.x, p1.y, p2.x, p2.y);
        if (distance < threshold) {
          return true;
        }
      }
      
      return false;
    }
    
    // Calculate distance from point to line segment
    function distanceToLineSegment(px, py, x1, y1, x2, y2) {
      const A = px - x1;
      const B = py - y1;
      const C = x2 - x1;
      const D = y2 - y1;
      
      const dot = A * C + B * D;
      const lenSq = C * C + D * D;
      let param = -1;
      
      if (lenSq !== 0) {
        param = dot / lenSq;
      }
      
      let xx, yy;
      
      if (param < 0) {
        xx = x1;
        yy = y1;
      } else if (param > 1) {
        xx = x2;
        yy = y2;
      } else {
        xx = x1 + param * C;
        yy = y1 + param * D;
      }
      
      const dx = px - xx;
      const dy = py - yy;
      
      return Math.sqrt(dx * dx + dy * dy);
    }
    
    // Send an erase action to the server
    function sendEraseAction(strokeUuid) {
      if (!strokeUuid) return;
      
      const actionUuid = shared.generateUuid();
      
      // Create the erase action in the format the server expects
      const action = {
        type: shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.TYPE,
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.ACTION_TYPE]: shared.MOD_ACTIONS.ERASE.TYPE,
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAGE_UUID]: currentPageUuid,
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.ACTION_UUID]: actionUuid,
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.BEFORE_HASH]: verifiedHash,
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD]: {
          type: shared.MOD_ACTIONS.ERASE.TYPE,
          [shared.MOD_ACTIONS.ERASE.ACTION_UUID]: strokeUuid
        }
      };
      
      // Calculate expected hash
      const nextHash = shared.hashNext(verifiedHash, action[shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD]);
      
      // Add to optimistic updates
      const optimisticAction = {
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.ACTION_UUID]: actionUuid,
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD]: action[shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD],
        hashes: {
          [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.BEFORE_HASH]: verifiedHash,
          [shared.MESSAGES.SERVER_TO_CLIENT.ACCEPT_MESSAGE.AFTER_HASH]: nextHash
        }
      };
      
      optimisticUpdates.push(optimisticAction);
      
      // Send to server
      sendMessage(action);
      
      // Immediately redraw with the stroke removed
      redrawCanvas();
    }
    
    // Send a stroke to the server
    function sendStroke(stroke) {
      const actionUuid = shared.generateUuid();
      lastDrawUuid = actionUuid; // Store for eraser
      
      const action = {
        type: shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.TYPE,
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.ACTION_TYPE]: shared.MOD_ACTIONS.DRAW.TYPE,
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAGE_UUID]: currentPageUuid,
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.ACTION_UUID]: actionUuid,
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.BEFORE_HASH]: verifiedHash,
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD]: {
          type: shared.MOD_ACTIONS.DRAW.TYPE,
          stroke: stroke
        }
      };
      
      // Calculate expected hash
      const nextHash = shared.hashNext(verifiedHash, action[shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD]);
      
      // Add to optimistic updates
      const optimisticAction = {
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.ACTION_UUID]: actionUuid,
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD]: action[shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD],
        hashes: {
          [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.BEFORE_HASH]: verifiedHash,
          [shared.MESSAGES.SERVER_TO_CLIENT.ACCEPT_MESSAGE.AFTER_HASH]: nextHash
        }
      };
      
      optimisticUpdates.push(optimisticAction);
      
      // Send to server
      sendMessage(action);
    }
    
    // Add a new page
    function addNewPage() {
      const actionUuid = shared.generateUuid();
      
      const action = {
        type: shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.TYPE,
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.ACTION_TYPE]: shared.MOD_ACTIONS.NEW_PAGE.TYPE,
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAGE_UUID]: currentPageUuid,
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.ACTION_UUID]: actionUuid,
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.BEFORE_HASH]: verifiedHash,
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD]: {
          type: shared.MOD_ACTIONS.NEW_PAGE.TYPE
        }
      };
      
      debugLog('Sending new page action', action);
      sendMessage(action);
    }
    
    // Delete current page
    function deletePage() {
      if (totalPages <= 1) {
        alert("Cannot delete the only page");
        return;
      }
      
      const actionUuid = shared.generateUuid();
      
      const action = {
        type: shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.TYPE,
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.ACTION_TYPE]: shared.MOD_ACTIONS.DELETE_PAGE.TYPE,
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAGE_UUID]: currentPageUuid,
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.ACTION_UUID]: actionUuid,
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.BEFORE_HASH]: verifiedHash,
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD]: {
          type: shared.MOD_ACTIONS.DELETE_PAGE.TYPE
        }
      };
      
      // Send to server
      debugLog('Sending delete page action', action);
      sendMessage(action);
    }
    
    // Navigate to a specific page
    function navigateToPage(pageNumber) {
      if (pageNumber < 1 || pageNumber > totalPages) {
        return;
      }
      
      const requestId = createRequestId();
      
      // Using the structure the server expects for page requests, with boardId
      const fullPageRequest = {
        type: shared.MESSAGES.CLIENT_TO_SERVER.FULL_PAGE_REQUESTS.TYPE,
        boardId: boardId, // Add boardId explicitly
        [shared.MESSAGES.CLIENT_TO_SERVER.FULL_PAGE_REQUESTS.PAGE_NUMBER]: pageNumber,
        [shared.MESSAGES.CLIENT_TO_SERVER.FULL_PAGE_REQUESTS.REQUEST_ID]: requestId
      };
      
      debugLog('Sending page request', fullPageRequest);
      sendMessage(fullPageRequest);
    }
    
    // Request replay from server
    function requestReplay(pageUuid, beforeHash) {
      const requestId = createRequestId();
      
      const replayMessage = {
        type: shared.MESSAGES.CLIENT_TO_SERVER.REPLAY_REQUESTS.TYPE,
        boardId: boardId, // Add boardId explicitly
        [shared.MESSAGES.CLIENT_TO_SERVER.REPLAY_REQUESTS.PAGE_UUID]: pageUuid,
        [shared.MESSAGES.CLIENT_TO_SERVER.REPLAY_REQUESTS.BEFORE_HASH]: beforeHash,
        [shared.MESSAGES.CLIENT_TO_SERVER.REPLAY_REQUESTS.REQUEST_ID]: requestId
      };
      
      sendMessage(replayMessage);
    }
    
    // Draw a stroke on the canvas
    function drawStroke(stroke) {
      if (!stroke || !stroke.points || stroke.points.length < 2) return;
      
      const style = stroke.style;
      
      ctx.save();
      
      // Apply style
      ctx.strokeStyle = style.color;
      ctx.lineWidth = style.width;
      
      if (style.penType === shared.PEN_TYPES.HIGHLIGHTER) {
        ctx.globalAlpha = 0.5;
        ctx.lineJoin = shared.JOIN_STYLES.ROUND;
        ctx.lineCap = shared.CAP_STYLES.SQUARE;
      } else {
        ctx.globalAlpha = style.opacity;
        ctx.lineJoin = style.joinStyle;
        ctx.lineCap = style.capStyle;
      }
      
      if (style.dashPattern && style.dashPattern.length > 1) {
        ctx.setLineDash(style.dashPattern);
      } else {
        ctx.setLineDash([]);
      }
      
      // Draw the stroke
      ctx.beginPath();
      ctx.moveTo(stroke.points[0].x, stroke.points[0].y);
      
      for (let i = 1; i < stroke.points.length; i++) {
        const point = stroke.points[i];
        
        // Apply pressure sensitivity if available
        if (style.pressureSensitivity > 0 && point.pressure !== undefined) {
          const pressureEffect = 1 + (point.pressure - 1) * style.pressureSensitivity;
          ctx.lineWidth = style.width * pressureEffect;
        }
        
        ctx.lineTo(point.x, point.y);
      }
      
      ctx.stroke();
      ctx.restore();
    }
    
    // Redraw the entire canvas
    function redrawCanvas() {
      ctx.save();
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.restore();
      
      // Get list of all stroke UUIDs that have been erased
      const erasedStrokes = [];
      const allActions = [...verifiedModActions, ...optimisticUpdates];
      
      for (const action of allActions) {
        if (!action[shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD]) continue;
        
        const payload = action[shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD];
        if (payload.type === shared.MOD_ACTIONS.ERASE.TYPE && payload[shared.MOD_ACTIONS.ERASE.ACTION_UUID]) {
          erasedStrokes.push(payload[shared.MOD_ACTIONS.ERASE.ACTION_UUID]);
        }
      }
      
      // Draw all non-erased strokes
      for (const action of allActions) {
        if (!action[shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD]) continue;
        
        // Skip drawing if this stroke has been erased
        if (erasedStrokes.includes(action[shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.ACTION_UUID])) {
          continue;
        }
        
        const payload = action[shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD];
        if (payload.type === shared.MOD_ACTIONS.DRAW.TYPE) {
          drawStroke(payload.stroke);
        }
      }
    }
    
    // Initialize the app
    window.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>
