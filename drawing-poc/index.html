<!DOCTYPE html>
<html>
<head>
  <title>Drawing PoC</title>
  <style>
    body {
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      margin: 0;
      gap: 10px;
    }
    #controls {
      display: flex;
      gap: 10px;
      margin-top: 10px;
    }
    #page-controls {
      display: flex;
      gap: 10px;
    }
    canvas {
      border: 1px solid black;
      cursor: crosshair;
    }
    button {
      padding: 10px;
      font-size: 14px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <h1>Whiteboard <span id="page-info"></span></h1>
  <div id="controls">
    <button id="pen-tool">Pen</button>
    <button id="eraser-tool">Eraser</button>
  </div>
  <canvas id="whiteboard" width="800" height="600"></canvas>
  <div id="page-controls">
    <button id="prev-page">Previous Page</button>
    <button id="next-page">Next Page</button>
    <button id="delete-page">Delete Page</button>
    <button id="insert-page">Insert Page</button>
  </div>
  
  <script src="./shared.js"></script>
  <script>
    const canvas = document.getElementById('whiteboard');
    const ctx = canvas.getContext('2d');
    const pageInfo = document.getElementById('page-info');
    const penTool = document.getElementById('pen-tool');
    const eraserTool = document.getElementById('eraser-tool');
    const prevPageBtn = document.getElementById('prev-page');
    const nextPageBtn = document.getElementById('next-page');
    const deletePageBtn = document.getElementById('delete-page');
    const insertPageBtn = document.getElementById('insert-page');

    const path = window.location.pathname;
    const ws = new WebSocket(`ws://${window.location.hostname}:3001${path}`);

    let isDrawing = false;
    let currentStrokePoints = [];
    let tool = shared.MOD_ACTIONS.DRAW.TYPE;
    let isInitialized = false;
    
    let verifiedModActions = [];
    let optimisticUpdates = [];
    let currentPageId = '';
    let verifiedHash = '';
    let pageNr = 0;
    let totalPages = 0;
    
    function logEvent(message, data) {
      console.log(`[EVENT] ${message}`, data);
    }
    
    function logMessage(direction, type, data) {
      console.log(`[MESSAGE ${direction}] Type: ${type}, Data:`, data);
    }

    function setControlsEnabled(enabled) {
      logEvent('Setting controls enabled state', enabled);
      canvas.style.pointerEvents = enabled ? 'auto' : 'none';
      penTool.disabled = !enabled;
      eraserTool.disabled = !enabled;
      prevPageBtn.disabled = !enabled || pageNr <= 1;
      nextPageBtn.disabled = !enabled || pageNr >= totalPages;
      deletePageBtn.disabled = !enabled || totalPages <= 1;
      insertPageBtn.disabled = !enabled;
    }
    setControlsEnabled(false);

    function drawStroke(stroke) {
      if (stroke.points.length > 1) {
        ctx.beginPath();
        ctx.moveTo(stroke.points[0].x, stroke.points[0].y);
        ctx.lineWidth = 2;
        ctx.lineCap = 'round';
        ctx.strokeStyle = 'black';
        stroke.points.forEach(point => ctx.lineTo(point.x, point.y));
        ctx.stroke();
      }
    }
    
    function renderCanvas() {
      logEvent('Rendering canvas');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const allActions = [...verifiedModActions, ...optimisticUpdates];
      allActions.forEach(action => {
        if (action.payload.type === shared.MOD_ACTIONS.DRAW.TYPE) {
          drawStroke(action.payload);
        }
      });
      updateUI();
    }
    
    function updateUI() {
        logEvent('Updating UI with new page information');
        pageInfo.textContent = `page ${pageNr} of ${totalPages}`;
        prevPageBtn.disabled = pageNr <= 1;
        nextPageBtn.disabled = pageNr >= totalPages;
        deletePageBtn.disabled = totalPages <= 1;
    }

    function findStrokeAt(x, y) {
      const allStrokes = [...verifiedModActions, ...optimisticUpdates];
      for (const action of allStrokes) {
        if (action.payload.type === shared.MOD_ACTIONS.DRAW.TYPE) {
          const points = action.payload.points;
          for (let i = 0; i < points.length - 1; i++) {
            const p1 = points[i];
            const p2 = points[i+1];
            
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            const length = Math.sqrt(dx * dx + dy * dy);
            
            const t = ((x - p1.x) * dx + (y - p1.y) * dy) / (length * length);
            
            let closestX, closestY;
            if (t < 0) {
              closestX = p1.x;
              closestY = p1.y;
            } else if (t > 1) {
              closestX = p2.x;
              closestY = p2.y;
            } else {
              closestX = p1.x + t * dx;
              closestY = p1.y + t * dy;
            }
            
            const dist = Math.sqrt((x - closestX) ** 2 + (y - closestY) ** 2);
            if (dist < 10) {
              return action;
            }
          }
        }
      }
      return null;
    }

    function sendModActionProposal(type, payload) {
      if (!isInitialized) return;
      logEvent(`Sending mod action proposal for type: ${type}`);
      const actionUuid = shared.generateUuid();
      
      const combinedActions = [...verifiedModActions.map(a => a.payload), ...optimisticUpdates.map(a => a.payload)];
      const beforeHash = shared.calculateHash(combinedActions);
      
      const proposal = {
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.ACTION_UUID]: actionUuid,
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD]: { type: type, ...payload },
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.BEFORE_HASH]: beforeHash
      };
      
      if (type === shared.MOD_ACTIONS.DRAW.TYPE) {
        optimisticUpdates.push(proposal);
      } else if (type === shared.MOD_ACTIONS.ERASE.TYPE) {
        const erasedActionUuid = payload[shared.MOD_ACTIONS.ERASE.ACTION_UUID];
        const verifiedAction = verifiedModActions.find(a => a[shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.ACTION_UUID] === erasedActionUuid);
        if (verifiedAction) {
          logEvent('Optimistically removing verified action from client state.');
          verifiedModActions = verifiedModActions.filter(a => a[shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.ACTION_UUID] !== erasedActionUuid);
        } else {
          logEvent('Optimistically removing optimistic action from client state.');
          optimisticUpdates = optimisticUpdates.filter(a => a[shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.ACTION_UUID] !== erasedActionUuid);
        }
      }
      
      renderCanvas();

      const message = {
          type: shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.TYPE,
          [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAGE_UUID]: currentPageId,
          [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.ACTION_UUID]: proposal[shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.ACTION_UUID],
          [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD]: proposal[shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD],
          [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.BEFORE_HASH]: proposal[shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.BEFORE_HASH],
      };
      
      try {
        ws.send(JSON.stringify(message));
        logMessage('CLIENT -> SERVER', message.type, message);
      } catch (e) {
          console.error('Failed to send message to server:', e);
      }
    }

    penTool.addEventListener('click', () => {
      logEvent('Pen tool clicked.');
      tool = shared.MOD_ACTIONS.DRAW.TYPE;
      canvas.style.cursor = 'crosshair';
    });
    eraserTool.addEventListener('click', () => {
      logEvent('Eraser tool clicked.');
      tool = shared.MOD_ACTIONS.ERASE.TYPE;
      canvas.style.cursor = 'cell';
    });

    canvas.addEventListener('mousedown', e => {
      if (!isInitialized) return;
      logEvent('Mouse down on canvas');
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      if (tool === shared.MOD_ACTIONS.DRAW.TYPE) {
        isDrawing = true;
        currentStrokePoints.push({ x, y });
        ctx.beginPath();
        ctx.moveTo(x, y);
      } else if (tool === shared.MOD_ACTIONS.ERASE.TYPE) {
        const erasedAction = findStrokeAt(x, y);
        if (erasedAction) {
          sendModActionProposal(shared.MOD_ACTIONS.ERASE.TYPE, { [shared.MOD_ACTIONS.ERASE.ACTION_UUID]: erasedAction[shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.ACTION_UUID] });
        }
      }
    });

    canvas.addEventListener('mousemove', e => {
      if (!isInitialized) return;
      if (tool === shared.MOD_ACTIONS.DRAW.TYPE && isDrawing) {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        currentStrokePoints.push({ x, y });
        ctx.lineTo(x, y);
        ctx.stroke();
      }
    });
    
    window.addEventListener('mouseup', () => {
      if (!isInitialized) return;
      logEvent('Mouse up event.');
      if (tool === shared.MOD_ACTIONS.DRAW.TYPE && isDrawing) {
        if (currentStrokePoints.length > 1) {
          sendModActionProposal(shared.MOD_ACTIONS.DRAW.TYPE, { points: currentStrokePoints });
        }
        currentStrokePoints = [];
      }
      isDrawing = false;
    });

    canvas.addEventListener('mouseleave', () => {
        if (!isInitialized) return;
        logEvent('Mouse left canvas.');
        if (tool === shared.MOD_ACTIONS.DRAW.TYPE && isDrawing) {
            if (currentStrokePoints.length > 1) {
                sendModActionProposal(shared.MOD_ACTIONS.DRAW.TYPE, { points: currentStrokePoints });
            }
            currentStrokePoints = [];
            isDrawing = false;
        }
    });

    prevPageBtn.addEventListener('click', () => {
        if (!isInitialized) return;
        logEvent('Previous page button clicked.');
        const message = { 
            type: shared.MESSAGES.CLIENT_TO_SERVER.FULL_PAGE_REQUESTS.TYPE,
            [shared.MESSAGES.CLIENT_TO_SERVER.FULL_PAGE_REQUESTS.BOARD_UUID]: '1', 
            [shared.MESSAGES.CLIENT_TO_SERVER.FULL_PAGE_REQUESTS.PAGE_ID]: currentPageId, 
            [shared.MESSAGES.CLIENT_TO_SERVER.FULL_PAGE_REQUESTS.DELTA]: -1, 
            [shared.MESSAGES.CLIENT_TO_SERVER.FULL_PAGE_REQUESTS.REQUEST_ID]: shared.generateUuid() 
        };
        try {
            ws.send(JSON.stringify(message));
            logMessage('CLIENT -> SERVER', message.type, message);
        } catch (e) {
            console.error('Failed to send previous page request:', e);
        }
    });
    nextPageBtn.addEventListener('click', () => {
        if (!isInitialized) return;
        logEvent('Next page button clicked.');
        const message = { 
            type: shared.MESSAGES.CLIENT_TO_SERVER.FULL_PAGE_REQUESTS.TYPE,
            [shared.MESSAGES.CLIENT_TO_SERVER.FULL_PAGE_REQUESTS.BOARD_UUID]: '1', 
            [shared.MESSAGES.CLIENT_TO_SERVER.FULL_PAGE_REQUESTS.PAGE_ID]: currentPageId, 
            [shared.MESSAGES.CLIENT_TO_SERVER.FULL_PAGE_REQUESTS.DELTA]: 1, 
            [shared.MESSAGES.CLIENT_TO_SERVER.FULL_PAGE_REQUESTS.REQUEST_ID]: shared.generateUuid() 
        };
        try {
            ws.send(JSON.stringify(message));
            logMessage('CLIENT -> SERVER', message.type, message);
        } catch (e) {
            console.error('Failed to send next page request:', e);
        }
    });
    deletePageBtn.addEventListener('click', () => {
        if (!isInitialized) return;
        logEvent('Delete page button clicked.');
        sendModActionProposal(shared.MOD_ACTIONS.DELETE_PAGE.TYPE, {});
    });
    insertPageBtn.addEventListener('click', () => {
        if (!isInitialized) return;
        logEvent('Insert page button clicked.');
        sendModActionProposal(shared.MOD_ACTIONS.NEW_PAGE.TYPE, {});
    });

    ws.onmessage = event => {
      const data = JSON.parse(event.data);
      logMessage('SERVER -> CLIENT', data.type, data);
      
      if (data.type === shared.MESSAGES.SERVER_TO_CLIENT.FULL_PAGE.TYPE) {
        logEvent('Received a FULL_PAGE message. Initializing/re-syncing state.');
        verifiedModActions = data[shared.MESSAGES.SERVER_TO_CLIENT.FULL_PAGE.STATE];
        optimisticUpdates = [];
        currentPageId = data[shared.MESSAGES.SERVER_TO_CLIENT.FULL_PAGE.PAGE];
        verifiedHash = data[shared.MESSAGES.SERVER_TO_CLIENT.FULL_PAGE.HASH];
        pageNr = data[shared.MESSAGES.SERVER_TO_CLIENT.FULL_PAGE.PAGE_NR];
        totalPages = data[shared.MESSAGES.SERVER_TO_CLIENT.FULL_PAGE.TOTAL_PAGES];
        isInitialized = true;
        setControlsEnabled(true);
        renderCanvas();
      } else if (data.type === shared.MESSAGES.SERVER_TO_CLIENT.ACCEPT_MESSAGE.TYPE) {
        logEvent('Received an ACCEPT_MESSAGE. Processing update.');
        const acceptedAction = optimisticUpdates.find(a => a[shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.ACTION_UUID] === data[shared.MESSAGES.SERVER_TO_CLIENT.ACCEPT_MESSAGE.ACTION_UUID]);
        if (acceptedAction) {
          logEvent('Found accepted action in optimistic updates. Moving to verified.');
          verifiedModActions.push(acceptedAction);
          optimisticUpdates = optimisticUpdates.filter(a => a[shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.ACTION_UUID] !== data[shared.MESSAGES.SERVER_TO_CLIENT.ACCEPT_MESSAGE.ACTION_UUID]);
          verifiedHash = data[shared.MESSAGES.SERVER_TO_CLIENT.ACCEPT_MESSAGE.AFTER_HASH];
          renderCanvas();
        } else if (data[shared.MESSAGES.SERVER_TO_CLIENT.ACCEPT_MESSAGE.BEFORE_HASH] !== verifiedHash) {
          logEvent('Hash mismatch detected after receiving accept message. Requesting replay.');
          const replayMessage = { 
              type: shared.MESSAGES.CLIENT_TO_SERVER.REPLAY_REQUESTS.TYPE, 
              [shared.MESSAGES.CLIENT_TO_SERVER.REPLAY_REQUESTS.PAGE_UUID]: currentPageId, 
              [shared.MESSAGES.CLIENT_TO_SERVER.REPLAY_REQUESTS.BEFORE_HASH]: verifiedHash, 
              [shared.MESSAGES.CLIENT_TO_SERVER.REPLAY_REQUESTS.REQUEST_ID]: shared.generateUuid() 
          };
          ws.send(JSON.stringify(replayMessage));
          logMessage('CLIENT -> SERVER', replayMessage.type, replayMessage);
        } else {
          logEvent('Accepted message matches current state. Updating verified hash.');
          verifiedHash = data[shared.MESSAGES.SERVER_TO_CLIENT.ACCEPT_MESSAGE.AFTER_HASH];
        }
        pageNr = data[shared.MESSAGES.SERVER_TO_CLIENT.ACCEPT_MESSAGE.CURRENT_PAGE_NR];
        totalPages = data[shared.MESSAGES.SERVER_TO_CLIENT.ACCEPT_MESSAGE.CURRENT_TOTAL_PAGES];
        updateUI();
      } else if (data.type === shared.MESSAGES.SERVER_TO_CLIENT.DECLINE_MESSAGE.TYPE) {
        logEvent('Received a DECLINE_MESSAGE. Re-syncing and requesting replay.');
        optimisticUpdates = optimisticUpdates.filter(a => a[shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.ACTION_UUID] !== data[shared.MESSAGES.SERVER_TO_CLIENT.DECLINE_MESSAGE.ACTION_UUID]);
        const replayMessage = { 
            type: shared.MESSAGES.CLIENT_TO_SERVER.REPLAY_REQUESTS.TYPE, 
            [shared.MESSAGES.CLIENT_TO_SERVER.REPLAY_REQUESTS.PAGE_UUID]: currentPageId, 
            [shared.MESSAGES.CLIENT_TO_SERVER.REPLAY_REQUESTS.BEFORE_HASH]: verifiedHash, 
            [shared.MESSAGES.CLIENT_TO_SERVER.REPLAY_REQUESTS.REQUEST_ID]: shared.generateUuid() 
        };
        ws.send(JSON.stringify(replayMessage));
        logMessage('CLIENT -> SERVER', replayMessage.type, replayMessage);
      } else if (data.type === shared.MESSAGES.SERVER_TO_CLIENT.REPLAY_MESSAGE.TYPE) {
        logEvent('Received a REPLAY_MESSAGE. Replaying missing actions.');
        
        const replayActions = data[shared.MESSAGES.SERVER_TO_CLIENT.REPLAY_MESSAGE.SEQUENCE];
        const lastAction = replayActions[replayActions.length - 1];

        verifiedModActions = [...verifiedModActions, ...replayActions];
        
        optimisticUpdates = optimisticUpdates.filter(o => {
            return !replayActions.some(r => r[shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.ACTION_UUID] === o[shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.ACTION_UUID]);
        });

        verifiedHash = data[shared.MESSAGES.SERVER_TO_CLIENT.REPLAY_MESSAGE.AFTER_HASH];
        pageNr = data[shared.MESSAGES.SERVER_TO_CLIENT.REPLAY_MESSAGE.CURRENT_PAGE_NR];
        totalPages = data[shared.MESSAGES.SERVER_TO_CLIENT.REPLAY_MESSAGE.CURRENT_TOTAL_PAGES];
        renderCanvas();
      } else if (data.type === shared.MESSAGES.SERVER_TO_CLIENT.PING.TYPE) {
        logEvent('Received a PING message.');
        if (verifiedHash !== data.hash) {
            logEvent(`Ping received, hash mismatch. Requesting replay...`);
            const replayMessage = { 
                type: shared.MESSAGES.CLIENT_TO_SERVER.REPLAY_REQUESTS.TYPE,
                [shared.MESSAGES.CLIENT_TO_SERVER.REPLAY_REQUESTS.PAGE_UUID]: data[shared.MESSAGES.SERVER_TO_CLIENT.PING.PAGE_UUID], 
                [shared.MESSAGES.CLIENT_TO_SERVER.REPLAY_REQUESTS.BEFORE_HASH]: verifiedHash, 
                [shared.MESSAGES.CLIENT_TO_SERVER.REPLAY_REQUESTS.REQUEST_ID]: shared.generateUuid()
            };
            ws.send(JSON.stringify(replayMessage));
            logMessage('CLIENT -> SERVER', replayMessage.type, replayMessage);
        }
      }
    };
  </script>
</body>
</html>
