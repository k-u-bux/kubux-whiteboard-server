<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Xournal++ Clone</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      overflow: hidden;
    }
    
    .toolbar {
      display: flex;
      background-color: #f0f0f0;
      padding: 5px;
      border-bottom: 1px solid #ccc;
    }
    
    .tool-section {
      display: flex;
      margin-right: 10px;
      padding-right: 10px;
      border-right: 1px solid #ddd;
    }
    
    .tool-btn {
      width: 30px;
      height: 30px;
      margin: 0 2px;
      cursor: pointer;
      border: 1px solid transparent;
      background-color: transparent;
      border-radius: 4px;
    }
    
    .tool-btn:hover {
      background-color: #e0e0e0;
    }

    .tool-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .tool-btn.active {
      border-color: #3498db;
      background-color: #ebf5fb;
    }
    
    .color-swatch {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      margin: 3px;
      cursor: pointer;
      border: 1px solid #ccc;
    }
    
    .color-swatch.active {
      border-color: #333;
      border-width: 2px;
    }
    
    #canvas-container {
      position: relative;
      flex-grow: 1;
      overflow: hidden;
    }
    
    canvas {
      position: absolute;
      background-color: white;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
    }
    
    .main-content {
      display: flex;
      height: calc(100vh - 42px);
    }
    
    #width-selector {
      width: 100px;
      margin: 0 10px;
    }
    
    .page-controls {
      display: flex;
      align-items: center;
    }
    
    #page-info {
      margin: 0 10px;
    }
    
    .error-banner {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background-color: #f44336;
      color: white;
      padding: 15px;
      text-align: center;
      z-index: 1000;
      display: none;
    }
    
    .error-banner button {
      margin-left: 15px;
      background-color: white;
      color: #f44336;
      border: none;
      padding: 5px 10px;
      cursor: pointer;
      border-radius: 4px;
    }

    /* Add tooltips for buttons */
    .tooltip {
      position: relative;
      display: inline-block;
    }

    .tooltip .tooltiptext {
      visibility: hidden;
      width: 120px;
      background-color: #555;
      color: #fff;
      text-align: center;
      border-radius: 6px;
      padding: 5px;
      position: absolute;
      z-index: 1;
      bottom: 125%;
      left: 50%;
      margin-left: -60px;
      opacity: 0;
      transition: opacity 0.3s;
      font-size: 12px;
    }

    .tooltip:hover .tooltiptext {
      visibility: visible;
      opacity: 1;
    }
  </style>
</head>
<body>
  <div class="error-banner" id="error-banner">
    <span id="error-message">Connection error</span>
    <button id="reconnect-button">Reconnect</button>
  </div>
  
  <div class="toolbar">
    <!-- Undo/Redo Section -->
    <div class="tool-section">
      <button class="tool-btn tooltip" id="undo-btn" title="Undo" disabled>‚Ü©
        <span class="tooltiptext">Undo (Ctrl+Z)</span>
      </button>
      <button class="tool-btn tooltip" id="redo-btn" title="Redo" disabled>‚Ü™
        <span class="tooltiptext">Redo (Ctrl+Y)</span>
      </button>
    </div>
    
    <!-- Tools Section -->
    <div class="tool-section">
      <button class="tool-btn active" id="pen-tool" title="Pen">‚úèÔ∏è</button>
      <button class="tool-btn" id="highlighter-tool" title="Highlighter">üñåÔ∏è</button>
      <button class="tool-btn" id="eraser-tool" title="Eraser">üßΩ</button>
    </div>
    
    <!-- Colors Section -->
    <div class="tool-section">
      <div class="color-swatch active" style="background-color: black;" data-color="#000000"></div>
      <div class="color-swatch" style="background-color: red;" data-color="#ff0000"></div>
      <div class="color-swatch" style="background-color: green;" data-color="#00ff00"></div>
      <div class="color-swatch" style="background-color: blue;" data-color="#0000ff"></div>
      <div class="color-swatch" style="background-color: yellow;" data-color="#ffff00"></div>
    </div>
    
    <!-- Width Section -->
    <div class="tool-section">
      <label for="width-selector">Width:</label>
      <input type="range" id="width-selector" min="1" max="10" value="2">
      <span id="width-value">2</span>
    </div>
    
    <!-- Page Controls -->
    <div class="tool-section page-controls">
      <button class="tool-btn" id="prev-page">‚óÄÔ∏è</button>
      <span id="page-info">Page 1 of 1</span>
      <button class="tool-btn" id="next-page">‚ñ∂Ô∏è</button>
      <button class="tool-btn" id="add-page">‚ûï</button>
      <button class="tool-btn" id="delete-page">‚ûñ</button>
    </div>
    
    <!-- Zoom Controls -->
    <div class="tool-section">
      <button class="tool-btn" id="zoom-out">-</button>
      <span id="zoom-level">100%</span>
      <button class="tool-btn" id="zoom-in">+</button>
    </div>
  </div>
  
  <div class="main-content">
    <div id="canvas-container">
      <canvas id="canvas"></canvas>
    </div>
  </div>

  <script src="shared.js"></script>
  <script>
    // Debug logging function
    function debugLog(msg, data) {
      console.log(`[DEBUG] ${msg}`, data || '');
    }

    // Globals for board state
    let ws = null;
    let boardId = null;
    let clientId = shared.generateUuid(); // Unique client identifier
    let currentPageUuid = null;
    let pageNr = 1;
    let totalPages = 1;
    let verifiedHash = '';
    let pendingRequests = {}; // Track in-flight requests
    let connectionEstablished = false;
    
    // Drawing state
    let isDrawing = false;
    let isErasing = false;
    let currentPath = [];
    let currentStroke = null;
    
    // Timeline state with single timeline approach
    let history = [];          // All confirmed actions from server
    let present = 0;           // Current position in confirmed history
    let pendingActions = [];   // Actions sent to server but not yet confirmed
    
    // Visual state
    let visualState = shared.createEmptyVisualState();
    
    // Zoom state
    let zoomLevel = 1;
    
    // Tool state
    let currentTool = 'pen';
    let eraserRadius = 20;
    let currentColor = '#000000';
    let currentWidth = 2;
    
    // DOM elements
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const container = document.getElementById('canvas-container');
    const widthSelector = document.getElementById('width-selector');
    const widthValue = document.getElementById('width-value');
    const zoomLevelDisplay = document.getElementById('zoom-level');
    const pageInfo = document.getElementById('page-info');
    const errorBanner = document.getElementById('error-banner');
    const errorMessage = document.getElementById('error-message');
    const reconnectButton = document.getElementById('reconnect-button');
    const undoBtn = document.getElementById('undo-btn');
    const redoBtn = document.getElementById('redo-btn');
    
    // Initialize 
    function init() {
      setupCanvas();
      setupWebSocket();
      setupEventListeners();
      debugStylusEvents(); // Add stylus debugging
    }
    
    // Set up canvas size
    function setupCanvas() {
      resizeCanvas();
      window.addEventListener('resize', resizeCanvas);
    }
    
    // Resize canvas to fit window
    function resizeCanvas() {
      canvas.width = container.clientWidth;
      canvas.height = container.clientHeight;
      applyZoom();
      redrawCanvas();
    }
    
    // Apply zoom transform
    function applyZoom() {
      ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset transform
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.setTransform(zoomLevel, 0, 0, zoomLevel, 0, 0);
    }
    
    // Show error message
    function showError(message) {
      errorMessage.textContent = message;
      errorBanner.style.display = 'block';
    }
    
    // Hide error message
    function hideError() {
      errorBanner.style.display = 'none';
    }
    
    // Generate a unique request ID and register it
    function createRequestId() {
      const requestId = shared.generateUuid();
      pendingRequests[requestId] = true;
      return requestId;
    }
    
    // Reconnect WebSocket
    function reconnectWebSocket() {
      if (ws) {
        ws.close();
      }
      setupWebSocket();
      hideError();
    }
    
    function setupWebSocket() {
      const urlParams = new URLSearchParams(window.location.search);
      const credential = urlParams.get('credential');
      boardId = urlParams.get('board');
      
      // Determine if we're creating or registering
      const isCreating = !!credential;
      
      // If neither board nor credential provided, show error
      if (!boardId && !isCreating) {
        showError('Please provide either a board ID or credentials to create a new board.');
        return; // Don't attempt to connect
      }
      
      // Always use secure WebSockets as required by the server
      const hostname = window.location.hostname || 'localhost';
      const wsUrl = `wss://${hostname}:8080/ws`;
      
      debugLog('Connecting to WebSocket:', wsUrl);
      
      ws = new WebSocket(wsUrl);
      connectionEstablished = false;
      
      ws.onopen = () => {
        debugLog('WebSocket connection established');
        
        if (isCreating) {
          // Send board creation request
          createBoard(credential);
        } else if (boardId) {
          // Register with existing board
          registerBoard(boardId);
        }
      };
      
      ws.onclose = () => {
        debugLog('Disconnected from server');
        connectionEstablished = false;
        showError('Connection to server lost. Please reconnect.');
      };
      
      ws.onerror = (error) => {
        console.error('WebSocket error:', error);
        connectionEstablished = false;
        showError('Failed to connect to server. Please check your connection.');
      };
      
      ws.onmessage = (event) => {
        try {
          const data = shared.deserialize(event.data);
          debugLog('Received message:', data);
          
          // Handle message based on type
          switch (data.type) {
            case shared.MESSAGES.SERVER_TO_CLIENT.BOARD_REGISTERED.TYPE:
              handleBoardRegistered(data);
              break;
            case shared.MESSAGES.SERVER_TO_CLIENT.FULL_PAGE.TYPE:
              handleFullPageMessage(data);
              break;
            case shared.MESSAGES.SERVER_TO_CLIENT.ACCEPT.TYPE:
              handleAcceptMessage(data);
              break;
            case shared.MESSAGES.SERVER_TO_CLIENT.DECLINE.TYPE:
              handleDeclineMessage(data);
              break;
            case shared.MESSAGES.SERVER_TO_CLIENT.REPLAY.TYPE:
              handleReplayMessage(data);
              break;
            case shared.MESSAGES.SERVER_TO_CLIENT.PING.TYPE:
              handlePingMessage(data);
              break;
            case "error":
              handleErrorMessage(data);
              break;
            default:
              console.error('Unknown message type:', data.type);
          }
        } catch (error) {
          console.error('Error processing message:', error);
          showError(`Error processing message: ${error.message}`);
        }
      };
    }
    
    // Handle server error message
    function handleErrorMessage(data) {
      console.error(`[SERVER ERROR] ${data.message}`, data.stack);
      showError(`Server error: ${data.message}`);
    }
    
    // Create a new board with credentials
    function createBoard(credential) {
      const requestId = createRequestId();
      
      const createMessage = {
        type: shared.MESSAGES.CLIENT_TO_SERVER.CREATE_BOARD.TYPE,
        [shared.MESSAGES.CLIENT_TO_SERVER.CREATE_BOARD.PASSWD]: credential,
        [shared.MESSAGES.CLIENT_TO_SERVER.CREATE_BOARD.CLIENT_ID]: clientId,
        [shared.MESSAGES.CLIENT_TO_SERVER.CREATE_BOARD.REQUEST_ID]: requestId
      };
      
      debugLog('Sending board creation request:', createMessage);
      ws.send(shared.serialize(createMessage));
    }
    
    // Register with an existing board
    function registerBoard(boardId) {
      const requestId = createRequestId();
      
      const registerMessage = {
        type: shared.MESSAGES.CLIENT_TO_SERVER.REGISTER_BOARD.TYPE,
        [shared.MESSAGES.CLIENT_TO_SERVER.REGISTER_BOARD.BOARD_ID]: boardId,
        [shared.MESSAGES.CLIENT_TO_SERVER.REGISTER_BOARD.CLIENT_ID]: clientId,
        [shared.MESSAGES.CLIENT_TO_SERVER.REGISTER_BOARD.REQUEST_ID]: requestId
      };
      
      debugLog('Sending board registration:', registerMessage);
      ws.send(shared.serialize(registerMessage));
    }
    
    // Handle board registration response
    function handleBoardRegistered(data) {
      debugLog('Board registered successfully');
      connectionEstablished = true;
      hideError();
      
      // Remove the request from pending
      const requestId = data[shared.MESSAGES.SERVER_TO_CLIENT.BOARD_REGISTERED.REQUEST_ID];
      delete pendingRequests[requestId];
      
      // Reset local state
      history = [];
      present = 0;
      pendingActions = [];
      visualState = shared.createEmptyVisualState();
      verifiedHash = '';
      
      // Update board ID and URL if necessary
      boardId = data[shared.MESSAGES.SERVER_TO_CLIENT.BOARD_REGISTERED.BOARD_ID];
      const urlParams = new URLSearchParams(window.location.search);
      
      if (urlParams.get('credential')) {
        // If we created a board, update URL to use board ID instead
        window.history.replaceState(null, null, `?board=${boardId}`);
      } else if (urlParams.get('board') !== boardId) {
        // If the board ID changed for some reason, update URL
        window.history.replaceState(null, null, `?board=${boardId}`);
      }
      
      // The server will send a full page message next, so we don't need
      // to request one explicitly
    }
    
    // Handle ping message from server
    function handlePingMessage(data) {
      const pingPageUuid = data[shared.MESSAGES.SERVER_TO_CLIENT.PING.UUID];
      const pingPageHash = data[shared.MESSAGES.SERVER_TO_CLIENT.PING.HASH];
      const pingPageNr = data[shared.MESSAGES.SERVER_TO_CLIENT.PING.PAGE_NR];
      const pingTotalPages = data[shared.MESSAGES.SERVER_TO_CLIENT.PING.TOTAL_PAGES];
      
      debugLog('Received ping', {
        serverPageUuid: pingPageUuid, 
        serverPageHash: pingPageHash, 
        serverPageNr: pingPageNr, 
        serverTotalPages: pingTotalPages,
        currentPageUuid: currentPageUuid
      });
      
      // Check if we're on the wrong page
      if (currentPageUuid !== pingPageUuid) {
        debugLog('Server indicates we should be on a different page');
        requestFullPage(pingPageUuid);
        return;
      }
      
      // Update page info if needed
      if (pageNr !== pingPageNr || totalPages !== pingTotalPages) {
        pageNr = pingPageNr;
        totalPages = pingTotalPages;
        updatePageInfo();
      }
      
      // Check if our hash is out of sync
      if (verifiedHash !== pingPageHash) {
        debugLog('Hash out of sync, requesting replay');
        requestReplay();
      }
    }

    // Handle accept message from server
    function handleAcceptMessage(data) {
      const acceptedActionUuid = data[shared.MESSAGES.SERVER_TO_CLIENT.ACCEPT.ACTION_UUID];
      const beforeHash = data[shared.MESSAGES.SERVER_TO_CLIENT.ACCEPT.BEFORE_HASH];
      const afterHash = data[shared.MESSAGES.SERVER_TO_CLIENT.ACCEPT.AFTER_HASH];
      
      // Find the pending action that was accepted
      const pendingActionIndex = pendingActions.findIndex(action => action.uuid === acceptedActionUuid);
      
      if (pendingActionIndex !== -1) {
        // Remove the pending action
        const acceptedAction = pendingActions.splice(pendingActionIndex, 1)[0];
        
        // For draw and erase actions, add to confirmed history if it's not already there
        if (acceptedAction.type === shared.MOD_ACTIONS.DRAW.TYPE || 
            acceptedAction.type === shared.MOD_ACTIONS.ERASE.TYPE) {
          
          // Add to history if not already there
          const existingIndex = history.findIndex(a => a.uuid === acceptedAction.uuid);
          if (existingIndex === -1) {
            // If we're in the middle of history (after an undo), truncate future actions
            if (present < history.length) {
              history = history.slice(0, present);
            }
            
            // Add to history and update present
            history.push(acceptedAction);
            present = history.length;
          }
        }
      }
      
      // If the before hash doesn't match what we expected, request a replay
      if (beforeHash !== verifiedHash) {
        console.warn('Hash mismatch detected, requesting replay to synchronize');
        requestReplay();
        return;
      }
      
      // Update hash
      verifiedHash = afterHash;
      
      // Update page info
      pageNr = data[shared.MESSAGES.SERVER_TO_CLIENT.ACCEPT.CURRENT_PAGE_NR];
      totalPages = data[shared.MESSAGES.SERVER_TO_CLIENT.ACCEPT.CURRENT_TOTAL_PAGES];
      updatePageInfo();
      
      // Update UI
      updateUndoRedoButtons();
      redrawCanvas();
    }
    
    // Handle decline message from server
    function handleDeclineMessage(data) {
      const declinedActionUuid = data[shared.MESSAGES.SERVER_TO_CLIENT.DECLINE.ACTION_UUID];
      const reason = data[shared.MESSAGES.SERVER_TO_CLIENT.DECLINE.REASON];
      
      console.error(`Server declined action ${declinedActionUuid}: ${reason}`);
      
      // Remove the declined action from pending
      pendingActions = pendingActions.filter(action => action.uuid !== declinedActionUuid);
      
      // Request replay to ensure we're in sync
      requestReplay();
    }
    
    // Handle replay message from server
    function handleReplayMessage(data) {
      const replaySequence = data[shared.MESSAGES.SERVER_TO_CLIENT.REPLAY.SEQUENCE];
      const afterHash = data[shared.MESSAGES.SERVER_TO_CLIENT.REPLAY.AFTER_HASH];
      const serverPresent = data[shared.MESSAGES.SERVER_TO_CLIENT.REPLAY.PRESENT];
      
      // Reset to server state
      history = replaySequence || [];
      present = serverPresent;
      verifiedHash = afterHash;
      
      // Reset pending actions - discard all optimistic updates on replay
      pendingActions = [];
      
      // Recompile visual state
      updateVisualState();
      
      // Update page info
      pageNr = data[shared.MESSAGES.SERVER_TO_CLIENT.REPLAY.PAGE_NR];
      totalPages = data[shared.MESSAGES.SERVER_TO_CLIENT.REPLAY.TOTAL_PAGES];
      updatePageInfo();
      
      // Update UI
      updateUndoRedoButtons();
    }
    
    // Handle full page message from server
    function handleFullPageMessage(data) {
      currentPageUuid = data[shared.MESSAGES.SERVER_TO_CLIENT.FULL_PAGE.UUID];
      history = data[shared.MESSAGES.SERVER_TO_CLIENT.FULL_PAGE.HISTORY] || [];
      present = data[shared.MESSAGES.SERVER_TO_CLIENT.FULL_PAGE.PRESENT];
      verifiedHash = data[shared.MESSAGES.SERVER_TO_CLIENT.FULL_PAGE.HASH];
      
      // Reset pending actions
      pendingActions = [];
      
      // Recompile visual state
      updateVisualState();
      
      // Update page info
      pageNr = data[shared.MESSAGES.SERVER_TO_CLIENT.FULL_PAGE.PAGE_NR];
      totalPages = data[shared.MESSAGES.SERVER_TO_CLIENT.FULL_PAGE.TOTAL_PAGES];
      updatePageInfo();
      
      // Update UI
      updateUndoRedoButtons();
    }
    
    // Request a full page from the server
    function requestFullPage(pageId, delta = 0) {
      const requestId = createRequestId();
      
      const request = {
        type: shared.MESSAGES.CLIENT_TO_SERVER.FULL_PAGE_REQUESTS.TYPE,
        [shared.MESSAGES.CLIENT_TO_SERVER.FULL_PAGE_REQUESTS.BOARD_UUID]: boardId
      };
      
      if (pageId) {
        request[shared.MESSAGES.CLIENT_TO_SERVER.FULL_PAGE_REQUESTS.PAGE_ID] = pageId;
      }
      
      request[shared.MESSAGES.CLIENT_TO_SERVER.FULL_PAGE_REQUESTS.DELTA] = delta;
      request[shared.MESSAGES.CLIENT_TO_SERVER.FULL_PAGE_REQUESTS.REQUEST_ID] = requestId;
      
      debugLog('Requesting full page', request);
      sendMessage(request);
    }
    
    // Request a replay from the server
    function requestReplay() {
      const requestId = createRequestId();
      
      const request = {
        type: shared.MESSAGES.CLIENT_TO_SERVER.REPLAY_REQUESTS.TYPE,
        [shared.MESSAGES.CLIENT_TO_SERVER.REPLAY_REQUESTS.PAGE_UUID]: currentPageUuid,
        [shared.MESSAGES.CLIENT_TO_SERVER.REPLAY_REQUESTS.PRESENT]: present,
        [shared.MESSAGES.CLIENT_TO_SERVER.REPLAY_REQUESTS.PRESENT_HASH]: verifiedHash,
        [shared.MESSAGES.CLIENT_TO_SERVER.REPLAY_REQUESTS.REQUEST_ID]: requestId
      };
      
      debugLog('Requesting replay', request);
      sendMessage(request);
    }
    
    // Send a message to the server
    function sendMessage(message) {
      if (!connectionEstablished) {
        showError('Not connected to server');
        return false;
      }
      
      debugLog('Sending message', message);
      ws.send(shared.serialize(message));
      return true;
    }
    
    // Update visual state based on history and pending actions
    function updateVisualState() {
      // Create a fresh visual state
      visualState = shared.createEmptyVisualState();
      
      // Apply confirmed actions up to present
      const confirmedActions = history.slice(0, present);
      
      // Apply all actions to visual state
      for (const action of confirmedActions) {
        applyActionToVisualState(action);
      }
      
      // Apply pending actions
      for (const action of pendingActions) {
        applyActionToVisualState(action);
      }
      
      // Redraw the canvas
      redrawCanvas();
    }
    
    // Apply a single action to the visual state
    function applyActionToVisualState(action) {
      if (!action) return;
      
      switch (action.type) {
        case shared.MOD_ACTIONS.DRAW.TYPE:
          const stroke = action[shared.MOD_ACTIONS.DRAW.STROKE] || action.stroke;
          shared.addElement(visualState, action.uuid, stroke);
          shared.showElement(visualState, action.uuid);
          break;
          
        case shared.MOD_ACTIONS.ERASE.TYPE:
          const targetUuid = action[shared.MOD_ACTIONS.ERASE.TARGET_ACTION] || action.targetAction;
          shared.hideElement(visualState, targetUuid);
          break;
      }
    }
    
    // Add stylus debugging function
    function debugStylusEvents() {
      canvas.addEventListener('pointerdown', logStylusEvent);
      canvas.addEventListener('pointermove', logStylusEvent);
      canvas.addEventListener('pointerup', logStylusEvent);
    }

    function logStylusEvent(event) {
      if (event.pointerType === 'pen') {
        console.log('Stylus Event:', {
          type: event.type,
          pointerType: event.pointerType,
          pressure: event.pressure,
          tiltX: event.tiltX,
          tiltY: event.tiltY,
          twist: event.twist,
          isPrimary: event.isPrimary,
          tool: currentTool
        });
      }
    }
    
    // Set up event listeners
    function setupEventListeners() {
      // Reconnect button
      reconnectButton.addEventListener('click', reconnectWebSocket);
      
      // Tool selection
      document.getElementById('pen-tool').addEventListener('click', () => setTool('pen'));
      document.getElementById('highlighter-tool').addEventListener('click', () => setTool('highlighter'));
      document.getElementById('eraser-tool').addEventListener('click', () => setTool('eraser'));
      
      // Color selection
      const colorSwatches = document.querySelectorAll('.color-swatch');
      colorSwatches.forEach(swatch => {
        swatch.addEventListener('click', () => {
          colorSwatches.forEach(s => s.classList.remove('active'));
          swatch.classList.add('active');
          currentColor = swatch.dataset.color;
        });
      });
      
      // Width selection
      widthSelector.addEventListener('input', () => {
        currentWidth = parseInt(widthSelector.value);
        widthValue.textContent = currentWidth;
      });
      
      // Page navigation
      document.getElementById('prev-page').addEventListener('click', () => navigatePage(-1));
      document.getElementById('next-page').addEventListener('click', () => navigatePage(1));
      document.getElementById('add-page').addEventListener('click', addNewPage);
      document.getElementById('delete-page').addEventListener('click', deletePage);
      
      // Zoom controls
      document.getElementById('zoom-in').addEventListener('click', () => adjustZoom(0.1));
      document.getElementById('zoom-out').addEventListener('click', () => adjustZoom(-0.1));
      
      // Undo/Redo buttons
      undoBtn.addEventListener('click', handleUndo);
      redoBtn.addEventListener('click', handleRedo);
      
      // Canvas events
      canvas.addEventListener('pointerdown', handlePointerDown);
      canvas.addEventListener('pointermove', handlePointerMove);
      canvas.addEventListener('pointerup', handlePointerUp);
      canvas.addEventListener('pointerleave', handlePointerUp);
      
      // Prevent default touch behaviors
      canvas.addEventListener('touchstart', e => e.preventDefault());
      canvas.addEventListener('touchmove', e => e.preventDefault());
      canvas.addEventListener('touchend', e => e.preventDefault());
      
      // Keyboard shortcuts
      document.addEventListener('keydown', handleKeyDown);
    }
    
    // Handle keyboard shortcuts
    function handleKeyDown(e) {
      // Undo: Ctrl+Z
      if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
        e.preventDefault();
        if (!undoBtn.disabled) {
          handleUndo();
        }
      }
      // Redo: Ctrl+Y or Ctrl+Shift+Z
      else if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
        e.preventDefault();
        if (!redoBtn.disabled) {
          handleRedo();
        }
      }
    }
    
    // Update undo/redo button states
    function updateUndoRedoButtons() {
      // Undo is available if we have actions in history before our present position
      undoBtn.disabled = present === 0;
      
      // Redo is available if we have actions in history after our present position
      redoBtn.disabled = present >= history.length;
    }
    
    // Handle undo action
    function handleUndo() {
      if (present === 0) return;
      
      const actionToUndo = history[present - 1];
      const undoUuid = shared.generateUuid();
      
      const undoAction = {
        type: shared.MOD_ACTIONS.UNDO.TYPE,
        [shared.MOD_ACTIONS.UUID]: undoUuid,
        [shared.MOD_ACTIONS.UNDO.TARGET_ACTION]: actionToUndo[shared.MOD_ACTIONS.UUID]
      };
      
      // Create proposal
      const proposal = {
        type: shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.TYPE,
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAGE_UUID]: currentPageUuid,
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD]: undoAction,
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.BEFORE_HASH]: verifiedHash
      };
      
      // Add to pending actions
      pendingActions.push(undoAction);
      
      // Apply optimistic update locally
      present--;
      
      // Update visual state and UI
      updateVisualState();
      updateUndoRedoButtons();
      
      // Send to server
      sendMessage(proposal);
    }
    
    // Handle redo action
    function handleRedo() {
      if (present >= history.length) return;
      
      const actionToRedo = history[present];
      const redoUuid = shared.generateUuid();
      
      const redoAction = {
        type: shared.MOD_ACTIONS.REDO.TYPE,
        [shared.MOD_ACTIONS.UUID]: redoUuid,
        [shared.MOD_ACTIONS.REDO.TARGET_ACTION]: actionToRedo[shared.MOD_ACTIONS.UUID]
      };
      
      // Create proposal
      const proposal = {
        type: shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.TYPE,
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAGE_UUID]: currentPageUuid,
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD]: redoAction,
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.BEFORE_HASH]: verifiedHash
      };
      
      // Add to pending actions
      pendingActions.push(redoAction);
      
      // Apply optimistic update locally
      present++;
      
      // Update visual state and UI
      updateVisualState();
      updateUndoRedoButtons();
      
      // Send to server
      sendMessage(proposal);
    }
    
    // Set current tool
    function setTool(tool) {
      currentTool = tool;
      
      // Update UI
      document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
      document.getElementById(`${tool}-tool`).classList.add('active');
      
      // Update cursor
      switch (tool) {
        case 'pen':
          canvas.style.cursor = 'crosshair';
          break;
        case 'highlighter':
          canvas.style.cursor = 'crosshair';
          break;
        case 'eraser':
          canvas.style.cursor = 'cell';
          break;
      }
    }
    
    // Adjust zoom level
    function adjustZoom(delta) {
      zoomLevel = Math.max(0.5, Math.min(3, zoomLevel + delta));
      zoomLevelDisplay.textContent = `${Math.round(zoomLevel * 100)}%`;
      applyZoom();
      redrawCanvas();
    }
    
    // Update page info display
    function updatePageInfo() {
      pageInfo.textContent = `Page ${pageNr} of ${totalPages}`;
    }
    
    // Handle pointer down event
    function handlePointerDown(event) {
      const rect = canvas.getBoundingClientRect();
      const x = (event.clientX - rect.left) / zoomLevel;
      const y = (event.clientY - rect.top) / zoomLevel;
      const pressure = event.pressure !== undefined ? event.pressure : 0.5;
      
      if (currentTool === 'eraser') {
        isErasing = true;
        handleEraserDown(x, y);
      } else {
        isDrawing = true;
        currentPath = [];
        
        // Create point
        const point = shared.createPoint(x, y, pressure);
        currentPath.push(point);
        
        // Create a new stroke based on selected tool
        currentStroke = shared.createStroke(
          currentTool === 'highlighter' ? shared.STROKE_STYLES.HIGHLIGHTER : shared.STROKE_STYLES.PEN
        );
        
        // Update stroke properties
        currentStroke[shared.ELEMENT.COLOR] = currentColor;
        currentStroke[shared.ELEMENT.WIDTH] = currentWidth;
        currentStroke[shared.ELEMENT.POINTS] = currentPath;
      }
    }
    
    // Handle pointer move event
    function handlePointerMove(event) {
      if (!isDrawing && !isErasing) return;
      
      const rect = canvas.getBoundingClientRect();
      const x = (event.clientX - rect.left) / zoomLevel;
      const y = (event.clientY - rect.top) / zoomLevel;
      const pressure = event.pressure !== undefined ? event.pressure : 0.5;
      
      if (isErasing) {
        handleEraserMove(x, y);
      } else if (isDrawing) {
        // Create point
        const point = shared.createPoint(x, y, pressure);
        currentPath.push(point);
        
        // Update current stroke
        currentStroke[shared.ELEMENT.POINTS] = currentPath;
        
        // Redraw
        redrawCanvas();
      }
    }
    
    // Handle pointer up event
    function handlePointerUp() {
      if (isErasing) {
        isErasing = false;
      } else if (isDrawing) {
        isDrawing = false;
        
        if (currentPath.length >= 2) {
          // Send completed stroke to server
          sendDrawAction(currentStroke);
        }
        
        currentPath = [];
        currentStroke = null;
      }
    }
    
    // Handle eraser down
    function handleEraserDown(x, y) {
      const elementsToErase = findElementsToErase(x, y);
      
      for (const elementUuid of elementsToErase) {
        sendEraseAction(elementUuid);
      }
    }
    
    // Handle eraser move
    function handleEraserMove(x, y) {
      const elementsToErase = findElementsToErase(x, y);
      
      for (const elementUuid of elementsToErase) {
        sendEraseAction(elementUuid);
      }
    }
    
    // Find elements to erase at a position
    function findElementsToErase(x, y) {
      const result = [];
      
      // Create a simple erase stroke for testing intersection
      const erasePoint = shared.createPoint(x, y);
      const eraseStroke = shared.createStroke();
      eraseStroke[shared.ELEMENT.POINTS] = [erasePoint];
      eraseStroke[shared.ELEMENT.WIDTH] = eraserRadius * 2;
      
      // Find intersecting elements using shared geometry function
      const intersecting = shared.findIntersectingElements(visualState, eraseStroke, eraserRadius, 10);
      
      for (const element of intersecting) {
        // Find the UUID for this element
        for (const [uuid, el] of visualState.element) {
          if (el === element && visualState.visible.has(uuid)) {
            result.push(uuid);
            break;
          }
        }
      }
      
      return result;
    }
    
    // Send a draw action to the server
    function sendDrawAction(stroke) {
      const actionUuid = shared.generateUuid();
      
      const drawAction = {
        type: shared.MOD_ACTIONS.DRAW.TYPE,
        [shared.MOD_ACTIONS.UUID]: actionUuid,
        [shared.MOD_ACTIONS.DRAW.STROKE]: stroke
      };
      
      // Create proposal
      const proposal = {
        type: shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.TYPE,
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAGE_UUID]: currentPageUuid,
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD]: drawAction,
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.BEFORE_HASH]: verifiedHash
      };
      
      // If we're in the middle of history (after undoing), truncate future actions
      if (present < history.length) {
        history = history.slice(0, present);
      }
      
      // Add the action to pending actions
      pendingActions.push(drawAction);
      
      // Update visual state
      applyActionToVisualState(drawAction);
      
      // Update UI
      updateUndoRedoButtons();
      
      // Send to server
      sendMessage(proposal);
    }
    
    // Send an erase action to the server
    function sendEraseAction(targetUuid) {
      const actionUuid = shared.generateUuid();
      
      const eraseAction = {
        type: shared.MOD_ACTIONS.ERASE.TYPE,
        [shared.MOD_ACTIONS.UUID]: actionUuid,
        [shared.MOD_ACTIONS.ERASE.TARGET_ACTION]: targetUuid
      };
      
      // Create proposal
      const proposal = {
        type: shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.TYPE,
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAGE_UUID]: currentPageUuid,
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD]: eraseAction,
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.BEFORE_HASH]: verifiedHash
      };
      
      // If we're in the middle of history (after undoing), truncate future actions
      if (present < history.length) {
        history = history.slice(0, present);
      }
      
      // Add the action to pending actions
      pendingActions.push(eraseAction);
      
      // Update visual state
      applyActionToVisualState(eraseAction);
      
      // Update UI
      updateUndoRedoButtons();
      
      // Send to server
      sendMessage(proposal);
    }
    
    // Add a new page
    function addNewPage() {
      const actionUuid = shared.generateUuid();
      
      const newPageAction = {
        type: shared.MOD_ACTIONS.NEW_PAGE.TYPE,
        [shared.MOD_ACTIONS.UUID]: actionUuid
      };
      
      // Create proposal
      const proposal = {
        type: shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.TYPE,
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAGE_UUID]: currentPageUuid,
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD]: newPageAction,
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.BEFORE_HASH]: verifiedHash
      };
      
      // Send to server - no optimistic update for page operations
      sendMessage(proposal);
    }
    
    // Delete current page
    function deletePage() {
      if (totalPages <= 1) {
        alert("Cannot delete the only page");
        return;
      }
      
      const actionUuid = shared.generateUuid();
      
      const deletePageAction = {
        type: shared.MOD_ACTIONS.DELETE_PAGE.TYPE,
        [shared.MOD_ACTIONS.UUID]: actionUuid
      };
      
      // Create proposal
      const proposal = {
        type: shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.TYPE,
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAGE_UUID]: currentPageUuid,
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD]: deletePageAction,
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.BEFORE_HASH]: verifiedHash
      };
      
      // Send to server - no optimistic update for page operations
      sendMessage(proposal);
    }
    
    // Navigate to next/previous page
    function navigatePage(delta) {
      // Request full page with delta
      requestFullPage(currentPageUuid, delta);
    }
    
    // Redraw the canvas
    function redrawCanvas() {
      ctx.save();
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.restore();
      
      // Custom render function for shared.render_all_visible_elements
      function renderElement(element) {
        if (!element) return;
        
        const points = element[shared.ELEMENT.POINTS];
        if (!Array.isArray(points) || points.length < 2) return;
        
        ctx.save();
        
        // Apply style
        ctx.strokeStyle = element[shared.ELEMENT.COLOR];
        ctx.lineWidth = element[shared.ELEMENT.WIDTH];
        ctx.globalAlpha = element[shared.ELEMENT.OPACITY];
        
        // Cap and join styles
        ctx.lineCap = shared.CAP_STYLE_STRINGS[element[shared.ELEMENT.CAP_STYLE]];
        ctx.lineJoin = shared.JOIN_STYLE_STRINGS[element[shared.ELEMENT.JOIN_STYLE]];
        
        // Dash pattern
        const dashPattern = element[shared.ELEMENT.DASH_PATTERN];
        if (dashPattern && dashPattern.length > 1) {
          ctx.setLineDash(dashPattern);
        } else {
          ctx.setLineDash([]);
        }
        
        // Draw the stroke
        ctx.beginPath();
        ctx.moveTo(points[0][shared.POINT.X], points[0][shared.POINT.Y]);
        
        for (let i = 1; i < points.length; i++) {
          const point = points[i];
          const pressure = point[shared.POINT.PRESSURE];
          
          // Apply pressure sensitivity
          if (element[shared.ELEMENT.SENSITIVITY] > 0 && pressure !== undefined) {
            const pressureEffect = 1 + (pressure - 0.5) * element[shared.ELEMENT.SENSITIVITY];
            ctx.lineWidth = element[shared.ELEMENT.WIDTH] * pressureEffect;
          }
          
          ctx.lineTo(point[shared.POINT.X], point[shared.POINT.Y]);
        }
        
        ctx.stroke();
        ctx.restore();
      }
      
      // Render all visible elements
      shared.render_all_visible_elements(visualState, renderElement);
      
      // Draw current stroke if we're drawing
      if (isDrawing && currentStroke) {
        renderElement(currentStroke);
      }
    }
    
    // Initialize the app
    window.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>
