<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Xournal++ Clone</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      overflow: hidden;
    }
    
    .toolbar {
      display: flex;
      background-color: #f0f0f0;
      padding: 5px;
      border-bottom: 1px solid #ccc;
    }
    
    .tool-section {
      display: flex;
      margin-right: 10px;
      padding-right: 10px;
      border-right: 1px solid #ddd;
    }
    
    .tool-btn {
      width: 30px;
      height: 30px;
      margin: 0 2px;
      cursor: pointer;
      border: 1px solid transparent;
      background-color: transparent;
      border-radius: 4px;
    }
    
    .tool-btn:hover {
      background-color: #e0e0e0;
    }

    .tool-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .tool-btn.active {
      border-color: #3498db;
      background-color: #ebf5fb;
    }
    
    .color-swatch {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      margin: 3px;
      cursor: pointer;
      border: 1px solid #ccc;
    }
    
    .color-swatch.active {
      border-color: #333;
      border-width: 2px;
    }
    
    #canvas-container {
      position: relative;
      flex-grow: 1;
      overflow: hidden;
    }
    
    canvas {
      position: absolute;
      background-color: white;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
    }
    
    .main-content {
      display: flex;
      height: calc(100vh - 42px);
    }
    
    #width-selector {
      width: 100px;
      margin: 0 10px;
    }
    
    .page-controls {
      display: flex;
      align-items: center;
    }
    
    #page-info {
      margin: 0 10px;
    }
    
    .error-banner {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background-color: #f44336;
      color: white;
      padding: 15px;
      text-align: center;
      z-index: 1000;
      display: none;
    }
    
    .error-banner button {
      margin-left: 15px;
      background-color: white;
      color: #f44336;
      border: none;
      padding: 5px 10px;
      cursor: pointer;
      border-radius: 4px;
    }

    /* Add tooltips for buttons */
    .tooltip {
      position: relative;
      display: inline-block;
    }

    .tooltip .tooltiptext {
      visibility: hidden;
      width: 120px;
      background-color: #555;
      color: #fff;
      text-align: center;
      border-radius: 6px;
      padding: 5px;
      position: absolute;
      z-index: 1;
      bottom: 125%;
      left: 50%;
      margin-left: -60px;
      opacity: 0;
      transition: opacity 0.3s;
      font-size: 12px;
    }

    .tooltip:hover .tooltiptext {
      visibility: visible;
      opacity: 1;
    }
  </style>
</head>
<body>
  <div class="error-banner" id="error-banner">
    <span id="error-message">Connection error</span>
    <button id="reconnect-button">Reconnect</button>
  </div>
  
  <div class="toolbar">
    <!-- Undo/Redo Section -->
    <div class="tool-section">
      <button class="tool-btn tooltip" id="undo-btn" title="Undo" disabled>‚Ü©
        <span class="tooltiptext">Undo (Ctrl+Z)</span>
      </button>
      <button class="tool-btn tooltip" id="redo-btn" title="Redo" disabled>‚Ü™
        <span class="tooltiptext">Redo (Ctrl+Y)</span>
      </button>
    </div>
    
    <!-- Tools Section -->
    <div class="tool-section">
      <button class="tool-btn active" id="pen-tool" title="Pen">‚úèÔ∏è</button>
      <button class="tool-btn" id="highlighter-tool" title="Highlighter">üñåÔ∏è</button>
      <button class="tool-btn" id="eraser-tool" title="Eraser">üßΩ</button>
    </div>
    
    <!-- Colors Section -->
    <div class="tool-section">
      <div class="color-swatch active" style="background-color: black;" data-color="#000000"></div>
      <div class="color-swatch" style="background-color: red;" data-color="#ff0000"></div>
      <div class="color-swatch" style="background-color: green;" data-color="#00ff00"></div>
      <div class="color-swatch" style="background-color: blue;" data-color="#0000ff"></div>
      <div class="color-swatch" style="background-color: yellow;" data-color="#ffff00"></div>
    </div>
    
    <!-- Width Section -->
    <div class="tool-section">
      <label for="width-selector">Width:</label>
      <input type="range" id="width-selector" min="1" max="10" value="2">
      <span id="width-value">2</span>
    </div>
    
    <!-- Page Controls -->
    <div class="tool-section page-controls">
      <button class="tool-btn" id="prev-page">‚óÄÔ∏è</button>
      <span id="page-info">Page 1 of 1</span>
      <button class="tool-btn" id="next-page">‚ñ∂Ô∏è</button>
      <button class="tool-btn" id="add-page">‚ûï</button>
      <button class="tool-btn" id="delete-page">‚ûñ</button>
    </div>
    
    <!-- Zoom Controls -->
    <div class="tool-section">
      <button class="tool-btn" id="zoom-out">-</button>
      <span id="zoom-level">100%</span>
      <button class="tool-btn" id="zoom-in">+</button>
    </div>
  </div>
  
  <div class="main-content">
    <div id="canvas-container">
      <canvas id="canvas"></canvas>
    </div>
  </div>

  <script src="shared.js"></script>
  <script>
    // Debug logging function
    function debugLog(msg, data) {
      console.log(`[DEBUG] ${msg}`, data || '');
    }

    // Globals for board state
    let ws = null;
    let boardId = null;
    let clientId = shared.generateUuid(); // Unique client identifier
    let currentPageUuid = null;
    let verifiedHash = '';
    let verifiedModActions = [];
    let optimisticUpdates = [];
    let pageNr = 1;
    let totalPages = 1;
    let lastDrawUuid = null;  // Track last drawn stroke UUID for eraser
    let pendingRequests = {}; // Track in-flight requests
    let connectionEstablished = false;
    
    // Drawing state
    let isDrawing = false;
    let isErasing = false;
    let currentPath = [];
    let currentStyle = [
      "stroke",                    // type
      [],                          // points
      "#000000",                   // color
      2.0,                         // width
      shared.PEN_TYPES.MARKER,     // penType
      1.0,                         // opacity
      shared.CAP_STYLES.ROUND,     // capStyle
      shared.JOIN_STYLES.ROUND,    // joinStyle
      [0],                         // dashPattern
      1.0,                         // pressureSensitivity
      1                            // layer
    ];
    
    // Zoom state
    let zoomLevel = 1;
    
    // Tool state
    let currentTool = 'pen';
    let eraserRadius = 20;
    
    // Undo/Redo state
    let myActions = [];          // Actions performed by this client
    let undoneActions = new Map(); // Map of undone actionUuid -> undo actionUuid
    
    // DOM elements
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const container = document.getElementById('canvas-container');
    const widthSelector = document.getElementById('width-selector');
    const widthValue = document.getElementById('width-value');
    const zoomLevelDisplay = document.getElementById('zoom-level');
    const pageInfo = document.getElementById('page-info');
    const errorBanner = document.getElementById('error-banner');
    const errorMessage = document.getElementById('error-message');
    const reconnectButton = document.getElementById('reconnect-button');
    const undoBtn = document.getElementById('undo-btn');
    const redoBtn = document.getElementById('redo-btn');
    
    // Initialize 
    function init() {
      setupCanvas();
      setupWebSocket();
      setupEventListeners();
      debugStylusEvents(); // Add stylus debugging
    }
    
    // Set up canvas size
    function setupCanvas() {
      resizeCanvas();
      window.addEventListener('resize', resizeCanvas);
    }
    
    // Resize canvas to fit window
    function resizeCanvas() {
      canvas.width = container.clientWidth;
      canvas.height = container.clientHeight;
      applyZoom();
      redrawCanvas();
    }
    
    // Apply zoom transform
    function applyZoom() {
      ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset transform
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.setTransform(zoomLevel, 0, 0, zoomLevel, 0, 0);
    }
    
    // Show error message
    function showError(message) {
      errorMessage.textContent = message;
      errorBanner.style.display = 'block';
    }
    
    // Hide error message
    function hideError() {
      errorBanner.style.display = 'none';
    }
    
    // Generate a unique request ID and register it
    function createRequestId() {
      const requestId = shared.generateUuid();
      pendingRequests[requestId] = true;
      return requestId;
    }
    
    // Reconnect WebSocket
    function reconnectWebSocket() {
      if (ws) {
        ws.close();
      }
      setupWebSocket();
      hideError();
    }
    
    // Set up WebSocket connection
    function setupWebSocket() {
      const urlParams = new URLSearchParams(window.location.search);
      boardId = urlParams.get('id') || shared.generateUuid();
      history.replaceState(null, null, `?id=${boardId}`);
      
      // Simplified WebSocket URL - no board ID in the path
      const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      const hostname = window.location.hostname || 'localhost';
      const wsUrl = `${wsProtocol}//${hostname}:3001/ws`;
      
      debugLog('Connecting to WebSocket:', wsUrl);
      
      ws = new WebSocket(wsUrl);
      connectionEstablished = false;
      
      ws.onopen = () => {
        debugLog('WebSocket connection established');
        // Register with the board immediately after connection
        registerBoard();
      };
      
      ws.onclose = () => {
        debugLog('Disconnected from server');
        connectionEstablished = false;
        showError('Connection to server lost. Please reconnect.');
      };
      
      ws.onerror = (error) => {
        console.error('WebSocket error:', error);
        connectionEstablished = false;
        showError('Failed to connect to server. Please check your connection.');
      };
      
      ws.onmessage = (event) => {
        const data = JSON.parse(event.data);
        debugLog('Received message:', data);
        
        // Handle existing message types
        switch (data.type) {
          case shared.MESSAGES.SERVER_TO_CLIENT.ACCEPT_MESSAGE.TYPE:
            handleAcceptMessage(data);
            break;
          case shared.MESSAGES.SERVER_TO_CLIENT.DECLINE_MESSAGE.TYPE:
            handleDeclineMessage(data);
            break;
          case shared.MESSAGES.SERVER_TO_CLIENT.REPLAY_MESSAGE.TYPE:
            handleReplayMessage(data);
            break;
          case shared.MESSAGES.SERVER_TO_CLIENT.FULL_PAGE.TYPE:
            handleFullPageMessage(data);
            break;
          case shared.MESSAGES.SERVER_TO_CLIENT.PING.TYPE:
            handlePingMessage(data);
            break;
          case shared.MESSAGES.SERVER_TO_CLIENT.BOARD_REGISTERED.TYPE:
            handleBoardRegistered(data);
            break;
        }
      };
    }
    
    // Register with a board
    function registerBoard() {
      const requestId = createRequestId();
      
      const registerMessage = {
        type: shared.MESSAGES.CLIENT_TO_SERVER.REGISTER_BOARD.TYPE,
        [shared.MESSAGES.CLIENT_TO_SERVER.REGISTER_BOARD.BOARD_ID]: boardId,
        [shared.MESSAGES.CLIENT_TO_SERVER.REGISTER_BOARD.CLIENT_ID]: clientId,
        [shared.MESSAGES.CLIENT_TO_SERVER.REGISTER_BOARD.REQUEST_ID]: requestId
      };
      
      debugLog('Sending board registration:', registerMessage);
      ws.send(JSON.stringify(registerMessage));
    }
    
    // Handle board registration response
    function handleBoardRegistered(data) {
      debugLog('Board registered successfully');
      connectionEstablished = true;
      hideError();
      
      // Remove the request from pending
      const requestId = data[shared.MESSAGES.SERVER_TO_CLIENT.BOARD_REGISTERED.REQUEST_ID];
      delete pendingRequests[requestId];
      
      // Reset local state - server will send us a full page message after registration
      verifiedModActions = [];
      optimisticUpdates = [];
      verifiedHash = '';
      myActions = []; // Reset undo history
      undoneActions.clear(); // Clear redo history
      updateUndoRedoButtons(); // Update button states
      
      // The server might update our boardId (e.g., if we connected with a new one)
      boardId = data[shared.MESSAGES.SERVER_TO_CLIENT.BOARD_REGISTERED.BOARD_ID];
      
      // If the URL doesn't match our boardId, update it
      const urlParams = new URLSearchParams(window.location.search);
      if (urlParams.get('id') !== boardId) {
        history.replaceState(null, null, `?id=${boardId}`);
      }
    }
    
    // Handle ping message from server
    function handlePingMessage(data) {
      // Extract page information from ping
      const pingPageUuid = data[shared.MESSAGES.SERVER_TO_CLIENT.PING.PAGE_UUID];
      const pingPageHash = data[shared.MESSAGES.SERVER_TO_CLIENT.PING.HASH];
      const pingPageNr = data[shared.MESSAGES.SERVER_TO_CLIENT.PING.CURRENT_PAGE_NR];
      const pingTotalPages = data[shared.MESSAGES.SERVER_TO_CLIENT.PING.CURRENT_TOTAL_PAGES];
      
      debugLog('Received ping with page info', {
        serverPageUuid: pingPageUuid, 
        serverPageHash: pingPageHash, 
        serverPageNr: pingPageNr, 
        serverTotalPages: pingTotalPages,
        currentPageUuid: currentPageUuid
      });
      
      // Check if we're on a different page than the server thinks we should be
      if (currentPageUuid !== pingPageUuid) {
        debugLog('Server indicates we should be on a different page', {
          localPageUuid: currentPageUuid,
          serverPageUuid: pingPageUuid
        });
        
        // Request full page for the replacement page the server suggests
        const requestId = createRequestId();
        const fullPageRequest = {
          type: shared.MESSAGES.CLIENT_TO_SERVER.FULL_PAGE_REQUESTS.TYPE,
          boardId: boardId,
          [shared.MESSAGES.CLIENT_TO_SERVER.FULL_PAGE_REQUESTS.PAGE_ID]: pingPageUuid,
          [shared.MESSAGES.CLIENT_TO_SERVER.FULL_PAGE_REQUESTS.DELTA]: 0,
          [shared.MESSAGES.CLIENT_TO_SERVER.FULL_PAGE_REQUESTS.REQUEST_ID]: requestId
        };
        
        debugLog('Requesting replacement page due to page mismatch', fullPageRequest);
        sendMessage(fullPageRequest);
        return;
      }
      
      // Update page position information
      if (pageNr !== pingPageNr || totalPages !== pingTotalPages) {
        debugLog('Page position out of sync', {
          local: { pageNr, totalPages },
          server: { pageNr: pingPageNr, totalPages: pingTotalPages }
        });
        
        // Update our local page info
        pageNr = pingPageNr;
        totalPages = pingTotalPages;
        updatePageInfo();
      }
      
      // Check if we need to request a replay (our hash doesn't match server's)
      if (verifiedHash !== pingPageHash) {
        debugLog('Page hash out of sync, requesting replay', {
          localHash: verifiedHash,
          serverHash: pingPageHash
        });
        requestReplay(currentPageUuid, verifiedHash);
      }
    }

    // Handle accept message from server
    function handleAcceptMessage(data) {
      const acceptedActionUuid = data[shared.MESSAGES.SERVER_TO_CLIENT.ACCEPT_MESSAGE.ACTION_UUID];
      const acceptedAction = optimisticUpdates.find(a => 
        a[shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.ACTION_UUID] === acceptedActionUuid
      );
      
      if (acceptedAction) {
        // Move action from optimistic to verified
        optimisticUpdates = optimisticUpdates.filter(a => 
          a[shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.ACTION_UUID] !== acceptedActionUuid
        );
        
        // Update hash values
        acceptedAction.hashes = {
          [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.BEFORE_HASH]: 
            data[shared.MESSAGES.SERVER_TO_CLIENT.ACCEPT_MESSAGE.BEFORE_HASH],
          [shared.MESSAGES.SERVER_TO_CLIENT.ACCEPT_MESSAGE.AFTER_HASH]: 
            data[shared.MESSAGES.SERVER_TO_CLIENT.ACCEPT_MESSAGE.AFTER_HASH]
        };
        
        verifiedModActions.push(acceptedAction);
        verifiedHash = data[shared.MESSAGES.SERVER_TO_CLIENT.ACCEPT_MESSAGE.AFTER_HASH];
        
        // Handle undo/redo tracking
        const payload = acceptedAction[shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD];
        
        // Check if this is a normal action (not undo/redo/page)
        if (payload.type === shared.MOD_ACTIONS.DRAW.TYPE || 
            payload.type === shared.MOD_ACTIONS.ERASE.TYPE) {
          // Add to my actions for undo
          myActions.push(acceptedActionUuid);
        }
        // Check if this is an undo action
        else if (payload.type === shared.MOD_ACTIONS.UNDO.TYPE) {
          const targetActionUuid = payload[shared.MOD_ACTIONS.UNDO.TARGET_ACTION_UUID];
          
          // Remove target action from myActions
          const index = myActions.indexOf(targetActionUuid);
          if (index !== -1) {
            myActions.splice(index, 1);
          }
          
          // Store mapping for redo
          undoneActions.set(targetActionUuid, acceptedActionUuid);
          
          // Add this undo action to myActions (for potential undo of undo)
          myActions.push(acceptedActionUuid);
        }
        // Check if this is a redo action
        else if (payload.type === shared.MOD_ACTIONS.REDO.TYPE) {
          const targetUndoActionUuid = payload[shared.MOD_ACTIONS.REDO.TARGET_UNDO_ACTION_UUID];
          
          // Find original action that was undone
          let originalActionUuid = null;
          for (const [original, undo] of undoneActions.entries()) {
            if (undo === targetUndoActionUuid) {
              originalActionUuid = original;
              break;
            }
          }
          
          if (originalActionUuid) {
            // Add original action back to myActions
            myActions.push(originalActionUuid);
            
            // Remove from undone mapping
            undoneActions.delete(originalActionUuid);
          }
          
          // Remove undo action from myActions
          const undoIndex = myActions.indexOf(targetUndoActionUuid);
          if (undoIndex !== -1) {
            myActions.splice(undoIndex, 1);
          }
          
          // Add this redo action to myActions
          myActions.push(acceptedActionUuid);
        }
        
        // Update page info
        pageNr = data[shared.MESSAGES.SERVER_TO_CLIENT.ACCEPT_MESSAGE.CURRENT_PAGE_NR];
        totalPages = data[shared.MESSAGES.SERVER_TO_CLIENT.ACCEPT_MESSAGE.CURRENT_TOTAL_PAGES];
        updatePageInfo();
        
        // Update undo/redo buttons
        updateUndoRedoButtons();
      } else {
        // Request replay if we don't know about this action
        requestReplay(currentPageUuid, verifiedHash);
      }
      
      redrawCanvas();
    }
    
    // Handle decline message from server
    function handleDeclineMessage(data) {
      const declinedActionUuid = data[shared.MESSAGES.SERVER_TO_CLIENT.DECLINE_MESSAGE.ACTION_UUID];
      
      // Remove declined action from optimistic updates
      optimisticUpdates = optimisticUpdates.filter(a => 
        a[shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.ACTION_UUID] !== declinedActionUuid
      );
      
      // Request replay to ensure we're in sync
      requestReplay(currentPageUuid, verifiedHash);
      redrawCanvas();
      
      // Update undo/redo buttons
      updateUndoRedoButtons();
    }
    
    // Handle replay message from server
    function handleReplayMessage(data) {
      const replayActions = data[shared.MESSAGES.SERVER_TO_CLIENT.REPLAY_MESSAGE.SEQUENCE];
      verifiedHash = data[shared.MESSAGES.SERVER_TO_CLIENT.REPLAY_MESSAGE.AFTER_HASH];
      
      // Apply replayed actions
      if (Array.isArray(replayActions)) {
        verifiedModActions = verifiedModActions.concat(replayActions);
      }
      
      // Update page info
      if (data[shared.MESSAGES.SERVER_TO_CLIENT.REPLAY_MESSAGE.CURRENT_PAGE_NR]) {
        pageNr = data[shared.MESSAGES.SERVER_TO_CLIENT.REPLAY_MESSAGE.CURRENT_PAGE_NR];
      }
      if (data[shared.MESSAGES.SERVER_TO_CLIENT.REPLAY_MESSAGE.CURRENT_TOTAL_PAGES]) {
        totalPages = data[shared.MESSAGES.SERVER_TO_CLIENT.REPLAY_MESSAGE.CURRENT_TOTAL_PAGES];
      }
      updatePageInfo();
      
      redrawCanvas();
      
      // Update undo/redo buttons
      updateUndoRedoButtons();
    }
    
    // Handle full page message from server
    function handleFullPageMessage(data) {
      const pageUuid = data[shared.MESSAGES.SERVER_TO_CLIENT.FULL_PAGE.PAGE];
      const modActions = data[shared.MESSAGES.SERVER_TO_CLIENT.FULL_PAGE.STATE];
      const afterHash = data[shared.MESSAGES.SERVER_TO_CLIENT.FULL_PAGE.HASH];
      
      // Replace current page data
      currentPageUuid = pageUuid;
      verifiedModActions = Array.isArray(modActions) ? modActions : [];
      optimisticUpdates = [];
      verifiedHash = afterHash;
      
      // Reset undo/redo state when changing pages
      myActions = [];
      undoneActions.clear();
      
      // Rebuild myActions and undoneActions by analyzing verifiedModActions
      rebuildUndoRedoState();
      
      // Update page info
      pageNr = data[shared.MESSAGES.SERVER_TO_CLIENT.FULL_PAGE.PAGE_NR];
      totalPages = data[shared.MESSAGES.SERVER_TO_CLIENT.FULL_PAGE.TOTAL_PAGES];
      updatePageInfo();
      
      redrawCanvas();
      
      // Update undo/redo buttons
      updateUndoRedoButtons();
    }
    
    // Rebuild undo/redo state from verified actions
    function rebuildUndoRedoState() {
      myActions = [];
      undoneActions.clear();
      
      // Map of action UUIDs that have been undone to their undo action
      const undoneActionsMap = new Map();
      
      // First pass: find all undo actions and their targets
      for (const action of verifiedModActions) {
        const payload = action[shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD];
        const actionUuid = action[shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.ACTION_UUID];
        
        if (!payload) continue;
        
        // If this is an undo action, record its target
        if (payload.type === shared.MOD_ACTIONS.UNDO.TYPE) {
          const targetActionUuid = payload[shared.MOD_ACTIONS.UNDO.TARGET_ACTION_UUID];
          undoneActionsMap.set(targetActionUuid, actionUuid);
        }
        
        // If this is a redo action, remove its target from undone map
        if (payload.type === shared.MOD_ACTIONS.REDO.TYPE) {
          const targetUndoActionUuid = payload[shared.MOD_ACTIONS.REDO.TARGET_UNDO_ACTION_UUID];
          
          // Find the original action that was undone
          for (const [original, undo] of undoneActionsMap.entries()) {
            if (undo === targetUndoActionUuid) {
              undoneActionsMap.delete(original);
              break;
            }
          }
        }
      }
      
      // Second pass: collect all actions by this client that haven't been undone
      for (const action of verifiedModActions) {
        const payload = action[shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD];
        const actionUuid = action[shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.ACTION_UUID];
        
        if (!payload) continue;
        
        // Skip actions by other clients
        if (action.clientId && action.clientId !== clientId) {
          continue;
        }
        
        // Include only actions that can be undone and haven't been undone
        if ((payload.type === shared.MOD_ACTIONS.DRAW.TYPE || 
             payload.type === shared.MOD_ACTIONS.ERASE.TYPE) && 
            !undoneActionsMap.has(actionUuid)) {
          myActions.push(actionUuid);
        }
      }
      
      // Populate undoneActions with mappings for actions undone by this client
      for (const [original, undo] of undoneActionsMap.entries()) {
        const undoAction = verifiedModActions.find(a => 
          a[shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.ACTION_UUID] === undo
        );
        
        if (undoAction && undoAction.clientId === clientId) {
          undoneActions.set(original, undo);
        }
      }
    }
    
    // Send a message to the server
    function sendMessage(message) {
      if (!connectionEstablished) {
        showError('Not connected to server. Please reconnect.');
        return false;
      }
      
      // Add boardId to all outgoing messages
      message.boardId = boardId;
      
      debugLog('Sending message:', message);
      ws.send(JSON.stringify(message));
      return true;
    }
    
    // Add stylus debugging function
    function debugStylusEvents() {
      canvas.addEventListener('pointerdown', logStylusEvent);
      canvas.addEventListener('pointermove', logStylusEvent);
      canvas.addEventListener('pointerup', logStylusEvent);
    }

    function logStylusEvent(event) {
      if (event.pointerType === 'pen') {
        console.log('Stylus Event:', {
          type: event.type,
          pointerType: event.pointerType,
          pressure: event.pressure,
          tiltX: event.tiltX,
          tiltY: event.tiltY,
          twist: event.twist,
          isPrimary: event.isPrimary,
          tool: currentTool
        });
      }
    }
    
    // Set up event listeners
    function setupEventListeners() {
      // Reconnect button
      reconnectButton.addEventListener('click', reconnectWebSocket);
      
      // Tool selection
      document.getElementById('pen-tool').addEventListener('click', () => setTool('pen'));
      document.getElementById('highlighter-tool').addEventListener('click', () => setTool('highlighter'));
      document.getElementById('eraser-tool').addEventListener('click', () => setTool('eraser'));
      
      // Color selection
      const colorSwatches = document.querySelectorAll('.color-swatch');
      colorSwatches.forEach(swatch => {
        swatch.addEventListener('click', () => {
          colorSwatches.forEach(s => s.classList.remove('active'));
          swatch.classList.add('active');
          currentStyle[shared.STROKE.COLOR] = swatch.dataset.color;
        });
      });
      
      // Width selection
      widthSelector.addEventListener('input', () => {
        const width = parseInt(widthSelector.value);
        widthValue.textContent = width;
        currentStyle[shared.STROKE.WIDTH] = width;
      });
      
      // Page navigation
      document.getElementById('prev-page').addEventListener('click', () => navigateToPage(pageNr - 1));
      document.getElementById('next-page').addEventListener('click', () => navigateToPage(pageNr + 1));
      document.getElementById('add-page').addEventListener('click', addNewPage);
      document.getElementById('delete-page').addEventListener('click', deletePage);
      
      // Zoom controls
      document.getElementById('zoom-in').addEventListener('click', () => adjustZoom(0.1));
      document.getElementById('zoom-out').addEventListener('click', () => adjustZoom(-0.1));
      
      // Undo/Redo buttons
      undoBtn.addEventListener('click', handleUndo);
      redoBtn.addEventListener('click', handleRedo);
      
      // Canvas events
      canvas.addEventListener('pointerdown', handlePointerDown);
      canvas.addEventListener('pointermove', handlePointerMove);
      canvas.addEventListener('pointerup', handlePointerUp);
      canvas.addEventListener('pointerleave', handlePointerUp);
      
      // Prevent default touch behaviors
      canvas.addEventListener('touchstart', e => e.preventDefault());
      canvas.addEventListener('touchmove', e => e.preventDefault());
      canvas.addEventListener('touchend', e => e.preventDefault());
      
      // Keyboard shortcuts
      document.addEventListener('keydown', handleKeyDown);
    }
    
    // Handle keyboard shortcuts
    function handleKeyDown(e) {
      // Undo: Ctrl+Z
      if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
        e.preventDefault();
        if (!undoBtn.disabled) {
          handleUndo();
        }
      }
      // Redo: Ctrl+Y or Ctrl+Shift+Z
      else if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
        e.preventDefault();
        if (!redoBtn.disabled) {
          handleRedo();
        }
      }
    }
    
    // Update undo/redo button states
    function updateUndoRedoButtons() {
      undoBtn.disabled = myActions.length === 0;
      redoBtn.disabled = undoneActions.size === 0;
    }
    
    // Handle undo action
    function handleUndo() {
      if (myActions.length === 0) return;
      
      // Get most recent action
      const actionToUndo = myActions[myActions.length - 1];
      
      // Create undo action
      const undoAction = {
        type: shared.MOD_ACTIONS.UNDO.TYPE,
        [shared.MOD_ACTIONS.UNDO.TARGET_ACTION_UUID]: actionToUndo,
        [shared.MOD_ACTIONS.UNDO.CLIENT_ID]: clientId
      };
      
      // Send undo proposal
      sendUndoRedoAction(undoAction);
    }
    
    // Handle redo action
    function handleRedo() {
      if (undoneActions.size === 0) return;
      
      // Find the most recently undone action's undo action
      let targetUndoAction = null;
      let originalAction = null;
      
      // Iterate through myActions in reverse to find the most recent undo
      for (let i = myActions.length - 1; i >= 0; i--) {
        const actionUuid = myActions[i];
        
        // Check if this is an undo action in our map
        for (const [original, undo] of undoneActions.entries()) {
          if (undo === actionUuid) {
            targetUndoAction = actionUuid;
            originalAction = original;
            break;
          }
        }
        
        if (targetUndoAction) break;
      }
      
      if (!targetUndoAction) return;
      
      // Create redo action (undo of the undo)
      const redoAction = {
        type: shared.MOD_ACTIONS.REDO.TYPE,
        [shared.MOD_ACTIONS.REDO.TARGET_UNDO_ACTION_UUID]: targetUndoAction,
        [shared.MOD_ACTIONS.REDO.CLIENT_ID]: clientId
      };
      
      // Send redo proposal
      sendUndoRedoAction(redoAction);
    }
    
    // Send undo or redo action to server
    function sendUndoRedoAction(action) {
      const actionUuid = shared.generateUuid();
      
      const proposal = {
        type: shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.TYPE,
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAGE_UUID]: currentPageUuid,
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.ACTION_UUID]: actionUuid,
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.BEFORE_HASH]: verifiedHash,
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD]: action
      };
      
      // Create optimistic update
      const optimisticAction = {
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.ACTION_UUID]: actionUuid,
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD]: action,
        clientId: clientId
      };
      
      // Add to optimistic updates
      optimisticUpdates.push(optimisticAction);
      
      // Temporarily disable undo/redo buttons until server responds
      undoBtn.disabled = true;
      redoBtn.disabled = true;
      
      // Send to server
      sendMessage(proposal);
    }
    
    // Set current tool
    function setTool(tool) {
      currentTool = tool;
      
      // Update UI
      document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
      document.getElementById(`${tool}-tool`).classList.add('active');
      
      // Set appropriate styles for the tool
      switch (tool) {
        case 'pen':
          currentStyle = [
            "stroke",                       // type
            [],                             // points
            currentStyle[shared.STROKE.COLOR],  // maintain color
            currentStyle[shared.STROKE.WIDTH],  // maintain width
            shared.PEN_TYPES.MARKER,        // penType
            1.0,                            // opacity
            shared.CAP_STYLES.ROUND,        // capStyle
            shared.JOIN_STYLES.ROUND,       // joinStyle
            [0],                            // dashPattern
            1.0,                            // pressureSensitivity
            1                               // layer
          ];
          break;
        case 'highlighter':
          currentStyle = [
            "stroke",                       // type
            [],                             // points
            currentStyle[shared.STROKE.COLOR],  // maintain color
            currentStyle[shared.STROKE.WIDTH],  // maintain width
            shared.PEN_TYPES.HIGHLIGHTER,   // penType
            0.5,                            // opacity
            shared.CAP_STYLES.SQUARE,       // capStyle
            shared.JOIN_STYLES.ROUND,       // joinStyle
            [0],                            // dashPattern
            0.3,                            // pressureSensitivity
            1                               // layer
          ];
          break;
      }
      
      // Update cursor
      switch (tool) {
        case 'pen':
          canvas.style.cursor = 'crosshair';
          break;
        case 'highlighter':
          canvas.style.cursor = 'crosshair';
          break;
        case 'eraser':
          canvas.style.cursor = 'cell';
          break;
      }
    }
    
    // Adjust zoom level
    function adjustZoom(delta) {
      zoomLevel = Math.max(0.5, Math.min(3, zoomLevel + delta));
      zoomLevelDisplay.textContent = `${Math.round(zoomLevel * 100)}%`;
      applyZoom();
      redrawCanvas();
    }
    
    // Update page info display
    function updatePageInfo() {
      if (pageNr > 0 && totalPages > 0) {
        pageInfo.textContent = `Page ${pageNr} of ${totalPages}`;
      } else {
        // Handle edge case when server returns invalid page numbers
        pageInfo.textContent = "Page data unavailable";
      }
    }
    
    // Handle pointer down event
    function handlePointerDown(event) {
      const rect = canvas.getBoundingClientRect();
      const x = (event.clientX - rect.left) / zoomLevel;
      const y = (event.clientY - rect.top) / zoomLevel;
      const pressure = event.pressure !== undefined ? event.pressure : 1.0;
      
      if (currentTool === 'eraser') {
        isErasing = true;
        
        // Find strokes near this point and erase them
        const strokeUuid = findStrokeToErase(x, y);
        if (strokeUuid) {
          sendEraseAction(strokeUuid);
        }
      } else {
        isDrawing = true;
        currentPath = [];
        
        // Create point in compact format [x, y, pressure, timestamp]
        const point = [x, y, pressure, Date.now()];
        currentPath.push(point);
      }
    }
    
    // Handle pointer move event
    function handlePointerMove(event) {
      const rect = canvas.getBoundingClientRect();
      const x = (event.clientX - rect.left) / zoomLevel;
      const y = (event.clientY - rect.top) / zoomLevel;
      const pressure = event.pressure !== undefined ? event.pressure : 1.0;
      
      if (currentTool === 'eraser' && isErasing) {
        // Find strokes near this point and erase them
        const strokeUuid = findStrokeToErase(x, y);
        if (strokeUuid) {
          sendEraseAction(strokeUuid);
        }
      } else if (isDrawing) {
        // Create point in compact format
        const point = [x, y, pressure, Date.now()];
        currentPath.push(point);
        
        // Create a temporary stroke for drawing
        const tempStroke = [...currentStyle];  // Clone the style
        tempStroke[shared.STROKE.POINTS] = currentPath.slice(-2);  // Last two points
        
        drawStroke(tempStroke);
      }
    }
    
    // Handle pointer up event
    function handlePointerUp() {
      if (currentTool === 'eraser') {
        isErasing = false;
      } else if (isDrawing) {
        isDrawing = false;
        
        if (currentPath.length >= 2) {
          // Create a complete stroke using the current style and path
          const stroke = [...currentStyle];  // Clone the style
          stroke[shared.STROKE.POINTS] = [...currentPath];  // All points
          
          sendStroke(stroke);
        }
        
        currentPath = [];
      }
    }
    
    // Find a stroke to erase at the given position
    function findStrokeToErase(x, y) {
      // Combine verified and optimistic actions
      const allActions = [...verifiedModActions, ...optimisticUpdates];
      
      // Find actions that have been undone
      const undoneActionIds = new Set();
      for (const action of allActions) {
        const payload = action[shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD];
        if (!payload) continue;
        
        // If this is an undo action, mark its target as undone
        if (payload.type === shared.MOD_ACTIONS.UNDO.TYPE) {
          undoneActionIds.add(payload[shared.MOD_ACTIONS.UNDO.TARGET_ACTION_UUID]);
        }
        
        // If this is a redo action, unmark its target's target
        if (payload.type === shared.MOD_ACTIONS.REDO.TYPE) {
          const targetUndoActionUuid = payload[shared.MOD_ACTIONS.REDO.TARGET_UNDO_ACTION_UUID];
          
          // Find the undo action in the list
          const undoAction = allActions.find(a => 
            a[shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.ACTION_UUID] === targetUndoActionUuid
          );
          
          if (undoAction && undoAction[shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD]) {
            const originalActionUuid = undoAction[shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD][shared.MOD_ACTIONS.UNDO.TARGET_ACTION_UUID];
            undoneActionIds.delete(originalActionUuid);
          }
        }
      }
      
      // Find the most recent DRAW action with a stroke near this point
      for (let i = allActions.length - 1; i >= 0; i--) {
        const action = allActions[i];
        if (!action[shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD]) continue;
        
        const actionUuid = action[shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.ACTION_UUID];
        
        // Skip if this action has been undone
        if (undoneActionIds.has(actionUuid)) continue;
        
        const payload = action[shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD];
        if (payload.type === shared.MOD_ACTIONS.DRAW.TYPE) {
          const stroke = payload.stroke;
          if (isPointNearStroke(x, y, stroke)) {
            return actionUuid;
          }
        }
      }
      
      return null;
    }
    
    // Check if a point is near a stroke
    function isPointNearStroke(x, y, stroke) {
      if (!stroke || !Array.isArray(stroke[shared.STROKE.POINTS]) || stroke[shared.STROKE.POINTS].length < 2) return false;
      
      const threshold = eraserRadius;
      const points = stroke[shared.STROKE.POINTS];
      
      // Check each segment of the stroke
      for (let i = 1; i < points.length; i++) {
        const p1 = points[i - 1];
        const p2 = points[i];
        
        // Make sure we're using array indices, not object properties
        const x1 = p1[shared.POINT.X];
        const y1 = p1[shared.POINT.Y];
        const x2 = p2[shared.POINT.X];
        const y2 = p2[shared.POINT.Y];
        
        if (x1 === undefined || y1 === undefined || x2 === undefined || y2 === undefined) {
          // Skip invalid points
          continue;
        }
        
        // Calculate distance from point to line segment
        const distance = distanceToLineSegment(x, y, x1, y1, x2, y2);
        
        if (distance < threshold) {
          return true;
        }
      }
      
      return false;
    }
    
    // Calculate distance from point to line segment
    function distanceToLineSegment(px, py, x1, y1, x2, y2) {
      const A = px - x1;
      const B = py - y1;
      const C = x2 - x1;
      const D = y2 - y1;
      
      const dot = A * C + B * D;
      const lenSq = C * C + D * D;
      let param = -1;
      
      if (lenSq !== 0) {
        param = dot / lenSq;
      }
      
      let xx, yy;
      
      if (param < 0) {
        xx = x1;
        yy = y1;
      } else if (param > 1) {
        xx = x2;
        yy = y2;
      } else {
        xx = x1 + param * C;
        yy = y1 + param * D;
      }
      
      const dx = px - xx;
      const dy = py - yy;
      
      return Math.sqrt(dx * dx + dy * dy);
    }
    
    // Send an erase action to the server
    function sendEraseAction(strokeUuid) {
      if (!strokeUuid) return;
      
      const actionUuid = shared.generateUuid();
      
      // Create the erase action in the format the server expects
      const action = {
        type: shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.TYPE,
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAGE_UUID]: currentPageUuid,
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.ACTION_UUID]: actionUuid,
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.BEFORE_HASH]: verifiedHash,
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD]: {
          type: shared.MOD_ACTIONS.ERASE.TYPE,
          [shared.MOD_ACTIONS.ERASE.ACTION_UUID]: strokeUuid
        }
      };
      
      // Calculate expected hash
      const nextHash = shared.hashNext(verifiedHash, action[shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD]);
      
      // Add to optimistic updates
      const optimisticAction = {
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.ACTION_UUID]: actionUuid,
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD]: action[shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD],
        hashes: {
          [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.BEFORE_HASH]: verifiedHash,
          [shared.MESSAGES.SERVER_TO_CLIENT.ACCEPT_MESSAGE.AFTER_HASH]: nextHash
        },
        clientId: clientId // Add client ID for undo tracking
      };
      
      optimisticUpdates.push(optimisticAction);
      
      // Send to server
      sendMessage(action);
      
      // Immediately redraw with the stroke removed
      redrawCanvas();
    }
    
    // Send a stroke to the server
    function sendStroke(stroke) {
      const actionUuid = shared.generateUuid();
      lastDrawUuid = actionUuid; // Store for eraser
      
      const action = {
        type: shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.TYPE,
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAGE_UUID]: currentPageUuid,
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.ACTION_UUID]: actionUuid,
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.BEFORE_HASH]: verifiedHash,
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD]: {
          type: shared.MOD_ACTIONS.DRAW.TYPE,
          stroke: stroke
        }
      };
      
      // Calculate expected hash
      const nextHash = shared.hashNext(verifiedHash, action[shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD]);
      
      // Add to optimistic updates
      const optimisticAction = {
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.ACTION_UUID]: actionUuid,
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD]: action[shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD],
        hashes: {
          [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.BEFORE_HASH]: verifiedHash,
          [shared.MESSAGES.SERVER_TO_CLIENT.ACCEPT_MESSAGE.AFTER_HASH]: nextHash
        },
        clientId: clientId // Add client ID for undo tracking
      };
      
      optimisticUpdates.push(optimisticAction);
      
      // Send to server
      sendMessage(action);
    }
    
    // Add a new page
    function addNewPage() {
      const actionUuid = shared.generateUuid();
      
      const action = {
        type: shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.TYPE,
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAGE_UUID]: currentPageUuid,
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.ACTION_UUID]: actionUuid,
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.BEFORE_HASH]: verifiedHash,
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD]: {
          type: shared.MOD_ACTIONS.NEW_PAGE.TYPE
        }
      };
      
      debugLog('Sending new page action', action);
      sendMessage(action);
    }
    
    // Delete current page
    function deletePage() {
      if (totalPages <= 1) {
        alert("Cannot delete the only page");
        return;
      }
      
      const actionUuid = shared.generateUuid();
      
      const action = {
        type: shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.TYPE,
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAGE_UUID]: currentPageUuid,
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.ACTION_UUID]: actionUuid,
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.BEFORE_HASH]: verifiedHash,
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD]: {
          type: shared.MOD_ACTIONS.DELETE_PAGE.TYPE
        }
      };
      
      // Send to server
      debugLog('Sending delete page action', action);
      sendMessage(action);
    }
    
    // Navigate to a specific page
    function navigateToPage(pageNumber) {
      if (pageNumber < 1 || pageNumber > totalPages) {
        return;
      }
      
      const requestId = createRequestId();
      
      // Using the structure the server expects for page requests
      const fullPageRequest = {
        type: shared.MESSAGES.CLIENT_TO_SERVER.FULL_PAGE_REQUESTS.TYPE,
        boardId: boardId,
        [shared.MESSAGES.CLIENT_TO_SERVER.FULL_PAGE_REQUESTS.PAGE_NUMBER]: pageNumber,
        [shared.MESSAGES.CLIENT_TO_SERVER.FULL_PAGE_REQUESTS.REQUEST_ID]: requestId
      };
      
      debugLog('Sending page request', fullPageRequest);
      sendMessage(fullPageRequest);
    }
    
    // Request replay from server
    function requestReplay(pageUuid, beforeHash) {
      const requestId = createRequestId();
      
      const replayMessage = {
        type: shared.MESSAGES.CLIENT_TO_SERVER.REPLAY_REQUESTS.TYPE,
        boardId: boardId,
        [shared.MESSAGES.CLIENT_TO_SERVER.REPLAY_REQUESTS.PAGE_UUID]: pageUuid,
        [shared.MESSAGES.CLIENT_TO_SERVER.REPLAY_REQUESTS.BEFORE_HASH]: beforeHash,
        [shared.MESSAGES.CLIENT_TO_SERVER.REPLAY_REQUESTS.REQUEST_ID]: requestId
      };
      
      sendMessage(replayMessage);
    }
    
    // Draw a stroke on the canvas
    function drawStroke(stroke) {
      if (!stroke || !Array.isArray(stroke[shared.STROKE.POINTS]) || stroke[shared.STROKE.POINTS].length < 2) return;
      
      const points = stroke[shared.STROKE.POINTS];
      
      ctx.save();
      
      // Apply style
      ctx.strokeStyle = stroke[shared.STROKE.COLOR];
      ctx.lineWidth = stroke[shared.STROKE.WIDTH];
      
      if (stroke[shared.STROKE.PEN_TYPE] === shared.PEN_TYPES.HIGHLIGHTER) {
        ctx.globalAlpha = 0.5;
        ctx.lineJoin = "round";
        ctx.lineCap = "square";
      } else {
        ctx.globalAlpha = stroke[shared.STROKE.OPACITY];
        ctx.lineJoin = shared.getJoinStyleString(stroke[shared.STROKE.JOIN_STYLE]);
        ctx.lineCap = shared.getCapStyleString(stroke[shared.STROKE.CAP_STYLE]);
      }
      
      const dashPattern = stroke[shared.STROKE.DASH_PATTERN];
      if (dashPattern && dashPattern.length > 1) {
        ctx.setLineDash(dashPattern);
      } else {
        ctx.setLineDash([]);
      }
      
      // Draw the stroke
      ctx.beginPath();
      ctx.moveTo(points[0][shared.POINT.X], points[0][shared.POINT.Y]);
      
      for (let i = 1; i < points.length; i++) {
        const point = points[i];
        
        // Apply pressure sensitivity if available
        if (stroke[shared.STROKE.PRESSURE_SENS] > 0 && point[shared.POINT.PRESSURE] !== undefined) {
          const pressureEffect = 1 + (point[shared.POINT.PRESSURE] - 1) * stroke[shared.STROKE.PRESSURE_SENS];
          ctx.lineWidth = stroke[shared.STROKE.WIDTH] * pressureEffect;
        }
        
        ctx.lineTo(point[shared.POINT.X], point[shared.POINT.Y]);
      }
      
      ctx.stroke();
      ctx.restore();
    }
    
    // Redraw the entire canvas
    function redrawCanvas() {
      ctx.save();
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.restore();
      
      // Collect all actions (verified + optimistic)
      const allActions = [...verifiedModActions, ...optimisticUpdates];
      
      // Find actions that have been undone
      const undoneActionIds = new Set();
      
      // First pass: identify all undone actions
      for (const action of allActions) {
        if (!action[shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD]) continue;
        
        const payload = action[shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD];
        
        // If this is an undo action, mark its target as undone
        if (payload.type === shared.MOD_ACTIONS.UNDO.TYPE) {
          undoneActionIds.add(payload[shared.MOD_ACTIONS.UNDO.TARGET_ACTION_UUID]);
        }
        
        // If this is a redo action, unmark its target's target
        if (payload.type === shared.MOD_ACTIONS.REDO.TYPE) {
          const targetUndoActionUuid = payload[shared.MOD_ACTIONS.REDO.TARGET_UNDO_ACTION_UUID];
          
          // Find the undo action in the list
          const undoAction = allActions.find(a => 
            a[shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.ACTION_UUID] === targetUndoActionUuid
          );
          
          if (undoAction && undoAction[shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD]) {
            const originalActionUuid = undoAction[shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD][shared.MOD_ACTIONS.UNDO.TARGET_ACTION_UUID];
            undoneActionIds.delete(originalActionUuid);
          }
        }
      }
      
      // Second pass: draw non-undone strokes
      for (const action of allActions) {
        if (!action[shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD]) continue;
        
        // Skip drawing if this action has been undone
        if (undoneActionIds.has(action[shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.ACTION_UUID])) {
          continue;
        }
        
        const payload = action[shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD];
        if (payload.type === shared.MOD_ACTIONS.DRAW.TYPE) {
          drawStroke(payload.stroke);
        }
      }
    }
    
    // Send a group action (for future use)
    function sendGroupAction(actions) {
      if (!Array.isArray(actions) || actions.length === 0) return;
      
      const groupUuid = shared.generateUuid();
      
      // Prepare actions with client-generated UUIDs
      const groupActions = actions.map(action => {
        return {
          actionUuid: shared.generateUuid(),
          payload: action
        };
      });
      
      // Create group action proposal
      const groupProposal = {
        type: shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.TYPE,
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAGE_UUID]: currentPageUuid,
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.ACTION_UUID]: groupUuid,
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.BEFORE_HASH]: verifiedHash,
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD]: {
          type: shared.MOD_ACTIONS.GROUP.TYPE,
          [shared.MOD_ACTIONS.GROUP.ACTIONS]: groupActions
        }
      };
      
      // Calculate expected hash
      const nextHash = shared.hashNext(verifiedHash, groupProposal[shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD]);
      
      // Add to optimistic updates
      const optimisticAction = {
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.ACTION_UUID]: groupUuid,
        [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD]: groupProposal[shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD],
        hashes: {
          [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.BEFORE_HASH]: verifiedHash,
          [shared.MESSAGES.SERVER_TO_CLIENT.ACCEPT_MESSAGE.AFTER_HASH]: nextHash
        },
        clientId: clientId
      };
      
      optimisticUpdates.push(optimisticAction);
      
      // Send to server
      sendMessage(groupProposal);
    }
    
    // Initialize the app
    window.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>
