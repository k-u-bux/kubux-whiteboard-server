<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#0078d7">
    <link rel="manifest" href="/manifest.json">
    <title>Whiteboard App</title>
    <style>
      body {
          margin: 0;
          padding: 0;
          font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
          overflow: hidden;
          display: flex; /* Make body a flex container */
          flex-direction: column; /* Stack children vertically */
          height: 100vh;
      }
      
      .toolbar {
          display: flex;
          background-color: #f0f0f0;
          padding: 5px;
          border-bottom: 1px solid #ccc;
      }
      
      .tool-section {
          display: flex;
          align-items: center;
          margin-right: 10px;
          padding-right: 10px;
          border-right: 1px solid #ddd;
      }

      .tool-btn {
          width: 30px;
          height: 30px;
          margin: 0 2px;
          cursor: pointer;
          border: 3px solid #f0f0f0;
          background-color: #f0f0f0;
          border-radius: 4px;
      }
      
      .tool-btn:hover {
          background-color: #e0e0e0;
      }
      
      .tool-btn:disabled {
          opacity: 0.5;
          cursor: not-allowed;
      }
      
      .tool-btn.active {
      border: 3px solid transparent;
      }
      
      .shape-btn {
          width: 30px;
          height: 30px;
          margin: 0 2px;
          cursor: pointer;
          border: 3px solid #f0f0f0;
          background-color: #f0f0f0;
          border-radius: 4px;
      }
      
      .shape-btn:hover {
          background-color: #e0e0e0;
      }

      .shape-btn:disabled {
          opacity: 0.5;
          cursor: not-allowed;
      }
      
      .shape-btn.active {
          border: 3px solid transparent;
          background-color: #808080;
      }
      
      .color-swatch {
          width: 12px;
          height: 12px;
          border-radius: 50%;
          margin: 3px;
          cursor: pointer;
          border: 1px solid #ccc;
      }
      
      .color-swatch.active {
          width: 12px;
          height: 12px;
          /* border-color: #333; */
          /* border-width: 6px; */
      }
      
      /* Base slider styles */
      input[type="range"] {
          -webkit-appearance: none;
          width: 100px; /* Swap width and height for vertical layout */
          height: 8px;
          background: #d3d3d3;
          outline: none;
          opacity: 0.7;
          transition: opacity .2s;
      }
      
      input[type="range"]::-webkit-slider-thumb {
          -webkit-appearance: none;
          appearance: none;
          border-radius: 50%;
          background: var(--thumb-color, black);
          cursor: pointer;
          width: calc(var(--thumb-size, 2) * 2px); 
          height: calc(var(--thumb-size, 2) * 2px);
      }
      
      input[type="range"]::-moz-range-thumb {
          border: none;
          border-radius: 50%;
          background: var(--thumb-color, black);
          cursor: pointer;
          width: calc(var(--thumb-size, 2) * 2px);
          height: calc(var(--thumb-size, 2) * 2px);
      }
      
      /* Specific styles for the opacity slider */
      #opacity-selector {
          background: #fff;
      }
      
      #opacity-selector::-webkit-slider-thumb {
          width: 24px;
          height: 24px;
          background: black;
          /* background: var(--thumb-color); */
          opacity: var(--thumb-opacity, 1);
      }
      
      #opacity-selector::-moz-range-thumb {
          width: 24px;
          height: 24px;
          background: black;
          /* background: var(--thumb-color); */
          filter: opacity( var(--thumb-opacity, 1));
      }
      
      #debug-tools {
          margin-left: auto;
      }

      #layer-controls {
          margin-left: auto;
      }

      .app-container {
          display: flex;
          flex-grow: 1;
      }
      
      .sidebar {
          width: 50px; /* Reduced width for a more compact sidebar */
          background-color: #f0f0f0;
          /* border-right: 0px solid #ccc; */
          padding: 4px 0px;
          display: flex;
          flex-direction: column;
          align-items: center;
      }

      .sidebar-section {
          width: 100%;
          box-sizing: border-box;
          display: flex;
          flex-direction: column;
          align-items: center; /* Center content within each section */
          padding: 4px 0px;
          margin-bottom: 1px;
          border-bottom: 1px solid #ddd;
      }
      
      .sidebar-section:last-child {
          border-bottom: none;
      }
      
      #width-selection, #opacity-selection {
          /* Apply styles to the individual slider sections */
          height: 120px; /* Give the containers enough space to hold the rotated sliders */
          justify-content: center;
      }
      
      #width-selector, #opacity-selector {
          transform: rotate(90deg); /* Rotate the sliders */
          transform-origin: 50% 50%; /* Ensure rotation is centered */
      }
      
      .main-content {
          flex-grow: 1;
          overflow: hidden;
      }
      
      #canvas-container {
          position: relative;
          width: 100%;
          height: 100%;
      }
      
      canvas {
          position: absolute;
          background-color: white;
          box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
      }
      
      .page-controls {
          display: flex;
          align-items: center;
      }
      
      #page-info {
          margin: 0 10px;
      }
      
      .error-banner {
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          background-color: #f44336;
          color: white;
          padding: 15px;
          text-align: center;
          z-index: 1000;
          display: none;
      }
      
      .error-banner button {
          margin-left: 15px;
          background-color: white;
          color: #f44336;
          border: none;
          padding: 5px 10px;
          cursor: pointer;
          border-radius: 4px;
      }
      
      .tooltip {
          position: relative;
          display: inline-block;
      }
      
      .tooltip .tooltiptext {
          visibility: hidden;
          width: 120px;
          background-color: #555;
          color: #fff;
          text-align: center;
          border-radius: 6px;
          padding: 5px;
          position: absolute;
          z-index: 1;
          bottom: 125%;
          left: 50%;
          margin-left: -60px;
          opacity: 0;
          transition: opacity 0.3s;
          font-size: 12px;
      }
      
      .tooltip:hover .tooltiptext {
          visibility: visible;
          opacity: 1;
      }
      
      /* Simple Color Picker Styles */
      #simple-color-picker {
          position: fixed;
          z-index: 1000;
          background: white;
          border: 1px solid #ccc;
          border-radius: 8px;
          box-shadow: 0 4px 8px rgba(0,0,0,0.2);
          padding: 10px;
          width: 260px;
          display: none;
      }
      
      #simple-color-picker-header {
          display: flex;
          justify-content: space-between;
          align-items: center;
          margin-bottom: 10px;
          border-bottom: 1px solid #eee;
          padding-bottom: 5px;
      }
      
      #simple-color-picker-title {
          font-weight: bold;
          margin: 0;
      }
      
      #simple-color-picker-close {
          background: none;
          border: none;
          font-size: 18px;
          cursor: pointer;
          padding: 2px 5px;
      }
      
      #color-grid {
          display: grid;
          grid-template-columns: repeat(8, 1fr);
          gap: 4px;
          margin-bottom: 10px;
      }
      
      .color-cell {
          width: 25px;
          height: 25px;
          border-radius: 3px;
          cursor: pointer;
          border: 1px solid #ccc;
      }
      
      .color-cell:hover {
          transform: scale(1.1);
      }
      
      #color-preview {
          height: 30px;
          border-radius: 4px;
          border: 1px solid #ccc;
          margin-bottom: 10px;
          display: flex;
      }
      
      #new-color {
          flex: 3;
          height: 100%;
      }
      
      #original-color {
          flex: 1;
          height: 100%;
          border-left: 1px solid #ccc;
      }
      
      #color-controls {
          display: flex;
          justify-content: space-between;
          margin-top: 10px;
      }
      
      #color-picker-actions {
          display: flex;
          gap: 5px;
      }
      
      #color-picker-actions button {
          padding: 5px 10px;
          border-radius: 4px;
          cursor: pointer;
      }
      
      #color-picker-apply {
          background-color: #4CAF50;
          color: white;
          border: none;
      }
      
      #color-picker-cancel {
          background-color: #f1f1f1;
          border: 1px solid #ccc;
      }
      
      #hex-input {
          padding: 5px;
          width: 80px;
          border: 1px solid #ccc;
          border-radius: 4px;
      }
      
      /* layers */
      .layer-grid {
          display: flex;
          flex-direction: column;
          gap: 2px;
      }
      
      .visibility-row, .active-row {
          display: flex;
          gap: 5px;
      }
      
      .layer-visibility-btn, .layer-active-btn {
          width: 12px;
          height: 12px;
          padding: 0;
          font-size: 9px;
          border: 1px solid #ccc;
          background-color: #f0f0f0;
          cursor: pointer;
          border-radius: 3px;
      }
      
      /* Visibility button styling */
      .layer-visibility-btn {
          opacity: 0.5;
      }
      
      .layer-visibility-btn.active {
          opacity: 1;
          background-color: #e6e6e6;
          border-color: #999;
      }
      
      /* Active layer button styling */
      .layer-active-btn {
          background-color: #f0f0f0;
      }
      
      .layer-active-btn.active {
          background-color: #3498db;
          color: white;
          border-color: #2980b9;
      }
      
      /* Visual indicator to distinguish rows */
      .visibility-row {
          border-bottom: 1px dotted #ccc;
          padding-bottom: 2px;
      }
      
      /* Selection tool specific styles */
      .selection-handle {
          width: 8px;
          height: 8px;
          background-color: white;
          border: 1px solid #0078d7;
          position: absolute;
          cursor: pointer;
      }
      
      /* Board Navigation Overlay */
      #board-nav-overlay {
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background-color: rgba(0, 0, 0, 0.5);
          display: none;
          justify-content: center;
          align-items: center;
          z-index: 2000;
      }
      
      #board-nav-window {
          background: white;
          border-radius: 8px;
          box-shadow: 0 4px 16px rgba(0,0,0,0.3);
          width: 400px;
          max-width: 90%;
      }
      
      #board-nav-header {
          display: flex;
          justify-content: space-between;
          align-items: center;
          padding: 15px 20px;
          border-bottom: 1px solid #ddd;
      }
      
      #board-nav-title {
          font-size: 18px;
          font-weight: bold;
          margin: 0;
      }
      
      #board-nav-close {
          background: none;
          border: none;
          font-size: 24px;
          cursor: pointer;
          color: #666;
          padding: 0;
          width: 30px;
          height: 30px;
          line-height: 1;
      }
      
      #board-nav-close:hover {
          color: #000;
      }
      
      .board-nav-section {
          padding: 20px;
          border-bottom: 1px solid #ddd;
      }
      
      .board-nav-section:last-child {
          border-bottom: none;
      }
      
      .board-nav-section h3 {
          margin: 0 0 15px 0;
          font-size: 16px;
          color: #333;
      }
      
      .board-nav-form {
          display: flex;
          flex-direction: column;
          gap: 10px;
      }
      
      .board-nav-form input {
          padding: 10px;
          border: 1px solid #ddd;
          border-radius: 4px;
          font-size: 14px;
      }
      
      .board-nav-form input:focus {
          outline: none;
          border-color: #0078d7;
      }
      
      .board-nav-actions {
          display: flex;
          justify-content: flex-end;
      }
      
      .board-nav-btn {
          padding: 10px 20px;
          border: none;
          border-radius: 4px;
          font-size: 14px;
          cursor: pointer;
          background-color: #0078d7;
          color: white;
      }
      
      .board-nav-btn:hover {
          background-color: #005a9e;
      }
      
      .board-nav-btn:disabled {
          background-color: #ccc;
          cursor: not-allowed;
      }
    </style>
  </head>
  <body>
    <div class="error-banner" id="error-banner">
      <span id="error-message">Connection error</span>
      <button id="reconnect-button">Reconnect</button>
    </div>
    
    <div class="toolbar">
      <div class="tool-section" id="export-pdf">
        <button class="tool-btn" id="pdf-btn" title="Export Current Page to PDF">üìÉ</button>
        <button class="tool-btn" id="pdf-board-btn" title="Export Entire Board to PDF">üìö</button>
      </div>

      <div class="tool-section page-controls">
        <button class="tool-btn" id="first-page" title="First Page">‚èÆÔ∏è</button>
        <button class="tool-btn" id="prev-page" title="Previous Page">‚óÄÔ∏è</button>
        <span id="page-info">Page 1 of 1</span>
        <button class="tool-btn" id="next-page" title="Next Page">‚ñ∂Ô∏è</button>
        <button class="tool-btn" id="last-page" title="Last Page">‚è≠Ô∏è</button>
        <button class="tool-btn" id="add-page" title="Add Page">‚ûï</button>
        <button class="tool-btn" id="delete-page" title="Delete Page">‚ûñ</button>
      </div>
      
      <div class="tool-section">
        <button class="tool-btn" id="zoom-out">-</button>
        <span id="zoom-level">100%</span>
        <button class="tool-btn" id="zoom-in">+</button>
        <button class="tool-btn" id="hand-tool" title="Pan (Hand Tool)">‚úã</button>
        <button class="tool-btn" id="reset-view" title="Reset View (Center, 100%)">‚åñ</button>
      </div>
      
      <div class="tool-section">
        <button class="tool-btn tooltip" id="undo-btn" title="Undo" disabled>‚Ü©
          <span class="tooltiptext">Undo (Ctrl+Z)</span>
        </button>
        <button class="tool-btn tooltip" id="redo-btn" title="Redo" disabled>‚Ü™
          <span class="tooltiptext">Redo (Ctrl+Y)</span>
        </button>
        <button class="tool-btn" id="paste-btn" title="Paste">üìå</button>
      </div>
      
      <div class="tool-section">
        <button class="tool-btn" id="chalk-tool" title="Chalk"><span style="filter: grayscale(100%) invert(100%);">üñçÔ∏è</span></button>
        <button class="tool-btn active" id="pen-tool" title="Pen">‚úèÔ∏è</button>
        <button class="tool-btn" id="highlighter-tool" title="Highlighter">üñåÔ∏è</button>
        <button class="tool-btn" id="eraser-tool" title="Eraser">üßΩ</button>
      </div>

      <div class="tool-section">
        <button class="tool-btn" id="selection-rectangle-tool" title="Rectangle Selection">‚ñ≠</button>
        <button class="tool-btn" id="selection-lasso-tool" title="Lasso Selection">‚≠ï</button>
        <button class="tool-btn" id="selection-stroke-tool" title="Stroke Selection">„Ä∞Ô∏è</button>
      </div>

      <div class="tool-section" id="layer-controls">
        <div class="layer-grid">
          <!-- Visibility Row -->
          <div class="visibility-row">
            <button class="layer-visibility-btn active" data-layer="0" title="Toggle Layer 1 Visibility">1</button>
            <button class="layer-visibility-btn active" data-layer="1" title="Toggle Layer 2 Visibility">2</button>
            <button class="layer-visibility-btn active" data-layer="2" title="Toggle Layer 3 Visibility">3</button>
            <button class="layer-visibility-btn active" data-layer="3" title="Toggle Layer 4 Visibility">4</button>
            <button class="layer-visibility-btn active" data-layer="4" title="Toggle Layer 5 Visibility">5</button>
            <button class="layer-visibility-btn active" data-layer="5" title="Toggle Layer 6 Visibility">6</button>
            <button class="layer-visibility-btn active" data-layer="6" title="Toggle Layer 7 Visibility">7</button>
            <button class="layer-visibility-btn active" data-layer="7" title="Toggle Layer 8 Visibility">8</button>
          </div>
          <!-- Active Layer Row -->
          <div class="active-row">
            <button class="layer-active-btn active" data-layer="0" title="Draw on Layer 1">1</button>
            <button class="layer-active-btn" data-layer="1" title="Draw on Layer 2">2</button>
            <button class="layer-active-btn" data-layer="2" title="Draw on Layer 3">3</button>
            <button class="layer-active-btn" data-layer="3" title="Draw on Layer 4">4</button>
            <button class="layer-active-btn" data-layer="4" title="Draw on Layer 5">5</button>
            <button class="layer-active-btn" data-layer="5" title="Draw on Layer 6">6</button>
            <button class="layer-active-btn" data-layer="6" title="Draw on Layer 7">7</button>
            <button class="layer-active-btn" data-layer="7" title="Draw on Layer 8">8</button>
          </div>
        </div>
      </div>      

      <div class="tool-section" id="debug-tools">
        <button class="tool-btn" id="board-nav-btn" title="Board Navigation">üóÇÔ∏è</button>
        <!-- <span id="sync-status">‚úì</span> -->
      </div>
    </div>
    
    <div class="app-container">
      <div class="sidebar">
        <div class="tool-section sidebar-section" id="color-selection">
          <div class="color-swatch" title="Press and hold to open color picker" style="background-color: black;" data-color="black"></div>
          <div class="color-swatch" title="Press and hold to open color picker" style="background-color: red;" data-color="red"></div>
          <div class="color-swatch" title="Press and hold to open color picker" style="background-color: green;" data-color="green"></div>
          <div class="color-swatch" title="Press and hold to open color picker" style="background-color: blue;" data-color="blue"></div>
          <div class="color-swatch" title="Press and hold to open color picker" style="background-color: yellow;" data-color="yellow"></div>
        </div>
        <div class="tool-section sidebar-section" id="width-selection">
          <input type="range" id="width-selector" min="1" max="20">
        </div>
        <div class="tool-section sidebar-section" id="opacity-selection">
          <input type="range" id="opacity-selector" min="0" max="128">
        </div>
        <div class="tool-section sidebar-section" id="timer-toggle">
          <button class="shape-btn" id="timer-btn" title="Timer">üïê</button>
        </div>
        <div class="tool-section sidebar-section" id="loop-toggle">
          <button class="shape-btn" id="loop-btn" title="open stroke / closed loop"></button>
        </div>
        <div class="tool-section sidebar-section" id="fill-toggle">
          <button class="shape-btn" id="fill-btn" title="draw / fill"></button>
        </div>
        <div class="tool-section sidebar-section" id="curve-selection">
          <button class="shape-btn" id="curve-btn" title="rectangle path">‚ö°</button>
        </div>
        <div class="tool-section sidebar-section" id="rectangle-selection">
          <button class="shape-btn" id="rectangle-btn" title="rectangle path">‚ñ≠</button>
        </div>
        <div class="tool-section sidebar-section" id="circle-selection">
          <button class="shape-btn" id="circle-btn" title="circle path">‚óØ</button>
        </div>
        <div class="tool-section sidebar-section" id="horizontal-selection">
          <button class="shape-btn" id="horizontal-btn" title="horizontal line">‚îÄ</button>
        </div>
        <div class="tool-section sidebar-section" id="vertical-selection">
          <button class="shape-btn" id="vertical-btn" title="vertical line">‚îÇ</button>
        </div>
        <div class="tool-section sidebar-section" id="line-selection">
          <button class="shape-btn" id="line-btn" title="straight line">Ôºè</button>
        </div>
        
        <!-- Selection action buttons (shown when selection tool is active) -->
        <div class="tool-section sidebar-section" id="selection-actions-sidebar" style="display: none;">
          <button class="shape-btn" id="cut-btn" title="Cut">‚úÇÔ∏è</button>
        </div>
        <div class="tool-section sidebar-section" id="selection-copy-sidebar" style="display: none;">
          <button class="shape-btn" id="copy-btn" title="Copy">üìã</button>
        </div>
        <div class="tool-section sidebar-section" id="selection-move-sidebar" style="display: none;">
          <button class="shape-btn" id="move-btn" title="Move">üîÑ</button>
        </div>
        <div class="tool-section sidebar-section" id="selection-layer-sidebar" style="display: none;">
          <button class="shape-btn" id="move-layer-btn" title="Move to Layer">‚áÖ</button>
        </div>
        <div class="tool-section sidebar-section" id="selection-deselect-sidebar" style="display: none;">
          <button class="shape-btn" id="deselect-toggle-btn" title="Deselect Mode">‚ûñ</button>
        </div>
      </div>
      
      <div class="main-content">
        <div id="canvas-container">
          <canvas id="canvas"></canvas>
        </div>
      </div>
    </div>


    <!-- Board Navigation Overlay -->
    <div id="board-nav-overlay">
      <div id="board-nav-window">
        <div id="board-nav-header">
          <h3 id="board-nav-title">Board Navigation</h3>
          <button id="board-nav-close">√ó</button>
        </div>
        
        <!-- Copy Link Section -->
        <div class="board-nav-section">
          <h3>Current Board</h3>
          <div class="board-nav-form">
            <button type="button" class="board-nav-btn" id="copy-link-btn">üìã Copy Board Link</button>
            <span id="copy-feedback" style="display: none; color: #4CAF50; margin-left: 10px;">‚úì Copied!</span>
          </div>
        </div>
        
        <!-- New Board Section -->
        <div class="board-nav-section">
          <h3>Create New Board</h3>
          <form class="board-nav-form" id="new-board-form">
            <input type="password" id="new-board-credential-input" placeholder="Enter credential" required>
            <div class="board-nav-actions">
              <button type="submit" class="board-nav-btn" id="new-board-btn">New Board</button>
            </div>
          </form>
        </div>
        
        <!-- Go to Board Section -->
        <div class="board-nav-section">
          <h3>Go to Board</h3>
          <form class="board-nav-form" id="goto-board-form">
            <input type="text" id="board-url-input" placeholder="Paste board URL here">
            <div style="text-align: center; margin: 10px 0; color: #999;">‚Äî or enter details ‚Äî</div>
            <input type="text" id="board-id-input" placeholder="Board UUID">
            <input type="password" id="board-password-input" placeholder="Board password (optional)">
            <div class="board-nav-actions">
              <button type="submit" class="board-nav-btn">Go to Board</button>
            </div>
          </form>
        </div>
      </div>
    </div>

    <!-- Simple Color Picker -->
    <div id="simple-color-picker">
      <div id="simple-color-picker-header">
        <h4 id="simple-color-picker-title">Color Picker</h4>
        <button id="simple-color-picker-close">√ó</button>
      </div>
      
      <div id="color-preview">
        <div id="new-color"></div>
        <div id="original-color"></div>
      </div>
      
      <div id="color-grid">
        <!-- Standard Colors: First Row -->
        <div class="color-cell" style="background-color: #000000" data-color="#000000"></div>
        <div class="color-cell" style="background-color: #808080" data-color="#808080"></div>
        <div class="color-cell" style="background-color: #800000" data-color="#800000"></div>
        <div class="color-cell" style="background-color: #808000" data-color="#808000"></div>
        <div class="color-cell" style="background-color: #008000" data-color="#008000"></div>
        <div class="color-cell" style="background-color: #008080" data-color="#008080"></div>
        <div class="color-cell" style="background-color: #000080" data-color="#000080"></div>
        <div class="color-cell" style="background-color: #800080" data-color="#800080"></div>
        
        <!-- Standard Colors: Second Row -->
        <div class="color-cell" style="background-color: #FFFFFF" data-color="#FFFFFF"></div>
        <div class="color-cell" style="background-color: #C0C0C0" data-color="#C0C0C0"></div>
        <div class="color-cell" style="background-color: #FF0000" data-color="#FF0000"></div>
        <div class="color-cell" style="background-color: #FFFF00" data-color="#FFFF00"></div>
        <div class="color-cell" style="background-color: #00FF00" data-color="#00FF00"></div>
        <div class="color-cell" style="background-color: #00FFFF" data-color="#00FFFF"></div>
        <div class="color-cell" style="background-color: #0000FF" data-color="#0000FF"></div>
        <div class="color-cell" style="background-color: #FF00FF" data-color="#FF00FF"></div>
        
        <!-- More Blues -->
        <div class="color-cell" style="background-color: #000033" data-color="#000033"></div>
        <div class="color-cell" style="background-color: #003399" data-color="#003399"></div>
        <div class="color-cell" style="background-color: #0066CC" data-color="#0066CC"></div>
        <div class="color-cell" style="background-color: #0099FF" data-color="#0099FF"></div>
        <div class="color-cell" style="background-color: #66CCFF" data-color="#66CCFF"></div>
        <div class="color-cell" style="background-color: #99FFFF" data-color="#99FFFF"></div>
        <div class="color-cell" style="background-color: #CCFFFF" data-color="#CCFFFF"></div>
        <div class="color-cell" style="background-color: #EFFFFF" data-color="#EFFFFF"></div>
        
        <!-- More Greens -->
        <div class="color-cell" style="background-color: #003300" data-color="#003300"></div>
        <div class="color-cell" style="background-color: #009933" data-color="#009933"></div>
        <div class="color-cell" style="background-color: #33CC33" data-color="#33CC33"></div>
        <div class="color-cell" style="background-color: #66FF66" data-color="#66FF66"></div>
        <div class="color-cell" style="background-color: #99FF99" data-color="#99FF99"></div>
        <div class="color-cell" style="background-color: #CCFFCC" data-color="#CCFFCC"></div>
        <div class="color-cell" style="background-color: #EFFFEF" data-color="#EFFFEF"></div>
        <div class="color-cell" style="background-color: #F5FFF5" data-color="#F5FFF5"></div>
        
        <!-- More Reds -->
        <div class="color-cell" style="background-color: #330000" data-color="#330000"></div>
        <div class="color-cell" style="background-color: #990000" data-color="#990000"></div>
        <div class="color-cell" style="background-color: #CC3333" data-color="#CC3333"></div>
        <div class="color-cell" style="background-color: #FF6666" data-color="#FF6666"></div>
        <div class="color-cell" style="background-color: #FF9999" data-color="#FF9999"></div>
        <div class="color-cell" style="background-color: #FFCCCC" data-color="#FFCCCC"></div>
        <div class="color-cell" style="background-color: #FFEFEF" data-color="#FFEFEF"></div>
        <div class="color-cell" style="background-color: #FFF5F5" data-color="#FFF5F5"></div>

        <!-- Yellows and Browns -->
        <div class="color-cell" style="background-color: #333300" data-color="#333300"></div>
        <div class="color-cell" style="background-color: #999900" data-color="#999900"></div>
        <div class="color-cell" style="background-color: #CCCC33" data-color="#CCCC33"></div>
        <div class="color-cell" style="background-color: #FFFF66" data-color="#FFFF66"></div>
        <div class="color-cell" style="background-color: #FFFF99" data-color="#FFFF99"></div>
        <div class="color-cell" style="background-color: #FFFFCC" data-color="#FFFFCC"></div>
        <div class="color-cell" style="background-color: #FFFFEF" data-color="#FFFFEF"></div>
        <div class="color-cell" style="background-color: #FFFFF5" data-color="#FFFFF5"></div>
        
        <!-- Browns and Oranges -->
        <div class="color-cell" style="background-color: #663300" data-color="#663300"></div>
        <div class="color-cell" style="background-color: #996633" data-color="#996633"></div>
        <div class="color-cell" style="background-color: #CC9933" data-color="#CC9933"></div>
        <div class="color-cell" style="background-color: #FFCC66" data-color="#FFCC66"></div>
        <div class="color-cell" style="background-color: #FF9933" data-color="#FF9933"></div>
        <div class="color-cell" style="background-color: #FF6600" data-color="#FF6600"></div>
        <div class="color-cell" style="background-color: #FF3300" data-color="#FF3300"></div>
        <div class="color-cell" style="background-color: #CC3300" data-color="#CC3300"></div>
      </div>
      
      <div id="color-controls">
        <input type="text" id="hex-input" placeholder="#RRGGBB">
        <div id="color-picker-actions">
          <button id="color-picker-cancel">Cancel</button>
          <button id="color-picker-apply">Apply</button>
        </div>
      </div>
    </div>

    <script src="shared.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pako@2/dist/pako.min.js"></script>
    <script>
      function debugLog(msg, data) {
          console.log(`[DEBUG] ${msg}`, data || '');
      }

      // Settings persistence (board-specific)
      function getSettingsStorageKey() {
          return `whiteboard_settings_${boardId}`;
      }
      
      function saveSettings() {
          if (!boardId) return; // Cannot save without boardId
          
          try {
              const settings = {
                  pen: pen_settings,
                  chalk: chalk_settings,
                  highlighter: highlighter_settings,
                  eraser: eraser_settings,
                  selectionRectangle: selection_rectangle_settings,
                  selectionLasso: selection_lasso_settings,
                  selectionStroke: selection_stroke_settings,
                  activeLayer: activeLayer,
                  lastTool: currentTool,
                  zoomLevel: zoomLevel,
                  panX: panX,
                  panY: panY,
                  colorSwatches: [],
                  // Page position
                  currentPageUuid: currentPageUuid,
                  pageNr: pageNr,
                  totalPages: totalPages
              };
              
              // Save color swatch customizations
              document.querySelectorAll('.color-swatch').forEach(swatch => {
                  settings.colorSwatches.push({
                      color: swatch.dataset.color,
                      backgroundColor: swatch.style.backgroundColor
                  });
              });
              
              localStorage.setItem(getSettingsStorageKey(), JSON.stringify(settings));
              debugLog('Settings saved', { boardId });
          } catch (err) {
              console.warn('Failed to save settings:', err);
          }
      }
      
      function loadSettings() {
          if (!boardId) return false; // Cannot load without boardId
          
          try {
              const saved = localStorage.getItem(getSettingsStorageKey());
              if (!saved) return false;
              
              const settings = JSON.parse(saved);
              
              // Restore tool settings
              if (settings.pen) Object.assign(pen_settings, settings.pen);
              if (settings.chalk) Object.assign(chalk_settings, settings.chalk);
              if (settings.highlighter) Object.assign(highlighter_settings, settings.highlighter);
              if (settings.eraser) Object.assign(eraser_settings, settings.eraser);
              if (settings.selectionRectangle) Object.assign(selection_rectangle_settings, settings.selectionRectangle);
              if (settings.selectionLasso) Object.assign(selection_lasso_settings, settings.selectionLasso);
              if (settings.selectionStroke) Object.assign(selection_stroke_settings, settings.selectionStroke);
              
              // Restore color swatches
              if (settings.colorSwatches) {
                  const swatches = document.querySelectorAll('.color-swatch');
                  settings.colorSwatches.forEach((swatch, index) => {
                      if (swatches[index]) {
                          swatches[index].dataset.color = swatch.color;
                          swatches[index].style.backgroundColor = swatch.backgroundColor;
                      }
                  });
              }
              
              // Restore active layer
              if (settings.activeLayer !== undefined) {
                  activeLayer = settings.activeLayer;
                  document.querySelectorAll('.layer-active-btn').forEach(btn => {
                      btn.classList.remove('active');
                      if (parseInt(btn.getAttribute('data-layer')) === activeLayer) {
                          btn.classList.add('active');
                      }
                  });
              }
              
              // Restore zoom level
              if (settings.zoomLevel !== undefined) {
                  zoomLevel = settings.zoomLevel;
                  zoomLevelDisplay.textContent = `${Math.round(zoomLevel * 100)}%`;
              }
              
              // Restore pan position
              if (settings.panX !== undefined) panX = settings.panX;
              if (settings.panY !== undefined) panY = settings.panY;
              
              // Apply zoom and pan
              applyZoom();
              
              // Restore last tool
              if (settings.lastTool) {
                  setTool(settings.lastTool);
              }
              
              // Store page position for restoration after connection
              // (Do not navigate yet - wait for WebSocket connection)
              if (settings.currentPageUuid) {
                  window.savedPagePosition = {
                      uuid: settings.currentPageUuid,
                      pageNr: settings.pageNr,
                      totalPages: settings.totalPages
                  };
                  debugLog('Saved page position loaded', window.savedPagePosition);
              }
              
              return true;
          } catch (err) {
              console.warn('Failed to load settings:', err);
              return false;
          }
      }
      
      // settings
      let eraser_settings = {
          tool: "eraser",
          opacity: 0.3,
          color: "#ff0000",
          undo: false,
          fill: false,
          loop: false,
          shape: 'curve',
          width: 2
      };
      let pen_settings = {
          tool: "pen", 
          opacity: 1.0,
          width: 2,
          color: "blue",
          undo: false,
          fill: false,
          loop: false,
          shape: 'curve',
          stroke: shared.createStroke( shared.STROKE_STYLES.PEN )
      };
      let chalk_settings = {
          tool: "chalk",
          opacity: 1.0,
          width: 3,
          color: "black",
          undo: false,
          fill: false,
          loop: false,
          shape: 'curve',
          stroke: shared.createStroke( shared.STROKE_STYLES.CHALK )
      };
      let highlighter_settings = {
          tool: "highlighter",
          opacity: 0.2,
          width: 24,
          color: "yellow",
          undo: true,
          fill: false,
          loop: false,
          shape: 'curve',
          stroke: shared.createStroke( shared.STROKE_STYLES.HIGHLIGHTER )
      };
      let selection_rectangle_settings = {
          tool: "selection-rectangle",
          opacity: 0.3,
          width: 2,
          color: "#0078d7", // Selection blue
          undo: false,
          fill: true,  // Fill to select everything inside
          loop: true,
          shape: 'rectangle',
          stroke: shared.createStroke( shared.STROKE_STYLES.PEN )
      };
      let selection_lasso_settings = {
          tool: "selection-lasso",
          opacity: 0.3,
          width: 2,
          color: "#0078d7",
          undo: false,
          fill: true,  // Fill to select everything inside
          loop: true,
          shape: 'curve',
          stroke: shared.createStroke( shared.STROKE_STYLES.PEN )
      };
      let selection_stroke_settings = {
          tool: "selection-stroke",
          opacity: 0.3,
          width: 2,
          color: "#0078d7",
          undo: false,
          fill: false,
          loop: false,
          shape: 'curve',
          stroke: shared.createStroke( shared.STROKE_STYLES.PEN )
      };

      let draw_settings = chalk_settings;

      function createStroke ( settings ) {
          const result = shared.createStroke( settings.stroke );
          result[shared.ELEMENT.WIDTH] = settings.width;
          result[shared.ELEMENT.COLOR] = settings.color;
          result[shared.ELEMENT.OPACITY] = settings.opacity;
          result[shared.ELEMENT.LAYER] = Number(activeLayer);
          return result;
      };

      function updateKnobs () {
          document.getElementById('chalk-tool').style.backgroundColor = chalk_settings.color;
          document.getElementById('pen-tool').style.backgroundColor = pen_settings.color;
          document.getElementById('highlighter-tool').style.backgroundColor = highlighter_settings.color;

          widthSelector.style.setProperty('--thumb-size', draw_settings.width);
          // widthSelector.style.setProperty('--thumb-color', draw_settings.color);
          widthSelector.value = draw_settings.width;
          opacitySelector.style.setProperty('--thumb-opacity', draw_settings.opacity);
          // opacitySelector.style.setProperty('--thumb-color', draw_settings.color);
          opacitySelector.value =  draw_settings.opacity * 128;
          if ( draw_settings.undo ) {
              document.getElementById('timer-btn').classList.add('active');
          } else {
              document.getElementById('timer-btn').classList.remove('active');
          }
          if ( draw_settings.fill ) { 
              document.getElementById('fill-btn').innerHTML = '‚ñ†';
          } else {
              document.getElementById('fill-btn').innerHTML = '‚ñ°';
          }
          if ( draw_settings.loop ) { 
              document.getElementById('loop-btn').innerHTML = 'üîÑ';
          } else {
              document.getElementById('loop-btn').innerHTML = '‚§¥';
          }
          update_shape_buttons();
      }
      
      // updateKnobs();

      function switch_settings ( the_settings ) {
          draw_settings = the_settings;
          updateKnobs();
          
          // Hide/show selection action buttons
          const isSelectionTool = (draw_settings.tool === 'selection-rectangle' || 
                                    draw_settings.tool === 'selection-lasso' || 
                                    draw_settings.tool === 'selection-stroke');
          selectionActionsSidebar.style.display = isSelectionTool ? 'flex' : 'none';
          selectionCopySidebar.style.display = isSelectionTool ? 'flex' : 'none';
          selectionMoveSidebar.style.display = isSelectionTool ? 'flex' : 'none';
          selectionLayerSidebar.style.display = isSelectionTool ? 'flex' : 'none';
          selectionDeselectSidebar.style.display = isSelectionTool ? 'flex' : 'none';
          
          switch (draw_settings.tool) {
          case 'pen':
          case 'chalk':
          case 'highlighter':
              colorSelectionDiv.style.display = 'flex';
              widthSelectionDiv.style.display = 'flex';
              opacitySelectionDiv .style.display = 'flex';
              timerToggleDiv.style.display = 'flex';
              fillToggleDiv.style.display = 'flex';
              loopToggleDiv.style.display = 'flex';
              curveSelectionDiv.style.display = 'flex';
              rectangleSelectionDiv.style.display = 'flex';
              horizontalSelectionDiv.style.display = 'flex';
              verticalSelectionDiv.style.display = 'flex';
              lineSelectionDiv.style.display = 'flex';
              break;
          case 'selection-rectangle':
          case 'selection-lasso':
              colorSelectionDiv.style.display = 'none';
              widthSelectionDiv.style.display = 'none';
              opacitySelectionDiv.style.display = 'none';
              timerToggleDiv.style.display = 'none';
              fillToggleDiv.style.display = 'none';
              loopToggleDiv.style.display = 'none';
              curveSelectionDiv.style.display = 'none';
              rectangleSelectionDiv.style.display = 'none';
              horizontalSelectionDiv.style.display = 'none';
              verticalSelectionDiv.style.display = 'none';
              lineSelectionDiv.style.display = 'none';
              break;
          case 'selection-stroke':
              colorSelectionDiv.style.display = 'none';
              widthSelectionDiv.style.display = 'flex'; // For stroke width
              opacitySelectionDiv.style.display = 'none';
              timerToggleDiv.style.display = 'none';
              fillToggleDiv.style.display = 'none';
              loopToggleDiv.style.display = 'none';
              curveSelectionDiv.style.display = 'none';
              rectangleSelectionDiv.style.display = 'none';
              horizontalSelectionDiv.style.display = 'none';
              verticalSelectionDiv.style.display = 'none';
              lineSelectionDiv.style.display = 'none';
              break;
          case 'eraser':
              colorSelectionDiv.style.display = 'none';
              widthSelectionDiv.style.display = 'flex';
              opacitySelectionDiv .style.display = 'none';
              timerToggleDiv.style.display = 'none';
              fillToggleDiv.style.display = 'none';
              loopToggleDiv.style.display = 'none';
              curveSelectionDiv.style.display = 'none';
              rectangleSelectionDiv.style.display = 'none';
              horizontalSelectionDiv.style.display = 'none';
              verticalSelectionDiv.style.display = 'none';
              lineSelectionDiv.style.display = 'none';
              break;
          }
      };

      // Globals for board state
      let ws = null;
      let boardId = null;
      let passwd = null; // needed for edits
      let storedCredential = null; // Store credential from URL for creating new boards
      let clientId = shared.generateUuid(); // Unique client identifier
      let currentPageUuid = null;
      let pageNr = 1;
      let totalPages = 1;
      let connectionEstablished = false;
      
      // Reconnection with exponential backoff
      let reconnectAttempts = 0;
      let reconnectTimer = null;
      let maxReconnectDelay = 30000; // Maximum 30 seconds
      let initialReconnectDelay = 1000; // Start with 1 second
      
      // Page cache using IndexedDB (larger storage, cleared on close)
      const PAGE_CACHE_DB_NAME = 'whiteboard_cache';
      const PAGE_CACHE_STORE_NAME = 'pages';
      let cacheDB = null;
      
      // Initialize IndexedDB for page caching
      async function initPageCacheDB() {
          return new Promise((resolve, reject) => {
              const request = indexedDB.open(PAGE_CACHE_DB_NAME, 1);
              
              request.onerror = () => {
                  console.error('Failed to open cache database');
                  resolve(null); // Continue without cache
              };
              
              request.onsuccess = (event) => {
                  cacheDB = event.target.result;
                  debugLog('Cache database initialized');
                  resolve(cacheDB);
              };
              
              request.onupgradeneeded = (event) => {
                  const db = event.target.result;
                  if (!db.objectStoreNames.contains(PAGE_CACHE_STORE_NAME)) {
                      // Create object store with pageUuid as key
                      const objectStore = db.createObjectStore(PAGE_CACHE_STORE_NAME, { keyPath: 'uuid' });
                      objectStore.createIndex('timestamp', 'timestamp', { unique: false });
                      objectStore.createIndex('boardId', 'boardId', { unique: false });
                  }
              };
          });
      }
      
      // Clear cache database when window closes
      window.addEventListener('beforeunload', () => {
          if (cacheDB) {
              cacheDB.close();
          }
          // Delete the database to clear all cached data
          indexedDB.deleteDatabase(PAGE_CACHE_DB_NAME);
      });
      
      // Two-canvas optimization: cache static background
      let backgroundCanvas = null;
      let backgroundCtx = null;
      let backgroundValid = false;
      let backgroundRenderedUpTo = 0; // Last present index rendered to background
      
      // Drawing state
      let isDrawing = false;
      let isErasing = false;
      let isSelecting = false;
      let currentPath = [];
      let currentStroke = null;
      let selectionStroke = null;
      let selectedElements = [];
      let isDraggingSelection = false;
      let selectionStartPoint = null;
      let selectionOriginalPoint = null; // Track original position for drag
      let isDeselectMode = false; // Toggle for removing from selection
      
      // Paste mode state
      let pasteMode = false;
      let pastedElements = []; // Array of {uuid, originalElement, transform}
      let pasteBounds = null;
      let pasteTransform = null; // Current transform being applied to paste group
      let isDraggingPaste = false;
      let isResizingPaste = false;
      let resizeHandle = null; // Which handle is being dragged
      let dragStartPoint = null;
      let initialTransform = null;
      
      // Paste mode control triangle state
      let initialTriangle = null; // { center, north, east, radius }
      let controlTriangle = null; // { center, north, east, radius }
      let draggedHandle = null; // 'center', 'north', 'east', 'circle', or null
      let transformMode = 'translate'; // 'translate', 'rotate', 'scale', 'affine'
      
      // Compute affine transformation from control triangle positions
      function affineFromControls() {
          const a = ( controlTriangle.east.x - controlTriangle.center.x ) / initialTriangle.radius;
          const c = - ( controlTriangle.north.x - controlTriangle.center.x ) / initialTriangle.radius;
          const b = ( controlTriangle.east.y - controlTriangle.center.y ) / initialTriangle.radius;
          const d = - ( controlTriangle.north.y - controlTriangle.center.y ) / initialTriangle.radius;
          const e = controlTriangle.center.x - a * initialTriangle.center.x - c * initialTriangle.center.y;
          const f = controlTriangle.center.y - b * initialTriangle.center.x - d * initialTriangle.center.y;
          return [ a, b, c, d, e, f ];

      }
      
      // Initialize control triangle from paste bounds
      function initializeControlTriangle() {
          if (!pasteBounds) return;
          
          const centerX = pasteBounds.x + pasteBounds.width / 2;
          const centerY = pasteBounds.y + pasteBounds.height / 2;
          
          // Use minimum dimension to keep handles on screen, with a minimum radius for usability
          const minRadius = 50; // Minimum radius in pixels for comfortable interaction
          const radius = Math.max(minRadius, Math.min(pasteBounds.width, pasteBounds.height) / 2);
          
          controlTriangle = {
              center: { x: centerX, y: centerY },
              north: { x: centerX, y: centerY - radius },
              east: { x: centerX + radius, y: centerY },
              radius: radius
          };
          initialTriangle = {
              center: { ...controlTriangle.center },
              north: { ...controlTriangle.north },
              east: { ...controlTriangle.east },
              radius: controlTriangle.radius
          };
      }
      
      // Check if point is near a control handle
      function getControlHandleAt(x, y) {
          if (!controlTriangle) return null;
          
          const threshold = 15 / zoomLevel; // 15 pixel hit radius
          
          const distToCenter = Math.sqrt(
              Math.pow(x - controlTriangle.center.x, 2) + 
              Math.pow(y - controlTriangle.center.y, 2)
          );
          if (distToCenter < threshold) return 'center';
          
          const distToNorth = Math.sqrt(
              Math.pow(x - controlTriangle.north.x, 2) + 
              Math.pow(y - controlTriangle.north.y, 2)
          );
          if (distToNorth < threshold) return 'north';
          
          const distToEast = Math.sqrt(
              Math.pow(x - controlTriangle.east.x, 2) + 
              Math.pow(y - controlTriangle.east.y, 2)
          );
          if (distToEast < threshold) return 'east';
          
          // Check if on circle (for uniform scale)
          const distToCircle = Math.abs(
              Math.sqrt(Math.pow(x - controlTriangle.center.x, 2) + 
                        Math.pow(y - controlTriangle.center.y, 2)) - 
              controlTriangle.radius
          );
          if (distToCircle < threshold) return 'circle';
          
          return null;
      }
      
      // Constrain north point to circle
      function constrainNorthToCircle(north) {
          const dx = north.x - controlTriangle.center.x;
          const dy = north.y - controlTriangle.center.y;
          const angle = Math.atan2(dy, dx);
          
          return {
              x: controlTriangle.center.x + controlTriangle.radius * Math.cos(angle),
              y: controlTriangle.center.y + controlTriangle.radius * Math.sin(angle)
          };
      }
      
      // Update paste transform from control triangle
      function updatePasteTransformFromControls() {
          if (!controlTriangle) return;
          
          // Compute transform from standard triangle to current triangle
          pasteTransform = affineFromControls();
          pasteBounds = calculatePasteBounds();
      }
      
      // Render control triangle overlay
      function renderControlTriangle() {
          if (!controlTriangle) return;
          
          ctx.save();
          ctx.setLineDash([]);
          ctx.lineWidth = 2 / zoomLevel;
          
          // Draw circle
          ctx.strokeStyle = '#888';
          ctx.beginPath();
          ctx.arc(
              controlTriangle.center.x, 
              controlTriangle.center.y, 
              controlTriangle.radius, 
              0, 2 * Math.PI
          );
          ctx.stroke();
          
          // Draw crosshair lines
          ctx.strokeStyle = '#666';
          ctx.lineWidth = 1 / zoomLevel;
          
          // Center to north
          ctx.beginPath();
          ctx.moveTo(controlTriangle.center.x, controlTriangle.center.y);
          ctx.lineTo(controlTriangle.north.x, controlTriangle.north.y);
          ctx.stroke();
          
          // Center to east
          ctx.beginPath();
          ctx.moveTo(controlTriangle.center.x, controlTriangle.center.y);
          ctx.lineTo(controlTriangle.east.x, controlTriangle.east.y);
          ctx.stroke();
          
          // Draw control handles
          const handleSize = 10 / zoomLevel;
          
          // Center handle (translation - blue)
          ctx.fillStyle = '#0078d7';
          ctx.strokeStyle = 'white';
          ctx.lineWidth = 2 / zoomLevel;
          ctx.beginPath();
          ctx.arc(controlTriangle.center.x, controlTriangle.center.y, handleSize/2, 0, 2 * Math.PI);
          ctx.fill();
          ctx.stroke();
          
          // North handle (rotation - brown)
          ctx.fillStyle = '#8B4513';
          ctx.beginPath();
          ctx.arc(controlTriangle.north.x, controlTriangle.north.y, handleSize/2, 0, 2 * Math.PI);
          ctx.fill();
          ctx.stroke();
          
          // East handle (affine - green)
          ctx.fillStyle = '#228B22';
          ctx.beginPath();
          ctx.arc(controlTriangle.east.x, controlTriangle.east.y, handleSize/2, 0, 2 * Math.PI);
          ctx.fill();
          ctx.stroke();
          
          ctx.restore();
      }
      
      // Clipboard for copy/paste
      let clipboard = {
        elements: [],
        sourceLayer: null,
        bounds: null
      };
      
      // Paste button
      const pasteBtn = document.getElementById('paste-btn');
      
      // Timeline state with complete hash chain
      let history = [];          // All actions in timeline
      let present = 0;           // Current position in timeline
      let hashes = [];           // Hash chain for all states
      let verifiedIndex = 0;     // Last index confirmed by server
      
      // Visual state
      let visualState = shared.createEmptyVisualState();
      
      // Zoom and pan state
      let zoomLevel = 1;
      let panX = 0;
      let panY = 0;

      // Layer state
      let activeLayer = 0;
      let visibleLayers = new Set([0, 1, 2, 3, 4, 5, 6, 7]); // All layers visible by default
      
      // Tool state
      let currentTool = 'chalk';
      let eraserRadius = 20;
      let currentColor = '#000000';
      let currentWidth = 2;
      let currentOpacity = 1.0;
      
      // DOM elements
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');
      const container = document.getElementById('canvas-container');
      const widthSelector = document.getElementById('width-selector');
      // const widthValue = document.getElementById('width-value');
      const opacitySelector = document.getElementById('opacity-selector');
      // const opacityValue = document.getElementById('opacity-value');
      const zoomLevelDisplay = document.getElementById('zoom-level');
      const pageInfo = document.getElementById('page-info');
      const errorBanner = document.getElementById('error-banner');
      const errorMessage = document.getElementById('error-message');
      const reconnectButton = document.getElementById('reconnect-button');
      const undoBtn = document.getElementById('undo-btn');
      const redoBtn = document.getElementById('redo-btn');
      // const syncStatus = document.getElementById('sync-status');

      const colorSelectionDiv = document.getElementById('color-selection');
      const widthSelectionDiv = document.getElementById('width-selection');
      const opacitySelectionDiv = document.getElementById('opacity-selection');
      const timerToggleDiv = document.getElementById('timer-toggle');
      const fillToggleDiv = document.getElementById('fill-toggle');
      const loopToggleDiv = document.getElementById('loop-toggle');
      const curveSelectionDiv = document.getElementById('curve-selection');
      const rectangleSelectionDiv = document.getElementById('rectangle-selection');
      const horizontalSelectionDiv = document.getElementById('horizontal-selection');
      const verticalSelectionDiv = document.getElementById('vertical-selection');
      const lineSelectionDiv = document.getElementById('line-selection');
      
      // Selection actions UI (sidebar)
      const selectionActionsSidebar = document.getElementById('selection-actions-sidebar');
      const selectionCopySidebar = document.getElementById('selection-copy-sidebar');
      const selectionMoveSidebar = document.getElementById('selection-move-sidebar');
      const selectionLayerSidebar = document.getElementById('selection-layer-sidebar');
      const selectionDeselectSidebar = document.getElementById('selection-deselect-sidebar');
      const cutBtn = document.getElementById('cut-btn');
      const copyBtn = document.getElementById('copy-btn');
      const moveBtn = document.getElementById('move-btn');
      const moveLayerBtn = document.getElementById('move-layer-btn');
      const deselectToggleBtn = document.getElementById('deselect-toggle-btn');

      // Simple Color Picker elements
      const colorPicker = document.getElementById('simple-color-picker');
      const closeColorPickerBtn = document.getElementById('simple-color-picker-close');
      const applyColorBtn = document.getElementById('color-picker-apply');
      const cancelColorBtn = document.getElementById('color-picker-cancel');
      const newColorPreview = document.getElementById('new-color');
      const originalColorPreview = document.getElementById('original-color');
      const hexInput = document.getElementById('hex-input');
      const colorCells = document.querySelectorAll('.color-cell');

      // Color picker state
      let currentEditingSwatch = null;
      let currentSelectedColor = '#000000';
      let originalColor = '#000000';

      // settings
      const force_stylus = true;

      // Initialize 
      async function init() {
          // Initialize IndexedDB cache first
          await initPageCacheDB();
          
          // Load stored credential from localStorage
          const savedCredential = localStorage.getItem('whiteboard_credential');
          if (savedCredential) {
              storedCredential = savedCredential;
              debugLog('Credential loaded from localStorage');
          }
          
          // Check for credential in URL and store it (overrides localStorage)
          const urlParams = new URLSearchParams(window.location.search);
          const credential = urlParams.get('credential');
          if (credential) {
              storedCredential = credential;
              localStorage.setItem('whiteboard_credential', credential);
              debugLog('Credential stored from URL and saved to localStorage');
          }
          
          // Note: loadSettings() will be called after board registration
          // when we have a valid boardId
          
          setupCanvas();
          setupWebSocket();
          setupEventListeners();
          setupColorPicker();
          setupLayerControls();
          setupSelectionControls();
          updatePasteButton(); // Initialize paste button state
          debugStylusEvents(); // Add stylus debugging
          // setupWebSocket();
      }
      
      // Set up canvas size
      function setupCanvas() {
          resizeCanvas();
          window.addEventListener('resize', resizeCanvas);
      }
      
      // Resize canvas to fit window
      function resizeCanvas() {
          canvas.width = container.clientWidth;
          canvas.height = container.clientHeight;
          
          // Resize background canvas to match
          if (!backgroundCanvas) {
              backgroundCanvas = document.createElement('canvas');
              backgroundCtx = backgroundCanvas.getContext('2d');
          }
          backgroundCanvas.width = canvas.width;
          backgroundCanvas.height = canvas.height;
          backgroundValid = false; // Invalidate on resize
          
          applyZoom();
          redrawCanvas();
      }
      
      // Apply zoom and pan transform
      function applyZoom() {
          ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset transform
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.setTransform(zoomLevel, 0, 0, zoomLevel, panX, panY);
      }
      
      // Show error message
      function showError(message) {
          errorMessage.textContent = message;
          errorBanner.style.display = 'block';
      }
      
      // Hide error message
      function hideError() {
          errorBanner.style.display = 'none';
      }
      
      function createRequestId() {
          return shared.generateUuid();
      }
      
      // Show synchronization status
      function updateSyncStatus() {
      //     if (present > verifiedIndex) {
      //         // Some actions not yet confirmed by server
      //         syncStatus.textContent = "‚ü≥";
      //         syncStatus.style.color = "#ff9800";
      //     } else {
      //         // All actions confirmed
      //         syncStatus.textContent = "‚úì";
      //         syncStatus.style.color = "#4caf50";
      //     }
      }
      
      // Calculate exponential backoff delay
      function getReconnectDelay() {
          // Calculate: min(maxDelay, initialDelay * 2^attempts)
          const delay = Math.min(
              maxReconnectDelay,
              initialReconnectDelay * Math.pow(2, reconnectAttempts)
          );
          return delay;
      }
      
      // Schedule automatic reconnection with exponential backoff
      function scheduleReconnect() {
          // Clear any existing reconnection timer
          if (reconnectTimer) {
              clearTimeout(reconnectTimer);
              reconnectTimer = null;
          }
          
          const delay = getReconnectDelay();
          const seconds = (delay / 1000).toFixed(1);
          
          debugLog(`Scheduling reconnection attempt ${reconnectAttempts + 1} in ${seconds}s`);
          showError(`Connection lost. Reconnecting in ${seconds}s... (Attempt ${reconnectAttempts + 1})`);
          
          reconnectTimer = setTimeout(() => {
              reconnectAttempts++;
              debugLog(`Attempting reconnection (attempt ${reconnectAttempts})`);
              setupWebSocket();
          }, delay);
      }
      
      // Reconnect WebSocket (manual reconnection - resets backoff)
      function reconnectWebSocket() {
          // Clear any pending automatic reconnection
          if (reconnectTimer) {
              clearTimeout(reconnectTimer);
              reconnectTimer = null;
          }
          
          // Reset reconnection attempts for manual reconnect
          reconnectAttempts = 0;
          
          if (ws) {
              ws.close();
          }
          
          debugLog('Manual reconnection initiated');
          setupWebSocket();
          hideError();
      }
      
      function setupWebSocket() {
          const urlParams = new URLSearchParams(window.location.search);
          const credential = urlParams.get('credential');
          boardId = urlParams.get('board');
          passwd = urlParams.get('passwd');

          if( boardId === '00000000-0000-0000-0000-000000000000' ) {
              debugLog( 'load most recent board.' );
              const board_data = loadMostRecentBoard();
              if ( board_data ) {
                  boardId = board_data.boardId;
                  passwd = board_data.passwd;
              } 
          } else {
              debugLog( 'not loading most recent board. current board:', boardId );
          }

          // Determine if we are creating or registering
          const isCreating = !!credential;
          const isEditing = !!passwd;
          
          // If neither board nor credential provided, show error
          if (!boardId && !isCreating) {
              showError('Please provide credentials to create a new board.');
              return; // Do not attempt to connect
          }
          
          let wsUrl;
          
          // Check if server injected a specific WebSocket URL (direct mode)
          if (typeof WHITEBOARD_WS_URL !== 'undefined' && WHITEBOARD_WS_URL !== null) {
              wsUrl = WHITEBOARD_WS_URL;
              debugLog('Using direct WebSocket URL:', wsUrl);
          } else {
              // Auto-detect mode (proxy mode)
              const hostname = window.location.hostname;
              const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
              
              // For production with nginx-proxy (no port in URL)
              wsUrl = `${protocol}//${hostname}/ws`;
              debugLog('Using auto-detected WebSocket URL:', wsUrl);
          }
          
          debugLog('Connecting to WebSocket:', wsUrl);
          
          ws = new WebSocket(wsUrl);
          connectionEstablished = false;
          
          ws.onopen = () => {
              debugLog('WebSocket connection established');
              
              // Reset reconnection attempts on successful connection
              reconnectAttempts = 0;
              if (reconnectTimer) {
                  clearTimeout(reconnectTimer);
                  reconnectTimer = null;
              }
              
              if (isCreating) {
                  // Send board creation request
                  createBoard(credential);
              } else if (boardId) {
                  // Register with existing board
                  registerBoard(boardId);
              }
          };
          
          ws.onclose = () => {
              debugLog('Disconnected from server');
              connectionEstablished = false;
              
              // Schedule automatic reconnection with exponential backoff
              scheduleReconnect();
          };
          
          ws.onerror = (error) => {
              console.error('WebSocket error:', error);
              connectionEstablished = false;
              showError('Failed to connect to server. Please check your connection.');
          };
          
          ws.onmessage = (event) => {
              try {
                  const data = shared.deserialize(event.data);
                  debugLog('Received message:', data);
                  
                  // Handle message based on type
                  switch (data.type) {
                  case shared.MESSAGES.SERVER_TO_CLIENT.BOARD_CREATED.TYPE:
                      handleBoardCreated(data);
                      break;
                  case shared.MESSAGES.SERVER_TO_CLIENT.BOARD_REGISTERED.TYPE:
                      handleBoardRegistered(data);
                      break;
                  case shared.MESSAGES.SERVER_TO_CLIENT.FULL_PAGE.TYPE:
                      handleFullPageMessage(data);
                      break;
                  case shared.MESSAGES.SERVER_TO_CLIENT.ACCEPT.TYPE:
                      handleAcceptMessage(data);
                      break;
                  case shared.MESSAGES.SERVER_TO_CLIENT.DECLINE.TYPE:
                      handleDeclineMessage(data);
                      break;
                  case shared.MESSAGES.SERVER_TO_CLIENT.REPLAY.TYPE:
                      handleReplayMessage(data);
                      break;
                  case shared.MESSAGES.SERVER_TO_CLIENT.PING.TYPE:
                      handlePingMessage(data);
                      break;
                  case "error":
                      handleErrorMessage(data);
                      break;
                  default:
                      console.error('Unknown message type:', data.type);
                  }
              } catch (error) {
                  console.error('Error processing message:', error);
                  showError(`Error processing message: ${error.message}`);
              }
          };
      }
      
      // Handle server error message
      function handleErrorMessage(data) {
          console.error(`[SERVER ERROR] ${data.message}`, data.stack);
          showError(`Server error: ${data.message}`);
      }
      
      // Create a new board with credentials
      function createBoard(credential) {
          const requestId = createRequestId();
          
          const createMessage = {
              type: shared.MESSAGES.CLIENT_TO_SERVER.CREATE_BOARD.TYPE,
              [shared.MESSAGES.CLIENT_TO_SERVER.CREATE_BOARD.PASSWORD]: credential,
              [shared.MESSAGES.CLIENT_TO_SERVER.CREATE_BOARD.CLIENT_ID]: clientId,
              [shared.MESSAGES.CLIENT_TO_SERVER.CREATE_BOARD.REQUEST_ID]: requestId
          };
          
          debugLog('Sending board creation request:', createMessage);
          ws.send(shared.serialize(createMessage));
      }
      
      // Handle board creation response
      function handleBoardCreated(data) {
          debugLog('Board created successfully');
          connectionEstablished = true;
          hideError();
          
          const requestId = data[shared.MESSAGES.SERVER_TO_CLIENT.BOARD_CREATED.REQUEST_ID];
          
          // Reset local state
          history = [];
          present = 0;
          hashes = [];
          verifiedIndex = 0;
          visualState = shared.createEmptyVisualState();
          
          boardId = data[shared.MESSAGES.SERVER_TO_CLIENT.BOARD_CREATED.BOARD_ID];
          passwd = data[shared.MESSAGES.SERVER_TO_CLIENT.BOARD_CREATED.PASSWORD];
          
          // Build the full URL with board ID and password
          const boardUrl = `${window.location.origin}${window.location.pathname}?board=${boardId}&passwd=${passwd}`;
          
          // Copy to clipboard
          navigator.clipboard.writeText(boardUrl).then(() => {
              debugLog('Board URL copied to clipboard');
          }).catch(err => {
              console.warn('Failed to copy to clipboard:', err);
          });
          
          // Show dialog with URL
          alert(`New board created!\n\nURL (copied to clipboard):\n${boardUrl}\n\nBoard ID: ${boardId}\nPassword: ${passwd}\n\nShare this URL with others to collaborate.`);
          
          // Update URL without reloading
          window.history.replaceState(null, null, `?board=${boardId}&passwd=${passwd}`);
          
          // Load settings now that we have a boardId
          loadSettings();
          updateKnobs();
      }
      
          
      // Save most recent board to localStorage
      function saveMostRecentBoard() {
          const boardData = {
              boardId: boardId,
              passwd: passwd,
              timestamp: Date.now()
          };
          
          localStorage.setItem('most_recent_board', shared.serialize(boardData));
          debugLog('Saved most recent board', boardData);
      }
      
      // Load most recent board from localStorage
      function loadMostRecentBoard() {
          try {
              const saved = localStorage.getItem('most_recent_board');
              if (!saved) return null;
              
              const boardData = shared.deserialize(saved);
              debugLog('Loaded most recent board', boardData);
              return boardData;
          } catch (err) {
              console.warn('Failed to load most recent board:', err);
              return null;
          }
      }

      // Register with an existing board
      function registerBoard(boardId) {
          const requestId = createRequestId();
          
          const registerMessage = {
              type: shared.MESSAGES.CLIENT_TO_SERVER.REGISTER_BOARD.TYPE,
              [shared.MESSAGES.CLIENT_TO_SERVER.REGISTER_BOARD.BOARD_ID]: boardId,
              [shared.MESSAGES.CLIENT_TO_SERVER.REGISTER_BOARD.CLIENT_ID]: clientId,
              [shared.MESSAGES.CLIENT_TO_SERVER.REGISTER_BOARD.REQUEST_ID]: requestId
          };
          
          debugLog('Sending board registration:', registerMessage);
          ws.send(shared.serialize(registerMessage));
      }
      
      // Handle board registration response
      function handleBoardRegistered(data) {
          debugLog('Board registered successfully');
          connectionEstablished = true;
          hideError();
          
          const requestId = data[shared.MESSAGES.SERVER_TO_CLIENT.BOARD_REGISTERED.REQUEST_ID];
          
          // Reset local state
          history = [];
          present = 0;
          hashes = [];
          verifiedIndex = 0;
          visualState = shared.createEmptyVisualState();
          
          // Update board ID and URL if necessary
          boardId = data[shared.MESSAGES.SERVER_TO_CLIENT.BOARD_REGISTERED.BOARD_ID];
          const urlParams = new URLSearchParams(window.location.search);
          
          if (urlParams.get('credential')) {
              // If we created a board, update URL to use board ID instead
              window.history.replaceState(null, null, `?board=${boardId}`);
          } else if (urlParams.get('board') !== boardId) {
              // If the board ID changed for some reason, update URL
              window.history.replaceState(null, null, `?board=${boardId}`);
          }
          
          // Load settings now that we have a boardId
          loadSettings();
          updateKnobs();
          saveMostRecentBoard();
          
          // The server will send a full page message next, so we do not need
          // to request one explicitly
      }
      
      // Handle ping message from server

      // a ping between a mod-request and the accept/decline response shall be ignored
      // BUT: the response may get lost ==> we need a timeout.

      const RESPONSE_TIMEOUT = 100; // msecs
      let pending_actions = new Set();
      let pending_timer = Date.now();

      function pending_register_action ( uuid ) {
          pending_actions.add( uuid );
          pending_timer = Date.now();
          debugLog( `A total of ${pending_actions.size} actions is pending` );
      }

      function adjustVerfiedIndex ( snapshots ) {
          index = 0;
          the_index = 0;
          alt_index = 0;
          the_hash = hashes[ the_index ];
          alt_hash = snapshots[ alt_index ];
          while ( ( the_index <= verifiedIndex ) && ( alt_index < snapshots.length ) ) {
              if ( the_hash != alt_hash ) {
                  ++ the_index;
                  the_hash = hashes[ the_index ];
              } else {
                  index = the_index;
                  ++ alt_index;
                  ++ the_index;
              }
          }
          verifiedIndex = index;
      }
                                                                       
      function handlePingMessage(data) {
          if ( Date.now() > RESPONSE_TIMEOUT + pending_timer ) {
              pending_actions.clear();
          }                                                                  
          if ( pending_actions.size > 0 ) { 
            debugLog( "exit handlePingMessage because of pending actions" );
            return; 
          }

          const pingPageUuid = data[shared.MESSAGES.SERVER_TO_CLIENT.PING.UUID];
          const pingPageHash = data[shared.MESSAGES.SERVER_TO_CLIENT.PING.HASH];
          const pingPageNr = data[shared.MESSAGES.SERVER_TO_CLIENT.PING.PAGE_NR];
          const pingTotalPages = data[shared.MESSAGES.SERVER_TO_CLIENT.PING.TOTAL_PAGES];
          const pingSnapshots = data[shared.MESSAGES.SERVER_TO_CLIENT.PING.SNAPSHOTS];
          
          debugLog('Received ping', {
              serverPageUuid: pingPageUuid, 
              serverPageHash: pingPageHash, 
              serverPageNr: pingPageNr, 
              serverTotalPages: pingTotalPages,
              currentPageUuid: currentPageUuid,
              verifiedHash: hashes[ verifiedIndex ]
          });
          
          // Check if we are on the wrong page
          if (currentPageUuid !== pingPageUuid) {
              debugLog('Server indicates we should be on a different page');
              requestFullPage(pingPageUuid);
              return;
          }
          
          // stay on the last page
          if ( pageNr == totalPages && totalPages < pingTotalPages ) {
              debugLog('Server indicates the board has grown. Stay on the last page');
              requestFullPage( currentPageUuid, pingTotalPages - totalPages );
              return;
          }

         // Update page info if needed
          if (pageNr !== pingPageNr || totalPages !== pingTotalPages) {
              pageNr = pingPageNr;
              totalPages = pingTotalPages;
              updatePageInfo();
          }
          
          // Check if our hash is out of sync with server
          // Look for matching hash in our hash chain
          let matchingIndex = hashes.indexOf( pingPageHash );
          
          if (matchingIndex === -1) {
              // Server hash not found in our hash chain
              debugLog('Hash not found in our chain, requesting replay');
              adjustVerfiedIndex( pingSnapshots );
              requestReplay();
          } else if (matchingIndex !== present) {
              debugLog(`Server is at position ${matchingIndex}, we are at ${present}`);
              present = matchingIndex;
              verifiedIndex = present;
              updateVisualState();
          } else {
              // We are in sync with server
              verifiedIndex = matchingIndex;
              updateSyncStatus();
          }
      }

      // Handle accept message from server
      function handleAcceptMessage(data) {
          // Update page info
          pageNr = data[shared.MESSAGES.SERVER_TO_CLIENT.ACCEPT.CURRENT_PAGE_NR];
          totalPages = data[shared.MESSAGES.SERVER_TO_CLIENT.ACCEPT.CURRENT_TOTAL_PAGES];
          updatePageInfo();
          
          const acceptedActionIndex = data[shared.MESSAGES.SERVER_TO_CLIENT.ACCEPT.ACTION_INDEX];
          const acceptedActionUuid = data[shared.MESSAGES.SERVER_TO_CLIENT.ACCEPT.ACTION_UUID];
          const beforeHash = data[shared.MESSAGES.SERVER_TO_CLIENT.ACCEPT.BEFORE_HASH];
          const afterHash = data[shared.MESSAGES.SERVER_TO_CLIENT.ACCEPT.AFTER_HASH];

          pending_actions.delete( acceptedActionUuid );
          
                                                    
          if ( afterHash === hashes[ verifiedIndex ] ) {
              ++ verifiedIndex;
              updateSyncStatus();
              updateUndoRedoButtons();
              return;
          }

          if ( acceptedActionIndex < verifiedIndex ) {
              updateSyncStatus();
              updateUndoRedoButtons();
              return;
          }

          const actionIndex = history.findIndex(action => action.uuid === acceptedActionUuid, undefined, verifiedIndex);
          
          if ( actionIndex === -1 ) {
              // Action not found in our history - request replay
              debugLog(`Accepted action ${acceptedActionUuid} not found in our history`);
              requestReplay();
              return;
          }
          if ( actionIndex < verifiedIndex ) {
              updateSyncStatus();
              updateUndoRedoButtons();
              return;
          }
          
          if ( actionIndex === acceptedActionIndex ) {
              updateSyncStatus();
              updateUndoRedoButtons();
              verifiedIndex = actionIndex + 1;
              return;
          }

          const afterIndex = hashes.findIndex( hash => hash == afterHash, undefined, verifiedIndex );
          const beforeIndex = hashes.findIndex( hash => hash === beforeHash, undefined, verifiedIndex );

          if ( afterIndex > verifiedIndex ) {
              debugLog(`found afterIndex=${afterIndex} with verifiedIndex=${verifiedIndex}`);
              verifiedIndex = afterIndex;
              updateSyncStatus();
              updateUndoRedoButtons();
              // if ( present < verifiedIndex ) { present = verifiedIndex-1; }
              return;
          }
          if ( beforeIndex >= verifiedIndex ) {
              debugLog(`found beoreIndex=${afterIndex} with verfiedIndex=${verifiedIndex}`);
              verifiedIndex = beforeIndex;
              const [ action ] = history.splice( actionIndex, 1 );
              history.splice( verifiedIndex, 0, action );
              ++ verfiedIndex;
              hashes[ verifiedIndex ] = afterHash;
              updateSyncStatus();
              updateUndoRedoButtons();
              // if ( present < verifiedIndex ) { present = verifiedIndex-1; }
              return;              
          }

          if ( hashes[actionIndex] === beforeHash && hashes[actionIndex + 1] === afterHash) {
              verifiedIndex = actionIndex + 1;
              updateSyncStatus();
              updateUndoRedoButtons();
              if ( present < verifiedIndex ) { present = verifiedIndex; }
              return;
          }
          
          // const lastVerifiedHash = hashes[ verifiedIndex ];
          // const pastVerifiedIndex = verifiedIndex;
          // if ( beforeHash == lastVerifiedHash ) {
          //      const [ action ] = history.splice( actionIndex, 1 );
          //      history.splice( verifiedIndex, 0, action );
          //      hashes[ verifiedIndex ] = afterHash;
          //      ++ verifiedIndex;                                            
          //      updateSyncStatus();
          //      updateUndoRedoButtons();
          //      return;
          // } else {
          //     for ( let j = verifiedIndex; j < present; j++ ) {
          //         if ( beforeHash === shared.hashNext( lastVerifiedHash, history[ j ] ) ) {
          //             if ( j == actionIndex ) {
          //                 debugLog( "beforeHash should not match" );
          //             } else if ( j < actionIndex ) {
          //                 const [ action_one ] = history.splice( j, 1 );
          //                 history.splice( verifiedIndex, 0, action_one );
          //                 hashes[ verifiedIndex ] = beforeHash;
          //                 ++ verifiedIndex;
          //                 const [ action ] = history.splice( actionIndex, 1 );
          //                 history.splice( verifiedIndex, 0, action );
          //                 hashes[ verifiedIndex ] = afterHash;
          //                 ++ verifiedIndex;                      
          //             } else {
          //                 const [ action_one ] = history.splice( j, 1 );
          //                 history.splice( verifiedIndex, 0, action_one );
          //                 hashes[ verifiedIndex ] = beforeHash;
          //                 ++ verifiedIndex;
          //                 const [ action ] = history.splice( actionIndex+1, 1 );
          //                 history.splice( verifiedIndex, 0, action );
          //                 hashes[ verifiedIndex ] = afterHash;
          //                 ++ verifiedIndex;                                            
          //             }
          //             
          //             updateSyncStatus();
          //             updateUndoRedoButtons();
          //             return;
          //         }
          //     }                        
          // }
          
          // Verify our computed hashes match the server:
          if (hashes[actionIndex] !== beforeHash || hashes[actionIndex + 1] !== afterHash) {
              // Hash mismatch - action was applied at different point in history
              debugLog(`Hash mismatch for action ${acceptedActionUuid}: client=${hashes[actionIndex]}/${hashes[actionIndex+1]} vs server=${beforeHash}/${afterHash}`);
              requestReplay();
              return;
          }

          // Hashes match - update verified index
          if (verifiedIndex <= actionIndex) {
              verifiedIndex = actionIndex + 1;
          }
          
          // Update UI
          updateSyncStatus();
          updateUndoRedoButtons();
      }
      
      // Handle decline message from server
      function handleDeclineMessage(data) {
          const declinedActionUuid = data[shared.MESSAGES.SERVER_TO_CLIENT.DECLINE.ACTION_UUID];
          const reason = data[shared.MESSAGES.SERVER_TO_CLIENT.DECLINE.REASON];
          
          pending_actions.delete( declinedActionUuid );

          console.error(`Server declined action ${declinedActionUuid}: ${reason}`);
          
          // Find the declined action in our history
          const actionIndex = history.findIndex(action => action.uuid === declinedActionUuid);
          
          if (actionIndex !== -1) {
              // If the action is in our history, we need to remove it and all subsequent actions
              if (actionIndex >= verifiedIndex) {
                  // Only remove unverified actions
                  history = history.slice(0, verifiedIndex);
                  hashes = hashes.slice(0, verifiedIndex + 1);
                  present = verifiedIndex;
                  
                  // Update visual state
                  updateVisualState();
                  updateUndoRedoButtons();
              }
          }
          
          // Request replay to ensure we are in sync
          requestReplay();
      }
      
      // Handle replay message from server
      function handleReplayMessage(data) {
          const pageUuid = data[shared.MESSAGES.SERVER_TO_CLIENT.REPLAY.UUID];
          const beforeHash = data[shared.MESSAGES.SERVER_TO_CLIENT.REPLAY.BEFORE_HASH];
          const afterHash = data[shared.MESSAGES.SERVER_TO_CLIENT.REPLAY.AFTER_HASH];
          const replaySequence = data[shared.MESSAGES.SERVER_TO_CLIENT.REPLAY.SEQUENCE];
          const serverPresent = data[shared.MESSAGES.SERVER_TO_CLIENT.REPLAY.PRESENT];
          const currentHash = data[shared.MESSAGES.SERVER_TO_CLIENT.REPLAY.CURRENT_HASH];
          
          // Find index where replay should start (matching beforeHash)
          let startIndex = -1;
          for (let i = 0; i < hashes.length; i++) {
              if (hashes[i] === beforeHash) {
                  startIndex = i;
                  break;
              }
          }
          
          if (startIndex === -1) {
              // Cannot find matching hash - need full page refresh
              debugLog("Replay hash not found in our chain, requesting full page", {
                  beforeHash,
                  ourHashes: hashes
              });
              requestFullPage(pageUuid);
              return;
          }
          
          // Apply replay edits to the history
          if (replaySequence && replaySequence.length > 0) {
              // Remove any conflicting history after the replay point
              history = history.slice(0, startIndex);
              hashes = hashes.slice(0, startIndex + 1);
              
              // Add the replayed actions to history
              for (let i = 0; i < replaySequence.length; i++) {
                  const action = replaySequence[i];
                  history.push(action);
                  
                  // Calculate new hash for each action
                  const lastHash = hashes[hashes.length - 1];
                  const newHash = shared.hashNext(lastHash, action);
                  hashes.push(newHash);
              }
              
              // Verify final hash matches afterHash
              const finalHash = hashes[hashes.length - 1];
              if (finalHash !== afterHash) {
                  debugLog("Hash mismatch after replay", {
                      calculatedHash: finalHash,
                      expectedHash: afterHash
                  });
                  requestFullPage(pageUuid);
                  return;
              }
          }
          
          // Update present position
          present = serverPresent;
          
          // Update verified index to match present after replay
          verifiedIndex = present;
          
          if (hashes[present] !== currentHash) {
              debugLog("Current hash mismatch after replay", {
                  ourHash: hashes[present],
                  serverHash: currentHash
              });
              requestFullPage(pageUuid);
              return;
          }
          
          // Recompile visual state
          updateVisualState();
          
          // Update page info
          pageNr = data[shared.MESSAGES.SERVER_TO_CLIENT.REPLAY.PAGE_NR];
          totalPages = data[shared.MESSAGES.SERVER_TO_CLIENT.REPLAY.TOTAL_PAGES];
          updatePageInfo();
          
          // Update UI
          updateSyncStatus();
          updateUndoRedoButtons();
          
          // Cache verification successful - reset flag
          cacheVerificationInProgress = false;
          
          // Update cache with new state
          savePageToCache(pageUuid, {
              history: history,
              present: present,
              hash: hashes[present]
          });
          
          debugLog("Replay applied successfully", {
              replaySequenceLength: replaySequence.length,
              historyLength: history.length,
              present: present,
              verifiedIndex: verifiedIndex
          });
      }
      
      // Track if we are in a cache verification cycle to avoid infinite loops
      let cacheVerificationInProgress = false;
      let hasRestoredSavedPosition = false; // Track if we have restored saved page position
      
      // Handle full page message from server
      async function handleFullPageMessage(data) {
          const pageUuid = data[shared.MESSAGES.SERVER_TO_CLIENT.FULL_PAGE.UUID];
          
          // Check if we have this page cached (but only if not already in verification cycle)
          // const cachedPage = !cacheVerificationInProgress ? loadPageFromCache(pageUuid) : null;
          const cachedPage = await loadPageFromCache(pageUuid);
          
          if (cachedPage && cachedPage.hash === data[shared.MESSAGES.SERVER_TO_CLIENT.FULL_PAGE.HASH]) {
              // We have valid cached data - use it and request only updates via replay
              debugLog('Using cached page data, requesting replay for updates');
              cacheVerificationInProgress = true; // Mark that we are in verification
              
              currentPageUuid = pageUuid;
              history = cachedPage.history;
              present = cachedPage.present;
              hashes = [ shared.hashAny( currentPageUuid ) ];
              for ( let i = 0; i < history.length; ++ i ) {
                  hashes.push( shared.hashNext( hashes[ i ], history[ i ] ) );
              }
              
              verifiedIndex = present;
              
              // Update page info
              pageNr = data[shared.MESSAGES.SERVER_TO_CLIENT.FULL_PAGE.PAGE_NR];
              totalPages = data[shared.MESSAGES.SERVER_TO_CLIENT.FULL_PAGE.TOTAL_PAGES];
              updatePageInfo();
              
              // Recompile visual state
              updateVisualState();
              updateSyncStatus();
              updateUndoRedoButtons();
              
              // Request replay to get any updates since we last visited
              requestReplay();
          } else {
              // No cache or hash mismatch - use full page data
              debugLog('No cache available or hash mismatch, using full page data');
              cacheVerificationInProgress = false; // Reset flag
              
              currentPageUuid = pageUuid;
              history = data[shared.MESSAGES.SERVER_TO_CLIENT.FULL_PAGE.HISTORY];
              present = data[shared.MESSAGES.SERVER_TO_CLIENT.FULL_PAGE.PRESENT];
              hashes = [ shared.hashAny( currentPageUuid ) ];
              for ( let i = 0; i < history.length; ++ i ) {
                  hashes.push( shared.hashNext( hashes[ i ], history[ i ] ) );
              }
              debugLog( "hashes = ", `${hashes}`);
              
              // Set verified index to present
              verifiedIndex = present;
              
              // Recompile visual state
              updateVisualState();
              
              // Update page info
              pageNr = data[shared.MESSAGES.SERVER_TO_CLIENT.FULL_PAGE.PAGE_NR];
              totalPages = data[shared.MESSAGES.SERVER_TO_CLIENT.FULL_PAGE.TOTAL_PAGES];
              updatePageInfo();
              
              // Update UI
              updateSyncStatus();
              updateUndoRedoButtons();
              
              // Save this page to cache
              savePageToCache(pageUuid, {
                  history: history,
                  present: present,
                  hash: hashes[present]
              });
          }
          
          // After loading initial page, check if we should restore saved position
          if (!hasRestoredSavedPosition && window.savedPagePosition) {
              hasRestoredSavedPosition = true;
              
              // If the saved page is different from current, navigate to it
              if (window.savedPagePosition.uuid !== currentPageUuid) {
                  debugLog('Restoring saved page position', window.savedPagePosition);
                  requestFullPage(window.savedPagePosition.uuid);
              }
          }
          
          // Save current page position to settings
          saveSettings();
      }
      
      // Request a full page from the server
      function requestFullPage(pageId, delta = 0) {
          const requestId = createRequestId();
          
          const request = {
              type: shared.MESSAGES.CLIENT_TO_SERVER.FULL_PAGE_REQUESTS.TYPE,
              [shared.MESSAGES.CLIENT_TO_SERVER.FULL_PAGE_REQUESTS.BOARD_UUID]: boardId
          };
          
          if (pageId) {
              request[shared.MESSAGES.CLIENT_TO_SERVER.FULL_PAGE_REQUESTS.PAGE_ID] = pageId;
          }
          
          request[shared.MESSAGES.CLIENT_TO_SERVER.FULL_PAGE_REQUESTS.DELTA] = delta;
          request[shared.MESSAGES.CLIENT_TO_SERVER.FULL_PAGE_REQUESTS.REQUEST_ID] = requestId;
          
          debugLog('Requesting full page', request);
          sendMessage(request);
      }
      
      // Request a replay from the server
      function requestReplay() {
          const requestId = createRequestId();
          
          const request = {
              type: shared.MESSAGES.CLIENT_TO_SERVER.REPLAY_REQUESTS.TYPE,
              [shared.MESSAGES.CLIENT_TO_SERVER.REPLAY_REQUESTS.PAGE_UUID]: currentPageUuid,
              [shared.MESSAGES.CLIENT_TO_SERVER.REPLAY_REQUESTS.PRESENT]: verifiedIndex,
              [shared.MESSAGES.CLIENT_TO_SERVER.REPLAY_REQUESTS.PRESENT_HASH]: hashes[verifiedIndex],
              [shared.MESSAGES.CLIENT_TO_SERVER.REPLAY_REQUESTS.REQUEST_ID]: requestId
          };
          
          debugLog('Requesting replay', request);
          sendMessage(request);
      }
      
      // Send a message to the server
      function sendMessage(message) {
          if (!connectionEstablished) {
              showError('Not connected to server');
              return false;
          }
          
          debugLog('Sending message', message);
          ws.send(shared.serialize(message));
          return true;
      }
      
      // Update visual state based on history up to present
      function updateVisualState() {
          // Clear selection when state changes
          clearSelection();
          
          // Create a fresh visual state
          visualState = shared.createEmptyVisualState();
          
          // Apply actions up to present
          const activeActions = history.slice(0, present);
          
          // Apply all actions to visual state
          for (const action of activeActions) {
              applyActionToVisualState(action);
          }
          
          // Invalidate background cache since state changed
          backgroundValid = false;
          
          // Redraw the canvas
          redrawCanvas();
      }
      
      function applyActionToVisualState(action) {
          if (!action) return;
          shared.commitEdit(visualState, action);
      }
      
      // Add stylus debugging function
      function debugStylusEvents() {
          canvas.addEventListener('pointerdown', logStylusEvent);
          canvas.addEventListener('pointermove', logStylusEvent);
          canvas.addEventListener('pointerup', logStylusEvent);
      }

      function logStylusEvent(event) {
          return;
          if (event.pointerType === 'pen') {
              console.log('Stylus Event:', {
                  type: event.type,
                  pointerType: event.pointerType,
                  pressure: event.pressure,
                  tiltX: event.tiltX,
                  tiltY: event.tiltY,
                  twist: event.twist,
                  isPrimary: event.isPrimary,
                  tool: currentTool
              });
          }
      }
      
      // Width selection
      function selectWidth () {
          const penRadius = widthSelector.value;
          draw_settings.width = parseInt(penRadius);
          widthSelector.style.setProperty('--thumb-size', draw_settings.width);
          saveSettings();
      }
      
      // Opacity selection
      function selectOpacity () {
          draw_settings.opacity = parseInt( opacitySelector.value ) / 128;
          opacitySelector.style.setProperty('--thumb-opacity', draw_settings.opacity);
          saveSettings();
      }
      
      // Setup Simple Color Picker
      function setupColorPicker() {
          // Setup color cell click events
          colorCells.forEach(cell => {
              cell.addEventListener('click', () => {
                  const color = cell.getAttribute('data-color');
                  selectColorInPicker(color);
              });
          });
          
          // Setup hex input
          hexInput.addEventListener('input', function() {
              let hex = this.value;
              if (hex.charAt(0) !== '#') {
                  hex = '#' + hex;
              }
              
              // Basic validation for hex format
              if (/^#([0-9A-F]{3}){1,2}$/i.test(hex)) {
                  selectColorInPicker(hex);
              }
          });
          
          // Setup buttons
          closeColorPickerBtn.addEventListener('click', closeColorPicker);
          cancelColorBtn.addEventListener('click', closeColorPicker);
          applyColorBtn.addEventListener('click', applySelectedColor);
          
          // Close picker when clicking outside
          document.addEventListener('mousedown', function(e) {
              if (colorPicker.style.display === 'block') {
                  const isClickInside = colorPicker.contains(e.target);
                  if (!isClickInside && e.target.className !== 'color-swatch') {
                      closeColorPicker();
                  }
              }
          });
      }
      
      function selectColorInPicker(color) {
          currentSelectedColor = color;
          newColorPreview.style.backgroundColor = color;
          
          // Update hex input without triggering the input event
          hexInput.value = color.toUpperCase();
      }
      
      function openColorPicker(swatch) {
          currentEditingSwatch = swatch;
          originalColor = swatch.style.backgroundColor;
          
          // Set original color preview
          originalColorPreview.style.backgroundColor = originalColor;
          
          // Set initial selected color to match the swatch
          currentSelectedColor = swatch.dataset.color;
          newColorPreview.style.backgroundColor = currentSelectedColor;
          
          // Set hex input value
          hexInput.value = currentSelectedColor;
          
          // Position the picker near the swatch
          const swatchRect = swatch.getBoundingClientRect();
          colorPicker.style.left = (swatchRect.right + 10) + 'px';
          colorPicker.style.top = swatchRect.top + 'px';
          
          // Show the picker
          colorPicker.style.display = 'block';
          
          // Make sure the picker is fully visible
          const pickerRect = colorPicker.getBoundingClientRect();
          const viewportWidth = window.innerWidth;
          const viewportHeight = window.innerHeight;
          
          // Adjust horizontal position if needed
          if (pickerRect.right > viewportWidth) {
              colorPicker.style.left = (swatchRect.left - pickerRect.width - 10) + 'px';
          }
          
          // Adjust vertical position if needed
          if (pickerRect.bottom > viewportHeight) {
              colorPicker.style.top = (viewportHeight - pickerRect.height - 10) + 'px';
          }
      }
      
      function closeColorPicker() {
          colorPicker.style.display = 'none';
          currentEditingSwatch = null;
      }
      
      function applySelectedColor() {
          if (currentEditingSwatch) {
              // Update the swatch with the new color
              currentEditingSwatch.style.backgroundColor = currentSelectedColor;
              currentEditingSwatch.dataset.color = currentSelectedColor;
              
              // If this is the active swatch, update the current tool settings
              if (currentEditingSwatch.classList.contains('active')) {
                  draw_settings.color = currentSelectedColor;
                  updateKnobs();
              }
              
              // Close the picker
              closeColorPicker();
          }
      }
      
      // Move selected elements - cut + immediate paste mode
      function moveSelectedElements() {
          if (selectedElements.length === 0) return;
          cutSelectedElements();
          enterPasteMode();
      }

      // Setup selection controls
      function setupSelectionControls() {
          // Set up action buttons
          cutBtn.addEventListener('click', cutSelectedElements);
          copyBtn.addEventListener('click', copySelectedElements);
          moveBtn.addEventListener('click', moveSelectedElements);
          pasteBtn.addEventListener('click', handlePasteClick);
          moveLayerBtn.addEventListener('click', showMoveToLayerDialog);
          
          // Deselect toggle button
          deselectToggleBtn.addEventListener('click', function() {
              isDeselectMode = !isDeselectMode;
              if (isDeselectMode) {
                  deselectToggleBtn.classList.add('active');
              } else {
                  deselectToggleBtn.classList.remove('active');
              }
          });
      }

      // Selection Functions
      function clearSelection() {
          selectedElements = [];
          redrawCanvas();
      }

      function calculateSelectionBounds() {
          if (selectedElements.length === 0) return null;
          
          let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
          
          selectedElements.forEach(uuid => {
              const element = visualState.element.get(uuid);
              if (!element) return;
              
              const bounds = bounding_box(element);
              minX = Math.min(minX, bounds[0]);
              minY = Math.min(minY, bounds[1]);
              maxX = Math.max(maxX, bounds[2]);
              maxY = Math.max(maxY, bounds[3]);
          });
          
          return {
              x: minX,
              y: minY,
              width: maxX - minX,
              height: maxY - minY
          };
      }

      function findElementsIntersectingSelection(selectionStroke) {
          let result = [];
          
          for (const [uuid, element] of visualState.element) {
              if (visualState.visible.has(uuid) && 
                  visibleLayers.has(element[shared.ELEMENT.LAYER]) &&
                  do_intersect(element, selectionStroke)) {
                  result.push(uuid);
              }
          }
          
          return result;
      }

      function isClickOnSelectedElement(x, y) {
          const point = { x, y };
          
          for (const uuid of selectedElements) {
              const element = visualState.element.get(uuid);
              if (!element) continue;
              
              const bounds = bounding_box(element);
              if (x >= bounds[0] && x <= bounds[2] && y >= bounds[1] && y <= bounds[3]) {
                  // Do a more precise check if needed
                  return true;
              }
          }
          
          return false;
      }

      function startDragSelectedElements(x, y) {
          isDraggingSelection = true;
          selectionStartPoint = { x, y };
          selectionOriginalPoint = { x, y };
      }

      function dragSelectedElements(x, y) {
          if (!isDraggingSelection || !selectionStartPoint) return;
          
          // Update selection start point for calculating final movement
          selectionStartPoint = { x, y };
          
          // TODO: Could implement real-time preview of the drag here
      }

      function finishDragSelectedElements(x, y) {
          if (!isDraggingSelection) return;
          
          // Calculate total movement from original point
          const dx = x - selectionOriginalPoint.x;
          const dy = y - selectionOriginalPoint.y;
          
          // Apply movement to all selected elements
          if (Math.abs(dx) > 5 || Math.abs(dy) > 5) {
              dragMoveSelectedElements(dx, dy);
          }
          
          isDraggingSelection = false;
          selectionStartPoint = null;
          selectionOriginalPoint = null;
      }

      function dragMoveSelectedElements(dx, dy) {
          const actions = selectedElements.map(uuid => {
              const element = visualState.element.get(uuid);
              if (!element) return null;
              
              // Create a new element with transformed points
              const newElement = JSON.parse(JSON.stringify(element));
              
              // Apply movement to points
              newElement[shared.ELEMENT.POINTS] = element[shared.ELEMENT.POINTS].map(point => {
                  return [
                      point[0] + dx,
                      point[1] + dy,
                      point[2]
                  ];
              });
              
              // Create erase action for the original
              const eraseAction = createEraseAction(uuid);
              
              // Create draw action for the modified version
              const drawUuid = shared.generateUuid();
              const drawAction = {
                  type: shared.MOD_ACTIONS.DRAW.TYPE,
                  [shared.MOD_ACTIONS.UUID]: drawUuid,
                  [shared.MOD_ACTIONS.DRAW.STROKE]: newElement
              };
              
              // Return group of erase + draw
              const modifyUuid = shared.generateUuid();
              return {
                  type: shared.MOD_ACTIONS.GROUP.TYPE,
                  [shared.MOD_ACTIONS.UUID]: modifyUuid,
                  [shared.MOD_ACTIONS.GROUP.ACTIONS]: [eraseAction, drawAction]
              };
          }).filter(action => action !== null);
          
          // Group all modifications
          const groupUuid = shared.generateUuid();
          const groupAction = {
              type: shared.MOD_ACTIONS.GROUP.TYPE,
              [shared.MOD_ACTIONS.UUID]: groupUuid,
              [shared.MOD_ACTIONS.GROUP.ACTIONS]: actions
          };
          
          // If we are in the middle of history (after undoing), truncate future actions
          if (present < history.length) {
              history = history.slice(0, present);
              hashes = hashes.slice(0, present + 1);
          }
          
          // Add to history and advance present
          history.push(groupAction);
          present++;
          
          // Calculate placeholder hash
          const placeholderHash = shared.generateUuid();
          hashes.push(placeholderHash);
          
          // Create proposal
          const proposal = {
              type: shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.TYPE,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PASSWORD]: passwd,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAGE_UUID]: currentPageUuid,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD]: groupAction,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.BEFORE_HASH]: hashes[present - 1]
          };
          
          // Update visual state and UI
          updateVisualState();
          updateUndoRedoButtons();
          updateSyncStatus();
          
          // Send to server
          pending_register_action( groupUuid );
          sendMessage(proposal);
      }

      function copySelectedElements() {
          clipboard.elements = [];
          clipboard.bounds = calculateSelectionBounds();
          clipboard.sourceLayer = activeLayer;
          
          selectedElements.forEach(uuid => {
              const element = visualState.element.get(uuid);
              if (element) {
                  // Create a deep copy of the element
                  // Note: Elements do not contain UUIDs - UUIDs are only used as Map keys and in actions
                  // The element structure only contains drawable data (type, path, points, color, etc.)
                  const elementCopy = JSON.parse(JSON.stringify(element));
                  clipboard.elements.push(elementCopy);
              }
          });
          
          // Update paste button state
          updatePasteButton();
      }

      function cutSelectedElements() {
          copySelectedElements();
          deleteSelectedElements();
          // updatePasteButton() already called by copySelectedElements()
      }

      function deleteSelectedElements() {
          if (selectedElements.length === 0) return;
          
          // Create group of erase actions
          const eraseActions = selectedElements.map(targetUuid => createEraseAction(targetUuid));
          
          const groupUuid = shared.generateUuid();
          const groupAction = {
              type: shared.MOD_ACTIONS.GROUP.TYPE,
              [shared.MOD_ACTIONS.UUID]: groupUuid,
              [shared.MOD_ACTIONS.GROUP.ACTIONS]: eraseActions
          };
          
          // If we are in the middle of history (after undoing), truncate future actions
          if (present < history.length) {
              history = history.slice(0, present);
              hashes = hashes.slice(0, present + 1);
          }
          
          // Add to history and advance present
          history.push(groupAction);
          present++;
          
          // Calculate placeholder hash
          const placeholderHash = shared.generateUuid();
          hashes.push(placeholderHash);
          
          // Create proposal
          const proposal = {
              type: shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.TYPE,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PASSWORD]: passwd,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAGE_UUID]: currentPageUuid,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD]: groupAction,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.BEFORE_HASH]: hashes[present - 1]
          };
          
          // Clear selection
          clearSelection();
          
          // Update visual state and UI
          updateVisualState();
          updateUndoRedoButtons();
          updateSyncStatus();
          
          // Send to server
          pending_register_action( groupUuid );
          sendMessage(proposal);
      }

      // Update paste button state based on clipboard
      function updatePasteButton() {
          if (pasteBtn) {
              pasteBtn.disabled = clipboard.elements.length === 0;
          }
      }

      // Handle paste button click - enter interactive paste mode
      function handlePasteClick() {
          if (!clipboard.elements.length) {
              return; // Button should be disabled, but just in case
          }
          
          // Enter paste mode
          enterPasteMode();
      }
      
      // Enter interactive paste mode
      function enterPasteMode() {
          // Create preview elements at original coordinates
          pasteMode = true;
          pastedElements = [];
          
          // Create identity transform initially (elements at original position)
          pasteTransform = shared.createIdentityTransform();
          
          // Store elements with their UUIDs
          clipboard.elements.forEach(element => {
              const uuid = shared.generateUuid();
              pastedElements.push({
                  uuid: uuid,
                  originalElement: element
              });
          });
          
          // Calculate bounds of pasted elements
          pasteBounds = calculatePasteBounds();
          
          // Initialize control triangle
          initializeControlTriangle();
          
          // Redraw to show pasted elements
          redrawCanvas();
      }
      
      // Calculate bounds of pasted elements with current transform
      function calculatePasteBounds() {
          if (pastedElements.length === 0) return null;
          
          let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
          
          pastedElements.forEach(({originalElement}) => {
              // Apply paste transform to get current bounds
              const transform = shared.compose(pasteTransform, originalElement[shared.ELEMENT.TRANSFORM]);
              const transformedPath = shared.applyTransformToPath(transform, originalElement[shared.ELEMENT.POINTS]);
              const boundaries = shared.bbox(transformedPath);
              const radius = originalElement[shared.ELEMENT.WIDTH] / 2;
              
              minX = Math.min(minX, boundaries[0] - radius);
              minY = Math.min(minY, boundaries[1] - radius);
              maxX = Math.max(maxX, boundaries[2] + radius);
              maxY = Math.max(maxY, boundaries[3] + radius);
          });
          
          return {
              x: minX,
              y: minY,
              width: maxX - minX,
              height: maxY - minY
          };
      }
      
      // Exit paste mode and commit the paste
      function commitPaste() {
          if (!pasteMode || pastedElements.length === 0) return;
          
          const actions = pastedElements.map(({uuid, originalElement}) => {
              const newElement = JSON.parse(JSON.stringify(originalElement));
              
              // Compose the paste transform with original transform
              newElement[shared.ELEMENT.TRANSFORM] = shared.compose(pasteTransform, originalElement[shared.ELEMENT.TRANSFORM]);
              
              // Set layer to current active layer
              newElement[shared.ELEMENT.LAYER] = Number(activeLayer);
              
              // Create a draw action
              return {
                  type: shared.MOD_ACTIONS.DRAW.TYPE,
                  [shared.MOD_ACTIONS.UUID]: uuid,
                  [shared.MOD_ACTIONS.DRAW.STROKE]: newElement
              };
          });
          
          // Group all paste actions
          const groupUuid = shared.generateUuid();
          const groupAction = {
              type: shared.MOD_ACTIONS.GROUP.TYPE,
              [shared.MOD_ACTIONS.UUID]: groupUuid,
              [shared.MOD_ACTIONS.GROUP.ACTIONS]: actions
          };
          
          // If we are in the middle of history (after undoing), truncate future actions
          if (present < history.length) {
              history = history.slice(0, present);
              hashes = hashes.slice(0, present + 1);
          }
          
          // Add to history and advance present
          history.push(groupAction);
          present++;
          
          // Calculate placeholder hash
          const placeholderHash = shared.generateUuid();
          hashes.push(placeholderHash);
          
          // Create proposal
          const proposal = {
              type: shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.TYPE,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PASSWORD]: passwd,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAGE_UUID]: currentPageUuid,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD]: groupAction,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.BEFORE_HASH]: hashes[present - 1]
          };
          
          // Exit paste mode
          exitPasteMode();
          
          // Update visual state and UI
          updateVisualState();
          updateUndoRedoButtons();
          updateSyncStatus();
          
          // Send to server
          pending_register_action( groupUuid );
          sendMessage(proposal);
      }
      
      // Exit paste mode without committing
      function exitPasteMode() {
          pasteMode = false;
          pastedElements = [];
          pasteBounds = null;
          pasteTransform = null;
          isDraggingPaste = false;
          isResizingPaste = false;
          resizeHandle = null;
          dragStartPoint = null;
          initialTransform = null;
          controlTriangle = null;
          draggedHandle = null;
          transformMode = 'translate';
          redrawCanvas();
      }

      function pasteElements(x, y) {
          if (!clipboard.elements.length) return;
          
          // Calculate offset to paste at cursor position
          const offsetX = x - (clipboard.bounds.x + clipboard.bounds.width/2);
          const offsetY = y - (clipboard.bounds.y + clipboard.bounds.height/2);
          
          const actions = clipboard.elements.map(element => {
              const newElement = JSON.parse(JSON.stringify(element));
              const newUuid = shared.generateUuid();
              
              // Apply offset to points
              newElement[shared.ELEMENT.POINTS] = element[shared.ELEMENT.POINTS].map(point => {
                  return [
                      point[0] + offsetX,
                      point[1] + offsetY,
                      point[2]
                  ];
              });
              
              // Set layer to current active layer
              newElement[shared.ELEMENT.LAYER] = Number(activeLayer);
              
              // Create a draw action
              return {
                  type: shared.MOD_ACTIONS.DRAW.TYPE,
                  [shared.MOD_ACTIONS.UUID]: newUuid,
                  [shared.MOD_ACTIONS.DRAW.STROKE]: newElement
              };
          });
          
          // Group all paste actions
          const groupUuid = shared.generateUuid();
          const groupAction = {
              type: shared.MOD_ACTIONS.GROUP.TYPE,
              [shared.MOD_ACTIONS.UUID]: groupUuid,
              [shared.MOD_ACTIONS.GROUP.ACTIONS]: actions
          };
          
          // If we are in the middle of history (after undoing), truncate future actions
          if (present < history.length) {
              history = history.slice(0, present);
              hashes = hashes.slice(0, present + 1);
          }
          
          // Add to history and advance present
          history.push(groupAction);
          present++;
          
          // Calculate placeholder hash
          const placeholderHash = shared.generateUuid();
          hashes.push(placeholderHash);
          
          // Create proposal
          const proposal = {
              type: shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.TYPE,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PASSWORD]: passwd,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAGE_UUID]: currentPageUuid,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD]: groupAction,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.BEFORE_HASH]: hashes[present - 1]
          };
          
          // Update visual state and UI
          updateVisualState();
          updateUndoRedoButtons();
          updateSyncStatus();
          
          // Send to server
          pending_register_action( groupUuid );
          sendMessage(proposal);
      }

      function showMoveToLayerDialog() {
          // Simple implementation - directly move to active layer
          moveSelectedElementsToLayer(activeLayer);
      }

      function moveSelectedElementsToLayer(targetLayer) {
          if (selectedElements.length === 0) return;
          
          const actions = selectedElements.map(uuid => {
              const element = visualState.element.get(uuid);
              if (!element) return null;
              
              // If already on target layer, skip
              if (element[shared.ELEMENT.LAYER] === targetLayer) return null;
              
              // Create a new element with modified layer
              const newElement = JSON.parse(JSON.stringify(element));
              newElement[shared.ELEMENT.LAYER] = Number(targetLayer);
              
              // Create erase action for the original
              const eraseAction = createEraseAction(uuid);
              
              // Create draw action for the modified version
              const drawUuid = shared.generateUuid();
              const drawAction = {
                  type: shared.MOD_ACTIONS.DRAW.TYPE,
                  [shared.MOD_ACTIONS.UUID]: drawUuid,
                  [shared.MOD_ACTIONS.DRAW.STROKE]: newElement
              };
              
              // Return group of erase + draw
              const modifyUuid = shared.generateUuid();
              return {
                  type: shared.MOD_ACTIONS.GROUP.TYPE,
                  [shared.MOD_ACTIONS.UUID]: modifyUuid,
                  [shared.MOD_ACTIONS.GROUP.ACTIONS]: [eraseAction, drawAction]
              };
          }).filter(action => action !== null);
          
          if (actions.length === 0) return;
          
          // Group all modifications
          const groupUuid = shared.generateUuid();
          const groupAction = {
              type: shared.MOD_ACTIONS.GROUP.TYPE,
              [shared.MOD_ACTIONS.UUID]: groupUuid,
              [shared.MOD_ACTIONS.GROUP.ACTIONS]: actions
          };
          
          // If we are in the middle of history (after undoing), truncate future actions
          if (present < history.length) {
              history = history.slice(0, present);
              hashes = hashes.slice(0, present + 1);
          }
          
          // Add to history and advance present
          history.push(groupAction);
          present++;
          
          // Calculate placeholder hash
          const placeholderHash = shared.generateUuid();
          hashes.push(placeholderHash);
          
          // Create proposal
          const proposal = {
              type: shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.TYPE,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PASSWORD]: passwd,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAGE_UUID]: currentPageUuid,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD]: groupAction,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.BEFORE_HASH]: hashes[present - 1]
          };
          
          // Clear selection
          clearSelection();
          
          // Update visual state and UI
          updateVisualState();
          updateUndoRedoButtons();
          updateSyncStatus();
          
          // Send to server
          pending_register_action( groupUuid );
          sendMessage(proposal);
      }

      // Set up event listeners
      function setupEventListeners() {
          // Reconnect button
          reconnectButton.addEventListener('click', reconnectWebSocket);
          
          // Tool selection
          document.getElementById('chalk-tool').addEventListener('click', () => setTool('chalk'));
          document.getElementById('pen-tool').addEventListener('click', () => setTool('pen'));
          document.getElementById('highlighter-tool').addEventListener('click', () => setTool('highlighter'));
          document.getElementById('eraser-tool').addEventListener('click', () => setTool('eraser'));
          document.getElementById('selection-rectangle-tool').addEventListener('click', () => setTool('selection-rectangle'));
          document.getElementById('selection-lasso-tool').addEventListener('click', () => setTool('selection-lasso'));
          document.getElementById('selection-stroke-tool').addEventListener('click', () => setTool('selection-stroke'));
          document.getElementById('hand-tool').addEventListener('click', () => setTool('hand'));
          
          // Color selection
          const colorSwatches = document.querySelectorAll('.color-swatch');
          colorSwatches.forEach(swatch => {
              // For normal click - select color
              swatch.addEventListener('click', function() {
                  document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('active'));
                  this.classList.add('active');
                  draw_settings.color = this.dataset.color;
                  updateKnobs();
                  saveSettings();
              });
              
              // For long press - open color picker
              let pressTimer;
              swatch.addEventListener('pointerdown', function(e) {
                  pressTimer = setTimeout(() => {
                      openColorPicker(this);
                  }, 500); // 500ms for long press
              });
              
              swatch.addEventListener('pointerup', function() {
                  clearTimeout(pressTimer);
              });
              
              swatch.addEventListener('pointerleave', function() {
                  clearTimeout(pressTimer);
              });
          });
          
          widthSelector.addEventListener('input', selectWidth);
          opacitySelector.addEventListener('input', selectOpacity);

          document.getElementById('timer-btn').addEventListener('click', () => {
              draw_settings.undo = ( draw_settings.tool != "eraser" ) && ! draw_settings.undo;
              updateKnobs();
              saveSettings();
          });
          
          document.getElementById('loop-btn').addEventListener('click', () => {
              draw_settings.loop = ( ! draw_settings.loop );
              updateKnobs();
              saveSettings();
          });
          
          document.getElementById('fill-btn').addEventListener('click', () => {
              draw_settings.fill = ( ! draw_settings.fill );
              updateKnobs();
              saveSettings();
          });
          
          document.getElementById('curve-btn').addEventListener('click', () => {
              set_shape_tool( 'curve' );
              update_shape_buttons();
              saveSettings();
          });
          
          document.getElementById('rectangle-btn').addEventListener('click', () => {
              set_shape_tool( 'rectangle' );
              update_shape_buttons();
              saveSettings();
          });
          
          document.getElementById('circle-btn').addEventListener('click', () => {
              set_shape_tool( 'circle' );
              update_shape_buttons();
              saveSettings();
          });
          
          document.getElementById('horizontal-btn').addEventListener('click', () => {
              set_shape_tool( 'horizontal' );
              update_shape_buttons();
              saveSettings();
          });
          
          document.getElementById('vertical-btn').addEventListener('click', () => {
              set_shape_tool( 'vertical' );
              update_shape_buttons();
              saveSettings();
          });
          
          document.getElementById('line-btn').addEventListener('click', () => {
              set_shape_tool( 'line' );
              update_shape_buttons();
              saveSettings();
          });
          
          // Page navigation
          document.getElementById('first-page').addEventListener('click', () => navigatePage(1-pageNr));
          document.getElementById('prev-page').addEventListener('click', () => navigatePage(-1));
          document.getElementById('next-page').addEventListener('click', () => navigatePage(1));
          document.getElementById('last-page').addEventListener('click', () => navigatePage(totalPages-pageNr));
          document.getElementById('add-page').addEventListener('click', addNewPage);
          document.getElementById('delete-page').addEventListener('click', deletePage);
          
          // Zoom controls
          document.getElementById('zoom-in').addEventListener('click', () => adjustZoom(0.1));
          document.getElementById('zoom-out').addEventListener('click', () => adjustZoom(-0.1));
          document.getElementById('reset-view').addEventListener('click', resetView);
          
          // Undo/Redo buttons
          undoBtn.addEventListener('click', handleUndo);
          redoBtn.addEventListener('click', handleRedo);
          
          // Board navigation button
          document.getElementById('board-nav-btn').addEventListener('click', openBoardNavigation);
          document.getElementById('board-nav-close').addEventListener('click', closeBoardNavigation);
          document.getElementById('copy-link-btn').addEventListener('click', copyBoardLink);
          
          // Board navigation forms
          document.getElementById('new-board-form').addEventListener('submit', handleNewBoard);
          document.getElementById('goto-board-form').addEventListener('submit', handleGotoBoard);
          
          // Close overlay when clicking outside the window
          document.getElementById('board-nav-overlay').addEventListener('click', function(e) {
              if (e.target === this) {
                  closeBoardNavigation();
              }
          });
          
          // Export PDF buttons
          document.getElementById('pdf-btn').addEventListener('click', exportPageToPDF);
          document.getElementById('pdf-board-btn').addEventListener('click', exportBoardToPDF);
          
          // Canvas events
          canvas.addEventListener('pointerdown', handlePointerDown);
          canvas.addEventListener('pointermove', handlePointerMove);
          canvas.addEventListener('pointerup', handlePointerUp);
          canvas.addEventListener('pointerleave', handlePointerUp);
          
          // Prevent default touch behaviors
          canvas.addEventListener('touchstart', e => e.preventDefault());
          canvas.addEventListener('touchmove', e => e.preventDefault());
          canvas.addEventListener('touchend', e => e.preventDefault());
          
          // Keyboard shortcuts
          document.addEventListener('keydown', handleKeyDown);
      }

      function setupLayerControls() {
          // Visibility toggle buttons
          document.querySelectorAll('.layer-visibility-btn').forEach(btn => {
              btn.addEventListener('click', function() {
                  const layer = parseInt(this.getAttribute('data-layer'));
                  
                  if (visibleLayers.has(layer)) {
                      visibleLayers.delete(layer);
                      this.classList.remove('active');
                  } else {
                      visibleLayers.add(layer);
                      this.classList.add('active');
                  }
                  
                  updateVisualState();
              });
          });
          
          // Active layer selection buttons
          document.querySelectorAll('.layer-active-btn').forEach(btn => {
              btn.addEventListener('click', function() {
                  const layer = parseInt(this.getAttribute('data-layer'));
                  
                  // Update active layer
                  activeLayer = Number(layer);
                  
                  // Update UI
                  document.querySelectorAll('.layer-active-btn').forEach(b => {
                      b.classList.remove('active');
                  });
                  this.classList.add('active');
                  
                  // Ensure this layer is visible
                  if (!visibleLayers.has(layer)) {
                      visibleLayers.add(layer);
                      document.querySelector(`.layer-visibility-btn[data-layer="${layer}"]`).classList.add('active');
                      updateVisualState();
                  }
                  
                  // Save settings
                  saveSettings();
              });
          });
      }

      
      // Show debug information
      function showDebugInfo() {
          console.log('=== DEBUG INFO ===');
          console.log('Page UUID:', currentPageUuid);
          console.log('History Length:', history.length);
          console.log('Present:', present);
          console.log('Verified Index:', verifiedIndex);
          console.log('Hashes:', hashes);
          console.log('Visual State:', visualState);
          
          alert(`Debug info in console.\nHistory: ${history.length} actions\nPresent: ${present}\nVerified: ${verifiedIndex}`);
      }
      
      // Handle keyboard shortcuts
      function handleKeyDown(e) {
          // Undo: Ctrl+Z
          if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
              e.preventDefault();
              if (!undoBtn.disabled) {
                  handleUndo();
              }
          }
          // Redo: Ctrl+Y or Ctrl+Shift+Z
          else if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
              e.preventDefault();
              if (!redoBtn.disabled) {
                  handleRedo();
              }
          }
      }
      
      // Update undo/redo button states
      function updateUndoRedoButtons() {
          // Undo is available if we have actions in history before our present position
          undoBtn.disabled = present === 0;
          
          // Redo is available if we have actions in history after our present position
          redoBtn.disabled = present >= history.length;
      }
      
      // Handle undo action
      function handleUndo() {
          if (present === 0) return;
          
          const actionToUndo = history[present - 1];
          const undoUuid = shared.generateUuid();
          
          const undoAction = {
              type: shared.MOD_ACTIONS.UNDO.TYPE,
              [shared.MOD_ACTIONS.UUID]: undoUuid,
              [shared.MOD_ACTIONS.UNDO.TARGET_ACTION]: actionToUndo[shared.MOD_ACTIONS.UUID]
          };
          
          // Create proposal
          const proposal = {
              type: shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.TYPE,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PASSWORD]: passwd,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAGE_UUID]: currentPageUuid,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD]: undoAction,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.BEFORE_HASH]: hashes[present]
          };
          
          // Apply locally first (optimistic update)
          present--;
          
          // Update visual state and UI
          updateVisualState();
          updateUndoRedoButtons();
          updateSyncStatus();
          
          // Send to server
          sendMessage(proposal);
      }
      
      // Handle redo action
      function handleRedo() {
          if (present >= history.length) return;
          
          const actionToRedo = history[present];
          const redoUuid = shared.generateUuid();
          
          const redoAction = {
              type: shared.MOD_ACTIONS.REDO.TYPE,
              [shared.MOD_ACTIONS.UUID]: redoUuid,
              [shared.MOD_ACTIONS.REDO.TARGET_ACTION]: actionToRedo[shared.MOD_ACTIONS.UUID]
          };
          
          // Create proposal
          const proposal = {
              type: shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.TYPE,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PASSWORD]: passwd,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAGE_UUID]: currentPageUuid,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD]: redoAction,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.BEFORE_HASH]: hashes[present]
          };
          
          // Apply locally first (optimistic update)
          present++;
          
          // Update visual state and UI
          updateVisualState();
          updateUndoRedoButtons();
          updateSyncStatus();
          
          // Send to server
          sendMessage(proposal);
      }
      
      // Hand tool pointer handler for panning
      const hand_pointer_handler = {
          down: () => {
              if (force_stylus && event.pointerType === "touch") return;
              
              const rect = canvas.getBoundingClientRect();
              const x = event.clientX - rect.left;
              const y = event.clientY - rect.top;
              
              isDraggingPaste = true; // Reuse flag
              dragStartPoint = { x, y, panX, panY };
          },
          move: () => {
              if (force_stylus && event.pointerType === "touch") return;
              if (!isDraggingPaste || !dragStartPoint) return;
              
              const rect = canvas.getBoundingClientRect();
              const x = event.clientX - rect.left;
              const y = event.clientY - rect.top;
              
              panX = dragStartPoint.panX + (x - dragStartPoint.x);
              panY = dragStartPoint.panY + (y - dragStartPoint.y);
              
              applyZoom();
              redrawCanvas();
          },
          up: () => {
              if (force_stylus && event.pointerType === "touch") return;
              
              isDraggingPaste = false;
              dragStartPoint = null;
              saveSettings();
          }
      };
      
      // Set current tool
      function setTool(tool) {
          // Commit paste if switching tools while in paste mode
          if (pasteMode) {
              commitPaste();
          }
          
          currentTool = tool;
          
          // Update UI - remove active from all tools
          document.getElementById('chalk-tool').classList.remove('active');
          document.getElementById('pen-tool').classList.remove('active');
          document.getElementById('highlighter-tool').classList.remove('active');
          document.getElementById('eraser-tool').classList.remove('active');
          document.getElementById('selection-rectangle-tool').classList.remove('active');
          document.getElementById('selection-lasso-tool').classList.remove('active');
          document.getElementById('selection-stroke-tool').classList.remove('active');
          document.getElementById('hand-tool').classList.remove('active');
          document.getElementById(`${tool}-tool`).classList.add('active');
          
          // Clear selection when switching away from selection tools
          const isSelectionTool = (tool === 'selection-rectangle' || tool === 'selection-lasso' || tool === 'selection-stroke');
          if (!isSelectionTool) {
              clearSelection();
              isDeselectMode = false;
              deselectToggleBtn.classList.remove('active');
          }
          
          // Update cursor
          switch (tool) {
          case 'chalk':
              canvas.style.cursor = 'none';
              switch_settings( chalk_settings );
              set_pointer_handler( shape_to_ph( chalk_settings.shape ) );
              break;
          case 'pen':
              canvas.style.cursor = 'none';
              switch_settings( pen_settings );
              set_pointer_handler( shape_to_ph( pen_settings.shape ) );
              break;
          case 'highlighter':
              canvas.style.cursor = 'none';
              switch_settings( highlighter_settings );
              set_pointer_handler( shape_to_ph( highlighter_settings.shape ) );
              break;
          case 'eraser':
              canvas.style.cursor = 'cell';
              switch_settings( eraser_settings );
              set_pointer_handler( erase_path_pointer_handler );
              break;
          case 'selection-rectangle':
              canvas.style.cursor = 'none';
              switch_settings( selection_rectangle_settings );
              set_pointer_handler( selection_pointer_handler );
              break;
          case 'selection-lasso':
              canvas.style.cursor = 'none';
              switch_settings( selection_lasso_settings );
              set_pointer_handler( selection_pointer_handler );
              break;
          case 'selection-stroke':
              canvas.style.cursor = 'none';
              switch_settings( selection_stroke_settings );
              set_pointer_handler( selection_pointer_handler );
              break;
          case 'hand':
              canvas.style.cursor = 'grab';
              set_pointer_handler( hand_pointer_handler );
              break;
          }
      }
      
      // Adjust zoom level
      function adjustZoom(delta) {
          zoomLevel = Math.max(0.5, Math.min(3, zoomLevel + delta));
          zoomLevelDisplay.textContent = `${Math.round(zoomLevel * 100)}%`;
          applyZoom();
          redrawCanvas();
          saveSettings();
      }
      
      // Reset view to default (center, 100% zoom)
      function resetView() {
          zoomLevel = 1;
          panX = 0;
          panY = 0;
          zoomLevelDisplay.textContent = '100%';
          applyZoom();
          redrawCanvas();
          saveSettings();
      }
      
      // Update page info display
      function updatePageInfo() {
          pageInfo.textContent = `Page ${pageNr} of ${totalPages}`;
      }
      
      const draw_path_pointer_handler = {
          down: () => {
              if ( force_stylus && event.pointerType === "touch" ) { return; }
              const rect = canvas.getBoundingClientRect();
              const x = (event.clientX - rect.left - panX) / zoomLevel;
              const y = (event.clientY - rect.top - panY) / zoomLevel;
              const pressure = event.pressure !== undefined ? event.pressure : 0.5;
              currentPath = [];
              const point = shared.createPoint(x, y, pressure);
              currentPath.push(point);
              isDrawing = true;
              currentStroke = createStroke( draw_settings );
              if ( draw_settings.loop ) {
                  currentStroke[shared.ELEMENT.PATH] = shared.DRAWABLE.PATH.CLOSED_PIECEWISE_LINEAR;
              } else {
                  currentStroke[shared.ELEMENT.PATH] = shared.DRAWABLE.PATH.OPEN_PIECEWISE_LINEAR;
              }
              if ( draw_settings.fill ) {
                  currentStroke[shared.ELEMENT.TYPE] = shared.DRAWABLE.TYPE.FILL;
              } else {
                  currentStroke[shared.ELEMENT.TYPE] = shared.DRAWABLE.TYPE.STROKE;
              }
              currentStroke[shared.ELEMENT.COLOR] = draw_settings.color;
              currentStroke[shared.ELEMENT.WIDTH] = draw_settings.width;
              currentStroke[shared.ELEMENT.OPACITY] = draw_settings.opacity;
              currentStroke[shared.ELEMENT.POINTS] = currentPath;
          },
          move: () => {
              if ( force_stylus && event.pointerType === "touch" ) { return; }
              if (!isDrawing) return;
              const rect = canvas.getBoundingClientRect();
              const x = (event.clientX - rect.left - panX) / zoomLevel;
              const y = (event.clientY - rect.top - panY) / zoomLevel;
              const pressure = event.pressure !== undefined ? event.pressure : 0.5;
              const point = shared.createPoint(x, y, pressure);
              currentPath.push(point);
              currentStroke[shared.ELEMENT.POINTS] = currentPath;
              redrawCanvas();
          },
          up: () => {
              if ( force_stylus && event.pointerType === "touch" ) { return; }
              if (isDrawing) {
                  isDrawing = false;
                  if (currentPath.length >= 1) {
                      const actionId = sendDrawAction(currentStroke);
                      if ( draw_settings.undo ) {
                          setTimeout( sendGroupEraseAction, 3000, [ actionId ] );
                      }
                  }
              }
              currentPath = [];
              currentStroke = null;
          }
      };

      const erase_path_pointer_handler = {
          down: () => {
              if ( force_stylus && event.pointerType === "touch" ) { return; }
              const rect = canvas.getBoundingClientRect();
              const x = (event.clientX - rect.left - panX) / zoomLevel;
              const y = (event.clientY - rect.top - panY) / zoomLevel;
              const pressure = event.pressure !== undefined ? event.pressure : 0.5;
              currentPath = [];
              const point = shared.createPoint(x, y, pressure);
              currentPath.push(point);
              isErasing = true;
              currentStroke = shared.createStroke( shared.STROKE_STYLES.PEN );
              currentStroke[shared.ELEMENT.WIDTH] = draw_settings.width;
              currentStroke[shared.ELEMENT.COLOR] = '#FF0000'; // Red for visibility during erasing
              currentStroke[shared.ELEMENT.OPACITY] = 0.3; // Transparent so we can see what is being erased
              currentStroke[shared.ELEMENT.LAYER] = activeLayer;
              currentStroke[shared.ELEMENT.POINTS] = currentPath;
          },
          move: () => {
              if ( force_stylus && event.pointerType === "touch" ) { return; }
              if (!isErasing) return;
              const rect = canvas.getBoundingClientRect();
              const x = (event.clientX - rect.left - panX) / zoomLevel;
              const y = (event.clientY - rect.top - panY) / zoomLevel;
              const pressure = event.pressure !== undefined ? event.pressure : 0.5;
              const point = shared.createPoint(x, y, pressure);
              currentPath.push(point);
              currentStroke[shared.ELEMENT.POINTS] = currentPath;
              redrawCanvas();
          },
          up: () => {
              if ( force_stylus && event.pointerType === "touch" ) { return; }
              if (isErasing) {
                  isErasing = false;
                  if (currentPath.length >= 1) {
                      const elementsToErase = findElementsIntersectingPath(currentStroke);
                      if (elementsToErase.length > 0) {
                          sendGroupEraseAction(elementsToErase);
                      } else {
                          updateVisualState();
                      }
                  }
              }
              currentPath = [];
              currentStroke = null;
          }
      };

      const selection_pointer_handler = {
          down: () => {
              if (force_stylus && event.pointerType === "touch") return;
              
              const rect = canvas.getBoundingClientRect();
              const x = (event.clientX - rect.left - panX) / zoomLevel;
              const y = (event.clientY - rect.top - panY) / zoomLevel;
              
              // If clicking on a selected element, start drag mode
              if (isClickOnSelectedElement(x, y)) {
                  startDragSelectedElements(x, y);
                  return;
              }
              
              // Start new selection
              isSelecting = true;
              currentPath = [];
              const point = shared.createPoint(x, y, 0.5);
              currentPath.push(point);
              
              // Create selection stroke based on current shape settings
              selectionStroke = createStroke(draw_settings);
              
              // Apply the current shape settings
              if (draw_settings.loop) {
                  selectionStroke[shared.ELEMENT.PATH] = shared.DRAWABLE.PATH.CLOSED_PIECEWISE_LINEAR;
              } else {
                  selectionStroke[shared.ELEMENT.PATH] = shared.DRAWABLE.PATH.OPEN_PIECEWISE_LINEAR;
              }
              
              if (draw_settings.fill) {
                  selectionStroke[shared.ELEMENT.TYPE] = shared.DRAWABLE.TYPE.FILL;
              } else {
                  selectionStroke[shared.ELEMENT.TYPE] = shared.DRAWABLE.TYPE.STROKE;
              }
              
              // For rectangle selection, initialize with 4 points
              if (draw_settings.shape === 'rectangle') {
                  selectionStroke[shared.ELEMENT.POINTS] = [point, point, point, point];
              } else {
                  selectionStroke[shared.ELEMENT.POINTS] = [point];
              }
              
              // Selection is always cumulative - no need to clear
              // (unless in deselect mode which is handled on pointer up)
              
              redrawCanvas();
          },
          
          move: () => {
              if (force_stylus && event.pointerType === "touch") return;
              
              // Handle dragging of selected elements
              if (isDraggingSelection) {
                  const rect = canvas.getBoundingClientRect();
                  const x = (event.clientX - rect.left - panX) / zoomLevel;
                  const y = (event.clientY - rect.top - panY) / zoomLevel;
                  
                  dragSelectedElements(x, y);
                  return;
              }
              
              if (!isSelecting) return;
              
              const rect = canvas.getBoundingClientRect();
              const x = (event.clientX - rect.left - panX) / zoomLevel;
              const y = (event.clientY - rect.top - panY) / zoomLevel;
              
              // Update selection shape based on the shape type
              if (draw_settings.shape === 'rectangle') {
                  // Rectangle selection
                  const startPoint = currentPath[0];
                  selectionStroke[shared.ELEMENT.POINTS] = [
                      shared.createPoint(startPoint[shared.POINT.X], startPoint[shared.POINT.Y], 0.5),
                      shared.createPoint(startPoint[shared.POINT.X], y, 0.5),
                      shared.createPoint(x, y, 0.5),
                      shared.createPoint(x, startPoint[shared.POINT.Y], 0.5)
                  ];
              } else if (draw_settings.shape === 'curve') {
                  // Freeform/lasso or stroke selection
                  const point = shared.createPoint(x, y, 0.5);
                  currentPath.push(point);
                  selectionStroke[shared.ELEMENT.POINTS] = currentPath;
              } else if (draw_settings.shape === 'line' || 
                         draw_settings.shape === 'horizontal' || 
                         draw_settings.shape === 'vertical') {
                  // Line-based selection
                  const startPoint = currentPath[0];
                  
                  if (draw_settings.shape === 'horizontal') {
                      selectionStroke[shared.ELEMENT.POINTS] = [
                          startPoint,
                          shared.createPoint(x, startPoint[shared.POINT.Y], 0.5)
                      ];
                  } else if (draw_settings.shape === 'vertical') {
                      selectionStroke[shared.ELEMENT.POINTS] = [
                          startPoint,
                          shared.createPoint(startPoint[shared.POINT.X], y, 0.5)
                      ];
                  } else {
                      selectionStroke[shared.ELEMENT.POINTS] = [startPoint, shared.createPoint(x, y, 0.5)];
                  }
              }
              
              redrawCanvas();
          },
          
          up: () => {
              if (force_stylus && event.pointerType === "touch") return;
              
              // Finish dragging if we were dragging
              if (isDraggingSelection) {
                  const rect = canvas.getBoundingClientRect();
                  const x = (event.clientX - rect.left - panX) / zoomLevel;
                  const y = (event.clientY - rect.top - panY) / zoomLevel;
                  
                  finishDragSelectedElements(x, y);
                  return;
              }
              
              if (!isSelecting) return;
              
              isSelecting = false;
              
              // For freeform selection, close the path if loop is true
              if (draw_settings.shape === 'curve' && draw_settings.loop && currentPath.length > 2) {
                  // Add the first point again to close the path
                  currentPath.push(currentPath[0]);
                  selectionStroke[shared.ELEMENT.POINTS] = currentPath;
              }
              
              // Finalize selection
              const finalIntersecting = findElementsIntersectingSelection(selectionStroke);
              
              if (isDeselectMode) {
                  // Remove from selection
                  finalIntersecting.forEach(uuid => {
                      const index = selectedElements.indexOf(uuid);
                      if (index > -1) {
                          selectedElements.splice(index, 1);
                      }
                  });
              } else {
                  // Add to selection (cumulative)
                  finalIntersecting.forEach(uuid => {
                      if (!selectedElements.includes(uuid)) {
                          selectedElements.push(uuid);
                      }
                  });
              }
              
              // Clear temporary selection stroke
              selectionStroke = null;
              currentPath = [];
              
              redrawCanvas();
          }
      };

      let A = [ 0, 0, 0, 0 ];
      let B = [ 0, 0, 0, 0 ];
      
      function bbox_path ( A, B ) {
          const xmin = Math.min( A[0], B[0] );
          const xmax = Math.max( A[0], B[0] );
          const ymin = Math.min( A[1], B[1] );
          const ymax = Math.max( A[1], B[1] );
          return [ shared.createPoint( xmin, ymax, 0.5 ),
                   shared.createPoint( xmin, ymin, 0.5 ),
                   shared.createPoint( xmax, ymin, 0.5 ),
                   shared.createPoint( xmax, ymax, 0.5 ) ];                   
      }

      function vertical_path ( A, B ) {
          return [ shared.createPoint( B[0], A[1], 0.5 ),
                   shared.createPoint( B[0], B[1], 0.5 ) ];
      }

      function horizontal_path ( A, B ) {
          return [ shared.createPoint( A[0], B[1], 0.5 ),
                   shared.createPoint( B[0], B[1], 0.5 ) ];
      }

      function straight_path ( A, B ) {
          return [ shared.createPoint( A[0], A[1], A[2] ),
                   shared.createPoint( B[0], B[1], B[2] ) ];
      }

      function circle_path ( A, B ) {
          // A is center, B is a point on the circle
          const centerX = A[0];
          const centerY = A[1];
          const radius = Math.sqrt(Math.pow(B[0] - centerX, 2) + Math.pow(B[1] - centerY, 2));
          
          // Use 72 vertices for a smooth circle (every 5 degrees)
          const numVertices = 72;
          const points = [];
          
          for (let i = 0; i < numVertices; i++) {
              const angle = (i / numVertices) * 2 * Math.PI;
              const x = centerX + radius * Math.cos(angle);
              const y = centerY + radius * Math.sin(angle);
              points.push(shared.createPoint(x, y, 0.5));
          }
          
          return points;
      }

      function draw_shape_pointer_handler ( make_path ) {
          const result = {
              down: () => {
                  if ( force_stylus && event.pointerType === "touch" ) { return; }
                  const rect = canvas.getBoundingClientRect();
                  const x = (event.clientX - rect.left - panX) / zoomLevel;
                  const y = (event.clientY - rect.top - panY) / zoomLevel;
                  const pressure = event.pressure !== undefined ? event.pressure : 0.5;
                  currentPath = [];
                  const point = shared.createPoint(x, y, pressure);
                  currentPath.push(point);
                  isDrawing = true;
                  currentStroke = createStroke( draw_settings );
                  currentStroke[shared.ELEMENT.PATH] = shared.DRAWABLE.PATH.CLOSED_PIECEWISE_LINEAR;
                  if ( draw_settings.fill ) {
                      currentStroke[shared.ELEMENT.TYPE] = shared.DRAWABLE.TYPE.FILL;
                  } else {
                      currentStroke[shared.ELEMENT.TYPE] = shared.DRAWABLE.TYPE.STROKE;
                  }
                  currentStroke[shared.ELEMENT.COLOR] = draw_settings.color;
                  currentStroke[shared.ELEMENT.WIDTH] = draw_settings.width;
                  currentStroke[shared.ELEMENT.OPACITY] = draw_settings.opacity;
                  currentStroke[shared.ELEMENT.POINTS] = [ point, point, point, point ];
                  A = point;
              },
              move: () => {
                  if ( force_stylus && event.pointerType === "touch" ) { return; }
                  if (!isDrawing) return;
                  const rect = canvas.getBoundingClientRect();
                  const x = (event.clientX - rect.left - panX) / zoomLevel;
                  const y = (event.clientY - rect.top - panY) / zoomLevel;
                  const pressure = event.pressure !== undefined ? event.pressure : 0.5;
                  const point = shared.createPoint(x, y, pressure);
                  B = point;
                  currentPath = make_path( A, B );
                  currentStroke[shared.ELEMENT.POINTS] = currentPath;
                  redrawCanvas();
              },
              up: () => {
                  if ( force_stylus && event.pointerType === "touch" ) { return; }
                  if (isDrawing) {
                      isDrawing = false;
                      if (currentPath.length >= 1) {
                          const actionId = sendDrawAction(currentStroke);
                          if ( draw_settings.undo ) {
                              setTimeout( sendGroupEraseAction, 3000, [ actionId ] );
                          }
                      }
                  }
                  currentPath = [];
                  currentStroke = null;
              }
          };
          return result;
      }

      const draw_rectangle_pointer_handler = draw_shape_pointer_handler( bbox_path );
      const draw_circle_pointer_handler = draw_shape_pointer_handler( circle_path );
      const draw_horizontal_pointer_handler = draw_shape_pointer_handler( horizontal_path );
      const draw_vertical_pointer_handler = draw_shape_pointer_handler( vertical_path );
      const draw_line_pointer_handler = draw_shape_pointer_handler( straight_path );

      // Paste mode pointer handler with affine controls
      const paste_pointer_handler = {
          down: () => {
              if (force_stylus && event.pointerType === "touch") return;
              
              const rect = canvas.getBoundingClientRect();
              const x = (event.clientX - rect.left - panX) / zoomLevel;
              const y = (event.clientY - rect.top - panY) / zoomLevel;
              
              // Initialize control triangle if not yet done
              if (!controlTriangle) {
                  initializeControlTriangle();
              }
              
              // Check if clicking on a control handle
              draggedHandle = getControlHandleAt(x, y);
              
              if (draggedHandle) {
                  isDraggingPaste = true;
                  dragStartPoint = { x, y };
                  initialTransform = [...pasteTransform];
                  
                  // Store initial triangle state for constrained operations
                  if (draggedHandle === 'north' || draggedHandle === 'circle') {
                      // Store angle for rotation
                      const dx = controlTriangle.north.x - controlTriangle.center.x;
                      const dy = controlTriangle.north.y - controlTriangle.center.y;
                      dragStartPoint.initialAngle = Math.atan2(dy, dx);
                  }
              } else if (pasteBounds && 
                         x >= pasteBounds.x && x <= pasteBounds.x + pasteBounds.width &&
                         y >= pasteBounds.y && y <= pasteBounds.y + pasteBounds.height) {
                  // Click inside bounds but not on handle - start translation
                  isDraggingPaste = true;
                  draggedHandle = 'center';
                  dragStartPoint = { x, y };
                  initialTransform = [...pasteTransform];
              } else {
                  // Click outside - commit paste
                  commitPaste();
              }
          },
          
          move: () => {
              if (force_stylus && event.pointerType === "touch") return;
              
              if (!isDraggingPaste || !dragStartPoint || !draggedHandle) return;
              
              const rect = canvas.getBoundingClientRect();
              const x = (event.clientX - rect.left - panX) / zoomLevel;
              const y = (event.clientY - rect.top - panY) / zoomLevel;
              
              const dx = x - dragStartPoint.x;
              const dy = y - dragStartPoint.y;
              
              if (draggedHandle === 'center') {
                  // Translation: move center point
                  controlTriangle.center.x += dx;
                  controlTriangle.center.y += dy;
                  controlTriangle.north.x += dx;
                  controlTriangle.north.y += dy;
                  controlTriangle.east.x += dx;
                  controlTriangle.east.y += dy;
                  
                  dragStartPoint = { x, y };
                  
              } else if (draggedHandle === 'north') {
                  // Rotation: constrain north to circle
                  const newNorth = constrainNorthToCircle({ x, y });

                  const v = { x: newNorth.x - controlTriangle.center.x, y: newNorth.y - controlTriangle.center.y };
                  const u = { x: controlTriangle.north.x - controlTriangle.center.x, y: controlTriangle.north.y - controlTriangle.center.y };
                  const c = ( v.x * u.x + v.y * u.y ) / ( u.x * u.x + u.y * u.y );
                  const s = ( v.x * u.y - v.y * u.x ) / ( u.x * u.x + u.y * u.y );
        
                  controlTriangle.north = newNorth;
                  
                  const w = { x: controlTriangle.east.x - controlTriangle.center.x, y: controlTriangle.east.y - controlTriangle.center.y };
                  const new_w = { x: c * w.x + s * w.y, y : -s * w.x + c *w.y };
                  controlTriangle.east = { x: controlTriangle.center.x + new_w.x, y: controlTriangle.center.y + new_w.y };

              } else if (draggedHandle === 'circle') {
                  // Uniform scale: adjust radius
                  const newRadius = Math.sqrt(
                      Math.pow(x - controlTriangle.center.x, 2) + 
                      Math.pow(y - controlTriangle.center.y, 2)
                  );
                  
                  const oldRadius = controlTriangle.radius;
                  const scaleFactor = newRadius / oldRadius;
                  
                  controlTriangle.radius = newRadius;
                  
                  // Scale north and east from center
                  const northDx = controlTriangle.north.x - controlTriangle.center.x;
                  const northDy = controlTriangle.north.y - controlTriangle.center.y;
                  controlTriangle.north = {
                      x: controlTriangle.center.x + northDx * scaleFactor,
                      y: controlTriangle.center.y + northDy * scaleFactor
                  };
                  
                  const eastDx = controlTriangle.east.x - controlTriangle.center.x;
                  const eastDy = controlTriangle.east.y - controlTriangle.center.y;
                  controlTriangle.east = {
                      x: controlTriangle.center.x + eastDx * scaleFactor,
                      y: controlTriangle.center.y + eastDy * scaleFactor
                  };
                  
              } else if (draggedHandle === 'east') {
                  // General affine: east can move freely
                  controlTriangle.east = { x, y };
              }
              
              // Update paste transform from new triangle
              updatePasteTransformFromControls();
              
              // Redraw
              redrawCanvas();
          },
          
          up: () => {
              if (force_stylus && event.pointerType === "touch") return;
              
              isDraggingPaste = false;
              draggedHandle = null;
              dragStartPoint = null;
          }
      };

      let pointer_handler = draw_path_pointer_handler;

      function set_pointer_handler ( ph ) {
          pointer_handler = ph;
      };


      function handlePointerDown(event) {
          // Override with paste handler if in paste mode
          if (pasteMode) {
              paste_pointer_handler.down();
          } else {
              pointer_handler.down();
          }
      }
      
      function handlePointerMove(event) {
          // Override with paste handler if in paste mode
          if (pasteMode) {
              paste_pointer_handler.move();
          } else {
              pointer_handler.move();
          }
      }

      function handlePointerUp() {
          // Override with paste handler if in paste mode
          if (pasteMode) {
              paste_pointer_handler.up();
          } else {
              pointer_handler.up();
          }
      }

      function update_shape_buttons () {
          switch ( draw_settings.shape ) {
          case 'curve':
              document.getElementById('curve-btn').classList.add('active');
              document.getElementById('rectangle-btn').classList.remove('active');
              document.getElementById('circle-btn').classList.remove('active');
              document.getElementById('horizontal-btn').classList.remove('active');
              document.getElementById('vertical-btn').classList.remove('active');
              document.getElementById('line-btn').classList.remove('active');
              break;
          case 'rectangle':
              document.getElementById('curve-btn').classList.remove('active');
              document.getElementById('rectangle-btn').classList.add('active');
              document.getElementById('circle-btn').classList.remove('active');
              document.getElementById('horizontal-btn').classList.remove('active');
              document.getElementById('vertical-btn').classList.remove('active');
              document.getElementById('line-btn').classList.remove('active');
              break;
          case 'circle':
              document.getElementById('curve-btn').classList.remove('active');
              document.getElementById('rectangle-btn').classList.remove('active');
              document.getElementById('circle-btn').classList.add('active');
              document.getElementById('horizontal-btn').classList.remove('active');
              document.getElementById('vertical-btn').classList.remove('active');
              document.getElementById('line-btn').classList.remove('active');
              break;
          case 'horizontal':
              document.getElementById('curve-btn').classList.remove('active');
              document.getElementById('rectangle-btn').classList.remove('active');
              document.getElementById('circle-btn').classList.remove('active');
              document.getElementById('horizontal-btn').classList.add('active');
              document.getElementById('vertical-btn').classList.remove('active');
              document.getElementById('line-btn').classList.remove('active');
              break;
          case 'vertical':
              document.getElementById('curve-btn').classList.remove('active');
              document.getElementById('rectangle-btn').classList.remove('active');
              document.getElementById('circle-btn').classList.remove('active');
              document.getElementById('horizontal-btn').classList.remove('active');
              document.getElementById('vertical-btn').classList.add('active');
              document.getElementById('line-btn').classList.remove('active');
              break;
          case 'line':
              document.getElementById('curve-btn').classList.remove('active');
              document.getElementById('rectangle-btn').classList.remove('active');
              document.getElementById('circle-btn').classList.remove('active');
              document.getElementById('horizontal-btn').classList.remove('active');
              document.getElementById('vertical-btn').classList.remove('active');
              document.getElementById('line-btn').classList.add('active');
              break;
          }
      }

      function shape_to_ph ( shape ) {
          const isSelectionTool = (currentTool === 'selection-rectangle' || 
                                    currentTool === 'selection-lasso' || 
                                    currentTool === 'selection-stroke');
          
          switch ( shape ) {
          case 'curve':
              return isSelectionTool ? selection_pointer_handler : draw_path_pointer_handler;
          case 'rectangle':
              return isSelectionTool ? selection_pointer_handler : draw_rectangle_pointer_handler;
          case 'circle':
              return isSelectionTool ? selection_pointer_handler : draw_circle_pointer_handler;
          case 'horizontal':
              return isSelectionTool ? selection_pointer_handler : draw_horizontal_pointer_handler;
          case 'vertical':
              return isSelectionTool ? selection_pointer_handler : draw_vertical_pointer_handler;
          case 'line':
              return isSelectionTool ? selection_pointer_handler : draw_line_pointer_handler;
          }
      }

      function set_shape_tool ( shape ) {
          draw_settings.shape = shape;
          set_pointer_handler( shape_to_ph( draw_settings.shape ) );
          update_shape_buttons();
      }

      
      // Find elements that intersect with a complete eraser path
      function findElementsIntersectingPath(eraserStroke) {
          let result = [];
          for ( const [ uuid, hay ] of visualState.element ) {
              if ( visualState.visible.has( uuid ) 
                   &&
                   do_intersect( hay, eraserStroke ) ) {
                  result.push( uuid );
              }
          }
          console.log("erasing:", serialize( result ) );
          return result;
      }
      
      // Send a draw action to the server
      function sendDrawAction(stroke) {
          const actionUuid = shared.generateUuid();
          
          const drawAction = {
              type: shared.MOD_ACTIONS.DRAW.TYPE,
              [shared.MOD_ACTIONS.UUID]: actionUuid,
              [shared.MOD_ACTIONS.DRAW.STROKE]: stroke
          };
          
          // If we are in the middle of history (after undoing), truncate future actions
          if (present < history.length) {
              history = history.slice(0, present);
              hashes = hashes.slice(0, present + 1);
          }
          
          // Add to history and advance present
          history.push(drawAction);
          present++;
          
          // Compute hash based on previous hash and current action
          const newHash = shared.hashNext(hashes[present - 1], drawAction);
          hashes.push(newHash);
          
          // Create proposal
          const proposal = {
              type: shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.TYPE,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PASSWORD]: passwd,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAGE_UUID]: currentPageUuid,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD]: drawAction,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.BEFORE_HASH]: hashes[present - 1]
          };
          
          // Update visual state
          updateVisualState();
          
          // Update UI
          updateUndoRedoButtons();
          updateSyncStatus();
          
          // Send to server
          pending_register_action( actionUuid );
          sendMessage(proposal);
          return actionUuid;
      }
      
      // Create a single erase action for a target
      function createEraseAction(targetUuid) {
          const actionUuid = shared.generateUuid();
          return {
              type: shared.MOD_ACTIONS.ERASE.TYPE,
              [shared.MOD_ACTIONS.UUID]: actionUuid,
              [shared.MOD_ACTIONS.ERASE.TARGET_ACTION]: targetUuid
          };
      }
      
      // Send a group of erase actions as a single group action
      function sendGroupEraseAction(targetUuids) {
          if (targetUuids.length === 0) return;
          
          const groupUuid = shared.generateUuid();
          
          // Create individual erase actions for each target
          const eraseActions = targetUuids.map(targetUuid => createEraseAction(targetUuid));
          
          // Create a group action containing all erase actions
          const groupAction = {
              type: shared.MOD_ACTIONS.GROUP.TYPE,
              [shared.MOD_ACTIONS.UUID]: groupUuid,
              [shared.MOD_ACTIONS.GROUP.ACTIONS]: eraseActions
          };
          
          // If we are in the middle of history (after undoing), truncate future actions
          if (present < history.length) {
              history = history.slice(0, present);
              hashes = hashes.slice(0, present + 1);
          }
          
          // Add to history and advance present
          history.push(groupAction);
          present++;
          
          // Compute hash based on previous hash and current action
          const newHash = shared.hashNext(hashes[present - 1], groupAction);
          hashes.push(newHash);
          
          // Create proposal
          const proposal = {
              type: shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.TYPE,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PASSWORD]: passwd,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAGE_UUID]: currentPageUuid,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD]: groupAction,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.BEFORE_HASH]: hashes[present - 1]
          };
          
          // Update visual state and UI
          updateVisualState();
          updateUndoRedoButtons();
          updateSyncStatus();
          
          // Send to server
          pending_register_action( groupUuid );
          sendMessage(proposal);
      }
      
      // Add a new page
      function addNewPage() {
          const actionUuid = shared.generateUuid();
          
          const newPageAction = {
              type: shared.MOD_ACTIONS.NEW_PAGE.TYPE,
              [shared.MOD_ACTIONS.UUID]: actionUuid
          };
          
          // Create proposal
          const proposal = {
              type: shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.TYPE,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PASSWORD]: passwd,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAGE_UUID]: currentPageUuid,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD]: newPageAction,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.BEFORE_HASH]: hashes[present]
          };
          
          // Send to server - no optimistic update for page operations
          sendMessage(proposal);
      }
      
      // Delete current page
      function deletePage() {
          const actionUuid = shared.generateUuid();
          const deletePageAction = {
              type: shared.MOD_ACTIONS.DELETE_PAGE.TYPE,
              [shared.MOD_ACTIONS.UUID]: actionUuid
          };
          const proposal = {
              type: shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.TYPE,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PASSWORD]: passwd,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAGE_UUID]: currentPageUuid,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD]: deletePageAction,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.BEFORE_HASH]: hashes[present]
          };
          sendMessage(proposal);
      }
      
      // Page cache functions with LRU eviction
      function getCacheKey(pageUuid) {
          return PAGE_CACHE_PREFIX + boardId + '_' + pageUuid;
      }
      
      function getAllCachedPages() {
          const cached = [];
          for (let i = 0; i < sessionStorage.length; i++) {
              const key = sessionStorage.key(i);
              if (key && key.startsWith(PAGE_CACHE_PREFIX + boardId)) {
                  try {
                      const data = shared.deserialize(sessionStorage.getItem(key));
                      cached.push({ key, data });
                  } catch (err) {
                      // Corrupted cache entry, remove it
                      sessionStorage.removeItem(key);
                  }
              }
          }
          return cached;
      }
      
      function evictOldestCachedPage() {
          const cached = getAllCachedPages();
          if (cached.length === 0) return;
          
          // Sort by timestamp (oldest first)
          cached.sort((a, b) => a.data.timestamp - b.data.timestamp);
          
          // Remove oldest
          const oldestKey = cached[0].key;
          sessionStorage.removeItem(oldestKey);
          debugLog('Evicted oldest cached page', { key: oldestKey });
      }
      
      function clearAllPageCache() {
          const keys = [];
          for (let i = 0; i < sessionStorage.length; i++) {
              const key = sessionStorage.key(i);
              if (key && key.startsWith(PAGE_CACHE_PREFIX)) {
                  keys.push(key);
              }
          }
          keys.forEach(key => sessionStorage.removeItem(key));
          debugLog('Cleared all page cache', { count: keys.length });
      }
      
      async function savePageToCache(pageUuid, pageData) {
          if (!cacheDB) return;
          
          try {
              const transaction = cacheDB.transaction([PAGE_CACHE_STORE_NAME], 'readwrite');
              const store = transaction.objectStore(PAGE_CACHE_STORE_NAME);
              
              const cacheData = {
                  uuid: pageUuid,
                  boardId: boardId,
                  history: pageData.history,
                  present: pageData.present,
                  hash: pageData.hash,
                  timestamp: Date.now()
              };
              
              store.put(cacheData);
              
              await new Promise((resolve, reject) => {
                  transaction.oncomplete = () => {
                      debugLog('Page cached in IndexedDB', { pageUuid });
                      resolve();
                  };
                  transaction.onerror = () => {
                      console.warn('Failed to cache page:', transaction.error);
                      reject(transaction.error);
                  };
              });
          } catch (err) {
              console.warn('Failed to cache page:', err);
              // Continue without caching - not critical
          }
      }
      
      async function loadPageFromCache(pageUuid) {
          if (!cacheDB) return null;
          
          try {
              const transaction = cacheDB.transaction([PAGE_CACHE_STORE_NAME], 'readwrite');
              const store = transaction.objectStore(PAGE_CACHE_STORE_NAME);
              
              const request = store.get(pageUuid);
              
              return await new Promise((resolve, reject) => {
                  request.onsuccess = () => {
                      const cacheData = request.result;
                      if (cacheData) {
                          // Update timestamp for LRU
                          cacheData.timestamp = Date.now();
                          store.put(cacheData);
                          
                          debugLog('Page loaded from cache', { pageUuid });
                          resolve(cacheData);
                      } else {
                          resolve(null);
                      }
                  };
                  request.onerror = () => {
                      console.warn('Failed to load page from cache:', request.error);
                      resolve(null);
                  };
              });
          } catch (err) {
              console.warn('Failed to load page from cache:', err);
              return null;
          }
      }

      // Navigate to next/previous page
      function navigatePage(delta) {
          // Save current page to cache before navigating
          savePageToCache(currentPageUuid, {
              history: history,
              present: present,
              hash: hashes[present]
          });
          
          // Request full page with delta
          requestFullPage(currentPageUuid, delta);
      }
      

      // drawing / rendering
      // ===================

      // boxes
      // box = [ xmin, ymin, xmax, ymax ]

      function bounding_box ( element ) {
          const path = shared.applyTransformToPath( element[ shared.ELEMENT.TRANSFORM ], element[ shared.ELEMENT.POINTS ] );
          console.log(`path = ${path}`);
          const boundaries = shared.bbox( path );
          const radius = element[ shared.ELEMENT.WIDTH ] / 2;
          return [ boundaries[ 0 ] - radius, boundaries[ 1 ] - radius,
                   boundaries[ 2 ] + radius, boundaries[ 3 ] + radius ];
      }

      function intersect_boxes ( bbox1, bbox2 ) {
          const xmin = Math.max( bbox1[0], bbox2[0] );
          const ymin = Math.max( bbox1[1], bbox2[1] );
          const xmax = Math.min( bbox1[2], bbox2[2] );
          const ymax = Math.min( bbox1[3], bbox2[3] );
          if ( xmin < xmax && ymin < ymax ) {
              return [ xmin, ymin, xmax, ymax ];
          } else {
              return [];
          }
      }

      function do_intersect ( elem1, elem2 ) {
          if ( elem1[ shared.ELEMENT.LAYER ] != elem2[ shared.ELEMENT.LAYER ] ) {
              return false;
          }
          const bbox1 = bounding_box( elem1 );
          const bbox2 = bounding_box( elem2 );
          const bbox = intersect_boxes( bbox1, bbox2 );
          console.log("do_intersect: bbox check");
          if ( bbox.length == 0 ) {
              console.log(`bbox1 = ${bbox1}`);
              console.log(`bbox2 = ${bbox2}`);
              return false;
          }
          console.log("do_intersect: passed bbox check");
          const [ xmin, ymin, xmax, ymax ] = bbox;
          const width = xmax - xmin;
          const height = ymax - ymin;

          const offCanvas1 = document.createElement('canvas');
          offCanvas1.width = width;
          offCanvas1.height = height;
          const ctx1 = offCanvas1.getContext('2d');
          ctx1.translate( -xmin, -ymin );
          renderElement( ctx1, elem1 );

          const offCanvas2 = document.createElement('canvas');
          offCanvas2.width = width;
          offCanvas2.height = height;
          const ctx2 = offCanvas2.getContext('2d');
          ctx2.translate( -xmin, -ymin );
          renderElement( ctx2, elem2 );

          //  const offCanvas3 = document.createElement('canvas');
          //  offCanvas3.width = width;
          //  offCanvas3.height = height;
          //  const ctx3 = offCanvas3.getContext('2d');
          //  ctx3.translate( -xmin, -ymin );
          //  renderElement( ctx3, elem1 );
          //  renderElement( ctx3, elem2 );

          // Get the pixel data for both canvases
          const imageData1 = ctx1.getImageData(0, 0, width, height);
          const data1 = imageData1.data;
          
          const imageData2 = ctx2.getImageData(0, 0, width, height);
          const data2 = imageData2.data;
          
          // Compare pixel data to find overlap
          for (let i = 0; i < data1.length; i += 4) {
              const alpha1 = data1[i + 3];
              const alpha2 = data2[i + 3];
              
              // If a pixel is opaque on both canvases, they intersect
              if (alpha1 > 0 && alpha2 > 0) {
                  return true;
              }
          }
          
          // No overlapping opaque pixels were found
          return false;
      }



      function push_settings(context, element) {
          const transform = element[shared.ELEMENT.TRANSFORM];
          context.transform(
              transform[shared.TRANSFORM.A],
              transform[shared.TRANSFORM.B],
              transform[shared.TRANSFORM.C],
              transform[shared.TRANSFORM.D],
              transform[shared.TRANSFORM.E],
              transform[shared.TRANSFORM.F]
          );

          // style
          context.strokeStyle = element[shared.ELEMENT.COLOR];
          context.fillStyle = element[shared.ELEMENT.COLOR];
          context.lineWidth = element[shared.ELEMENT.WIDTH];
          context.globalAlpha = element[shared.ELEMENT.OPACITY];
          context.globalCompositeOperation = 'source-over';
          
          // Cap and join styles
          context.lineCap = shared.CAP_STYLE_STRINGS[element[shared.ELEMENT.CAP_STYLE]];
          context.lineJoin = shared.JOIN_STYLE_STRINGS[element[shared.ELEMENT.JOIN_STYLE]];
          
          // Dash pattern
          const dashPattern = element[shared.ELEMENT.DASH_PATTERN];
          if (dashPattern && dashPattern.length > 1) {
              context.setLineDash(dashPattern);
          } else {
              context.setLineDash([]);
          }
      }

      function lay_path(context, element) {
          const points = element[shared.ELEMENT.POINTS];
          context.beginPath();
          context.moveTo(points[0][shared.POINT.X], points[0][shared.POINT.Y]);
          for (let i = 1; i < points.length; i++) {
              const point = points[i];
              context.lineTo(point[shared.POINT.X], point[shared.POINT.Y]);
          }
      }

      function draw_open(context, element) {
          const points = element[shared.ELEMENT.POINTS];
          context.miterLimit = 2;
          if ( 1 == points.length ) {
              context.beginPath();
              context.moveTo(points[0][shared.POINT.X], points[0][shared.POINT.Y]);
              context.lineWidth = element[shared.ELEMENT.WIDTH] * ( 1 + element[shared.ELEMENT.SENSITIVITY] / 2 );
              context.lineTo(points[0][shared.POINT.X]+0.0001, points[0][shared.POINT.Y]);
              context.stroke();
          } else if ( 0.03 > element[shared.ELEMENT.SENSITIVITY] ) {
              context.beginPath();
              context.moveTo(points[0][shared.POINT.X], points[0][shared.POINT.Y]);
              context.lineWidth = element[shared.ELEMENT.WIDTH];
              for (let i = 1; i < points.length; i++) {
                  const point = points[i];
                  context.lineTo(point[shared.POINT.X], point[shared.POINT.Y]);
              }
              context.stroke();
          } else {
              for (let i = 1; i < points.length; i++) {
                  context.beginPath();
                  context.moveTo(points[i-1][shared.POINT.X], points[i-1][shared.POINT.Y]);
                  const point = points[i];
                  const pressure = point[shared.POINT.PRESSURE];
                  const pressureEffect = ( 1 + pressure * element[shared.ELEMENT.SENSITIVITY] );
                  context.lineWidth = element[shared.ELEMENT.WIDTH] * pressureEffect;
                  context.lineTo(point[shared.POINT.X], point[shared.POINT.Y]);
                  context.stroke();
              }
          }
      }

      function draw_closed(context, element) {
          lay_path(context, element);
          context.closePath();
          context.lineWidth = element[shared.ELEMENT.WIDTH];
          context.stroke();
      }
      
      function renderElement(context, element) {
          if (!element) return;
          context.save();
          push_settings(context, element);
          const type = element[ELEMENT.TYPE];
          const path = element[ELEMENT.PATH];
          const is_closed = ( path == DRAWABLE.PATH.CLOSED_PIECEWISE_LINEAR || path == DRAWABLE.PATH.CLOSED_BEZIER_CURVE );
          lay_path(context, element);
          if ( type == DRAWABLE.TYPE.FILL ) {
              if ( ! is_closed ) {
                  console.error('Only closed paths can be filled.',"");
                  throw new Error('Only closed paths can be filled.');
              }
              lay_path(context, element);
              context.closePath();
              context.fill()
          } else if ( type == DRAWABLE.TYPE.STROKE ) {
              if ( is_closed ) {
                  draw_closed(context, element);
              } else {
                  draw_open(context, element);
              }
          } else {
              // If we get here, it is a bug - assertion would fail in production code
              console.error('Unknown drawable type:', type);
              throw new Error('Invalid drawable type');
          }
          context.restore();
      }
      
      // Custom render function for shared.render_all_visible_elements
      function renderElementToScreen( element ) {
          if ( visibleLayers.has( element[ shared.ELEMENT.LAYER ] ) ) {
              renderElement( ctx, element );
          }
      }
      
      // Render selection highlight
      function renderSelectionHighlight() {
          if (selectedElements.length === 0) return;
          
          ctx.save();
          
          // Draw highlight for each selected element
          selectedElements.forEach(uuid => {
              const element = visualState.element.get(uuid);
              if (!element || !visibleLayers.has(element[shared.ELEMENT.LAYER])) return;
              
              // Draw selection outline
              const highlightElement = JSON.parse(JSON.stringify(element));
              highlightElement[shared.ELEMENT.COLOR] = '#0078d7';
              highlightElement[shared.ELEMENT.OPACITY] = 0.3;
              highlightElement[shared.ELEMENT.WIDTH] += 4;
              
              renderElement(ctx, highlightElement);
          });
          
          // Draw selection bounding box
          const bounds = calculateSelectionBounds();
          if (bounds) {
              ctx.setLineDash([5, 5]);
              ctx.strokeStyle = '#0078d7';
              ctx.lineWidth = 2;
              ctx.strokeRect(bounds.x, bounds.y, bounds.width, bounds.height);
              
              // Draw handles for resizing
              const handleSize = 8 / zoomLevel;
              ctx.fillStyle = 'white';
              ctx.strokeStyle = '#0078d7';
              ctx.lineWidth = 1;
              
              // Draw handles at corners and midpoints
              const handles = [
                  {x: bounds.x, y: bounds.y}, // top-left
                  {x: bounds.x + bounds.width/2, y: bounds.y}, // top-middle
                  {x: bounds.x + bounds.width, y: bounds.y}, // top-right
                  {x: bounds.x + bounds.width, y: bounds.y + bounds.height/2}, // middle-right
                  {x: bounds.x + bounds.width, y: bounds.y + bounds.height}, // bottom-right
                  {x: bounds.x + bounds.width/2, y: bounds.y + bounds.height}, // bottom-middle
                  {x: bounds.x, y: bounds.y + bounds.height}, // bottom-left
                  {x: bounds.x, y: bounds.y + bounds.height/2} // middle-left
              ];
              
              handles.forEach(handle => {
                  ctx.fillRect(handle.x - handleSize/2, handle.y - handleSize/2, handleSize, handleSize);
                  ctx.strokeRect(handle.x - handleSize/2, handle.y - handleSize/2, handleSize, handleSize);
              });
          }
          
          ctx.restore();
      }


      // Render pasted elements with orange highlight
      function renderPasteHighlight() {
          if (!pasteMode || pastedElements.length === 0) return;
          
          ctx.save();
          
          // Draw each pasted element with orange tint
          pastedElements.forEach(({originalElement}) => {
              const element = JSON.parse(JSON.stringify(originalElement));
              
              // Apply paste transform
              element[shared.ELEMENT.TRANSFORM] = shared.compose(pasteTransform, originalElement[shared.ELEMENT.TRANSFORM]);
              
              // Render element normally
              renderElement(ctx, element);
              
              // Draw orange outline
              const highlightElement = JSON.parse(JSON.stringify(element));
              highlightElement[shared.ELEMENT.COLOR] = '#ff8c00'; // Dark orange
              highlightElement[shared.ELEMENT.OPACITY] = 0.4;
              highlightElement[shared.ELEMENT.WIDTH] += 3;
              renderElement(ctx, highlightElement);
          });
          
          ctx.restore();
          
          // Draw control triangle for affine transformations
          renderControlTriangle();
      }

      // Check if we can incrementally update background
      function canIncrementallyUpdate() {
          if (!backgroundValid || backgroundRenderedUpTo >= present) {
              return false;
          }
          
          // Check if all actions since last render are DRAW actions
          for (let i = backgroundRenderedUpTo; i < present; i++) {
              const action = history[i];
              if (action.type !== shared.MOD_ACTIONS.DRAW.TYPE) {
                  return false; // Non-draw action requires full re-render
              }
          }
          
          return true;
      }
      
      // Render static background (all committed elements)
      function renderBackground() {
          if (!backgroundCanvas || !backgroundCtx) return;
          
          // Try incremental update if possible
          if (canIncrementallyUpdate()) {
              // Incremental update: only render new DRAW actions
              backgroundCtx.save();
              backgroundCtx.setTransform(zoomLevel, 0, 0, zoomLevel, panX, panY);
              
              for (let i = backgroundRenderedUpTo; i < present; i++) {
                  const action = history[i];
                  const stroke = action[shared.MOD_ACTIONS.DRAW.STROKE];
                  if (stroke && visibleLayers.has(stroke[shared.ELEMENT.LAYER])) {
                      renderElement(backgroundCtx, stroke);
                  }
              }
              
              backgroundCtx.restore();
              backgroundRenderedUpTo = present;
              backgroundValid = true;
              return;
          }
          
          // Full re-render: clear and render everything
          backgroundCtx.save();
          backgroundCtx.setTransform(1, 0, 0, 1, 0, 0);
          backgroundCtx.clearRect(0, 0, backgroundCanvas.width, backgroundCanvas.height);
          backgroundCtx.restore();
          
          // Apply zoom and pan to background
          backgroundCtx.setTransform(zoomLevel, 0, 0, zoomLevel, panX, panY);
          
          // Render all visible elements to background
          shared.render_all_visible_elements(visualState, (element) => {
              if (visibleLayers.has(element[shared.ELEMENT.LAYER])) {
                  renderElement(backgroundCtx, element);
              }
          });
          
          // Render selection highlights to background
          if (selectedElements.length > 0) {
              renderSelectionHighlightToContext(backgroundCtx);
          }
          
          backgroundRenderedUpTo = present;
          backgroundValid = true;
      }
      
      // Render selection highlight to a specific context
      function renderSelectionHighlightToContext(context) {
          if (selectedElements.length === 0) return;
          
          context.save();
          
          // Draw highlight for each selected element
          selectedElements.forEach(uuid => {
              const element = visualState.element.get(uuid);
              if (!element || !visibleLayers.has(element[shared.ELEMENT.LAYER])) return;
              
              // Draw selection outline
              const highlightElement = JSON.parse(JSON.stringify(element));
              highlightElement[shared.ELEMENT.COLOR] = '#0078d7';
              highlightElement[shared.ELEMENT.OPACITY] = 0.3;
              highlightElement[shared.ELEMENT.WIDTH] += 4;
              
              renderElement(context, highlightElement);
          });
          
          // Draw selection bounding box
          const bounds = calculateSelectionBounds();
          if (bounds) {
              context.setLineDash([5, 5]);
              context.strokeStyle = '#0078d7';
              context.lineWidth = 2;
              context.strokeRect(bounds.x, bounds.y, bounds.width, bounds.height);
              
              // Draw handles for resizing
              const handleSize = 8 / zoomLevel;
              context.fillStyle = 'white';
              context.strokeStyle = '#0078d7';
              context.lineWidth = 1;
              
              // Draw handles at corners and midpoints
              const handles = [
                  {x: bounds.x, y: bounds.y}, // top-left
                  {x: bounds.x + bounds.width/2, y: bounds.y}, // top-middle
                  {x: bounds.x + bounds.width, y: bounds.y}, // top-right
                  {x: bounds.x + bounds.width, y: bounds.y + bounds.height/2}, // middle-right
                  {x: bounds.x + bounds.width, y: bounds.y + bounds.height}, // bottom-right
                  {x: bounds.x + bounds.width/2, y: bounds.y + bounds.height}, // bottom-middle
                  {x: bounds.x, y: bounds.y + bounds.height}, // bottom-left
                  {x: bounds.x, y: bounds.y + bounds.height/2} // middle-left
              ];
              
              handles.forEach(handle => {
                  context.fillRect(handle.x - handleSize/2, handle.y - handleSize/2, handleSize, handleSize);
                  context.strokeRect(handle.x - handleSize/2, handle.y - handleSize/2, handleSize, handleSize);
              });
          }
          
          context.restore();
      }
      
      // Redraw the canvas - optimized with background caching
      function redrawCanvas() {
          // Check if we are in an interactive mode (drawing, erasing, selecting, pasting)
          const isInteractive = isDrawing || isErasing || isSelecting || pasteMode;
          
          // If background is invalid or we are not in interactive mode, render fresh background
          if (!backgroundValid || !isInteractive) {
              renderBackground();
          }
          
          // Clear display canvas
          ctx.save();
          ctx.setTransform(1, 0, 0, 1, 0, 0);
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          
          // Copy background to display canvas (fast!)
          if (backgroundValid) {
              ctx.drawImage(backgroundCanvas, 0, 0);
          }
          
          ctx.restore();
          
          // Apply zoom and pan for active elements
          ctx.setTransform(zoomLevel, 0, 0, zoomLevel, panX, panY);

          // WARNING: only go up to present, otherwise you break undo
          // for ( let i = present; i < history.length; i++ ) {
          //     const action = history[i];
          //     const stroke = action[shared.MOD_ACTIONS.DRAW.STROKE];
          //     if (stroke && visibleLayers.has(stroke[shared.ELEMENT.LAYER])) {
          //         renderElement(ctx, stroke);
          //     }
          // }
          
          // Draw current stroke if we are drawing or erasing (active layer)
          if ((isDrawing || isErasing) && currentStroke) {
              renderElement(ctx, currentStroke);
          }
          
          // Draw selection rectangle if selecting (active layer)
          if (isSelecting && selectionStroke) {
              renderElement(ctx, selectionStroke);
          }
          
          // Draw paste highlights if in paste mode (active layer)
          if (pasteMode) {
              renderPasteHighlight();
          }
      }

      

      // export current page to pdf

      function getTimestampForFilename() {
          const now = new Date();
          const year = now.getFullYear();
          const month = (now.getMonth() + 1).toString().padStart(2, '0');
          const day = now.getDate().toString().padStart(2, '0');
          const hours = now.getHours().toString().padStart(2, '0');
          const minutes = now.getMinutes().toString().padStart(2, '0');
          const seconds = now.getSeconds().toString().padStart(2, '0');          
          return `${year}-${month}-${day}_${hours}-${minutes}-${seconds}`;
      }

      function exportPageToPDF () {
          try {
              const timestamp = getTimestampForFilename();
              
              // Create PDF with vector rendering
              const builder = shared.PDFBuilder();
              const pdfCtx = builder.new_page(canvas.width, canvas.height);
              
              // Apply zoom transformation
              pdfCtx.transform(zoomLevel, 0, 0, zoomLevel, panX, panY);
              
              // Render all visible elements as vectors
              shared.render_all_visible_elements(visualState, (element) => {
                  if (visibleLayers.has(element[shared.ELEMENT.LAYER])) {
                      renderElement(pdfCtx, element);
                  }
              });
              
              // Download the PDF
              builder.download_in_browser(`board_${boardId}_page_${pageNr}_${timestamp}.pdf`);
              
          } catch (err) {
              showError(`PDF export failed: ${err.message}`);
              console.error('PDF export error:', err);
          }
      }

      async function exportBoardToPDF() {
          try {
              const timestamp = getTimestampForFilename();
              
              // Create PDF with vector rendering
              const builder = shared.PDFBuilder();
              
              // Snapshot current page number for delta calculations
              const startPageNr = pageNr;
              
              // Iterate through each page sequentially
              for (let i = 1; i <= totalPages; i++) {
                  showError(`Exporting page ${i}/${totalPages}...`);
                  
                  // Request and wait for page data
                  const pageData = await new Promise((resolve) => {
                      const requestId = createRequestId();
                      const originalHandler = ws.onmessage;
                      
                      ws.onmessage = (event) => {
                          try {
                              const data = shared.deserialize(event.data);
                              if (data.type === shared.MESSAGES.SERVER_TO_CLIENT.FULL_PAGE.TYPE) {
                                  const pageHistory = data[shared.MESSAGES.SERVER_TO_CLIENT.FULL_PAGE.HISTORY];
                                  const pagePresent = data[shared.MESSAGES.SERVER_TO_CLIENT.FULL_PAGE.PRESENT];
                                  
                                  ws.onmessage = originalHandler;
                                  resolve({ history: pageHistory, present: pagePresent });
                              } else {
                                  originalHandler.call(ws, event);
                              }
                          } catch (error) {
                              ws.onmessage = originalHandler;
                              console.error('Error getting page:', error);
                              resolve(null);
                          }
                      };
                      
                      const request = {
                          type: shared.MESSAGES.CLIENT_TO_SERVER.FULL_PAGE_REQUESTS.TYPE,
                          [shared.MESSAGES.CLIENT_TO_SERVER.FULL_PAGE_REQUESTS.BOARD_UUID]: boardId,
                          [shared.MESSAGES.CLIENT_TO_SERVER.FULL_PAGE_REQUESTS.PAGE_ID]: currentPageUuid,
                          [shared.MESSAGES.CLIENT_TO_SERVER.FULL_PAGE_REQUESTS.DELTA]: i - startPageNr,
                          [shared.MESSAGES.CLIENT_TO_SERVER.FULL_PAGE_REQUESTS.REQUEST_ID]: requestId
                      };
                      
                      ws.send(shared.serialize(request));
                  });
                  
                  if (!pageData) continue;
                  
                  // Create new page in PDF
                  const pdfCtx = builder.new_page(canvas.width, canvas.height);
                  
                  // Apply zoom and pan transformation
                  pdfCtx.transform(zoomLevel, 0, 0, zoomLevel, panX, panY);
                  
                  // Compile visual state for this page
                  const pageVisualState = shared.createEmptyVisualState();
                  const pageActions = pageData.history.slice(0, pageData.present);
                  for (const action of pageActions) {
                      shared.commitEdit(pageVisualState, action);
                  }
                  
                  // Render all visible elements as vectors
                  shared.render_all_visible_elements(pageVisualState, (element) => {
                      if (visibleLayers.has(element[shared.ELEMENT.LAYER])) {
                          renderElement(pdfCtx, element);
                      }
                  });
              }
              
              // Download the complete multi-page PDF
              builder.download_in_browser(`board_${boardId}_${timestamp}.pdf`);
              hideError();
              
          } catch (err) {
              hideError();
              showError(`PDF export failed: ${err.message}`);
              console.error('PDF export error:', err);
          }
      }

      
      // Copy current board link to clipboard
      function copyBoardLink() {
          if (!boardId) {
              alert('No board is currently loaded');
              return;
          }
          
          // Build the full URL with board ID and password
          let boardUrl = `${window.location.origin}${window.location.pathname}?board=${boardId}`;
          if (passwd) {
              boardUrl += `&passwd=${passwd}`;
          }
          
          // Copy to clipboard
          navigator.clipboard.writeText(boardUrl).then(() => {
              // Show feedback
              const feedback = document.getElementById('copy-feedback');
              feedback.style.display = 'inline';
              setTimeout(() => {
                  feedback.style.display = 'none';
              }, 2000);
          }).catch(err => {
              alert('Failed to copy to clipboard');
              console.error('Clipboard error:', err);
          });
      }
      
      // Parse whiteboard URL to extract board ID and password
      function parseWhiteboardURL(urlString) {
          try {
              const url = new URL(urlString);
              
              // Check if it's the same origin (same domain)
              if (url.origin !== window.location.origin) {
                  return null; // Different domain - invalid
              }
              
              // Extract board ID and password from query parameters
              const params = new URLSearchParams(url.search);
              const boardId = params.get('board');
              
              if (!boardId) {
                  return null; // No board ID - invalid
              }
              
              return {
                  boardId: boardId,
                  password: params.get('passwd') || ''
              };
          } catch (e) {
              // Invalid URL format
              return null;
          }
      }
      
      // Board Navigation Functions
      function openBoardNavigation() {
          const overlay = document.getElementById('board-nav-overlay');
          overlay.style.display = 'flex';
          
          // Pre-fill credential field if stored
          const credentialInput = document.getElementById('new-board-credential-input');
          if (storedCredential) {
              credentialInput.value = storedCredential;
          }
          
          // Pre-fill current board ID if available
          if (boardId) {
              document.getElementById('board-id-input').value = boardId;
          }
      }
      
      function closeBoardNavigation() {
          const overlay = document.getElementById('board-nav-overlay');
          overlay.style.display = 'none';
          
          // Clear form inputs
          document.getElementById('board-url-input').value = '';
          document.getElementById('board-id-input').value = '';
          document.getElementById('board-password-input').value = '';
      }
      
      function handleNewBoard(e) {
          e.preventDefault();
          
          // Read credential from input field
          const credential = document.getElementById('new-board-credential-input').value.trim();
          
          if (!credential) {
              alert('Please enter a credential');
              return;
          }
          
          // Save credential for future reuse
          storedCredential = credential;
          localStorage.setItem('whiteboard_credential', credential);
          
          // Use credential to create new board
          const newUrl = `${window.location.origin}${window.location.pathname}?credential=${encodeURIComponent(credential)}`;
          window.location.href = newUrl;
      }
      
      function handleGotoBoard(e) {
          e.preventDefault();
          
          const boardUrlInput = document.getElementById('board-url-input').value.trim();
          const boardIdInput = document.getElementById('board-id-input').value.trim();
          const boardPasswordInput = document.getElementById('board-password-input').value;
          
          let targetBoardId = null;
          let targetPassword = null;
          
          // Try to parse URL first if provided
          if (boardUrlInput) {
              const parsed = parseWhiteboardURL(boardUrlInput);
              
              if (!parsed) {
                  alert('Invalid whiteboard URL. Please check the URL and try again.');
                  return;
              }
              
              targetBoardId = parsed.boardId;
              targetPassword = parsed.password;
          } else if (boardIdInput) {
              // Use manual entry if URL not provided
              targetBoardId = boardIdInput;
              targetPassword = boardPasswordInput;
          } else {
              alert('Please enter either a board URL or board UUID');
              return;
          }
          
          // Build URL with board ID and optional password
          let newUrl = `${window.location.origin}${window.location.pathname}?board=${encodeURIComponent(targetBoardId)}`;
          
          if (targetPassword) {
              newUrl += `&passwd=${encodeURIComponent(targetPassword)}`;
          }
          
          // Change URL and (not) reload page
          boardId = targetBoardId;
          passwd = targetPassword;
          registerBoard(boardId);
          // window.location.assign( newUrl );
          window.history.replaceState(null, null, newUrl);
          closeBoardNavigation();
      }
      
      // Register Service Worker for PWA
      if ('serviceWorker' in navigator) {
          window.addEventListener('load', () => {
              navigator.serviceWorker.register('/sw.js')
                  .then(registration => {
                      console.log('Service Worker registered:', registration.scope);
                  })
                  .catch(error => {
                      console.log('Service Worker registration failed:', error);
                  });
          });
      }
      
      // Initialize the app
      window.addEventListener('DOMContentLoaded', init);
      setTool('chalk');
      updateKnobs();
      update_shape_buttons();
    </script>
  </body>
</html>
