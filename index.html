<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Xournal++ Clone</title>
    <link rel="manifest" href="data:application/manifest+json,%7B%22name%22%3A%22Whiteboard%20App%22%2C%22short_name%22%3A%22Whiteboard%22%2C%22start_url%22%3A%22.%22%2C%22display%22%3A%22standalone%22%2C%22background_color%22%3A%22%23ffffff%22%2C%22theme_color%22%3A%22%23000000%22%2C%22icons%22%3A%5B%7B%22src%22%3A%22data%3Aimage%2Fsvg%2Bxml%2C%253Csvg%2520xmlns%253D%2522http%253A%252F%252Fwww.w3.org%252F2000%252Fsvg%2522%2520viewBox%253D%25220%25200%2520100%2520100%2522%253E%253Cpath%2520d%253D%2522M25%252075%2520L75%252025%2520M25%252025%2520L75%252075%22%2520stroke%253D%2522black%2522%2520stroke-width%253D%252210%2522%2520%252F%253E%253C%252Fsvg%253E%22%2C%22sizes%22%3A%22192x192%22%2C%22type%22%3A%22image%2Fsvg%2Bxml%22%7D%5D%7D">
    <style>
      body {
          margin: 0;
          padding: 0;
          font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
          overflow: hidden;
          display: flex; /* Make body a flex container */
          flex-direction: column; /* Stack children vertically */
          height: 100vh;
      }
      
      .toolbar {
          display: flex;
          background-color: #f0f0f0;
          padding: 5px;
          border-bottom: 1px solid #ccc;
      }
      
      .tool-section {
          display: flex;
          align-items: center;
          margin-right: 10px;
      padding-right: 10px;
      border-right: 1px solid #ddd;
      }

      .tool-btn {
      width: 30px;
      height: 30px;
      margin: 0 2px;
      cursor: pointer;
      border: 3px solid #f0f0f0;
      background-color: #f0f0f0;
      border-radius: 4px;
      }
      
      .tool-btn:hover {
      background-color: #e0e0e0;
      }

      .tool-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      }
      
      .tool-btn.active {
      border: 3px solid transparent;
      }
      
      .shape-btn {
      width: 30px;
      height: 30px;
      margin: 0 2px;
      cursor: pointer;
      border: 3px solid #f0f0f0;
      background-color: #f0f0f0;
      border-radius: 4px;
      }
      
      .shape-btn:hover {
      background-color: #e0e0e0;
      }

      .shape-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      }
      
      .shape-btn.active {
      border: 3px solid transparent;
      background-color: #808080;
      }
      
      .color-swatch {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      margin: 3px;
      cursor: pointer;
      border: 1px solid #ccc;
      }
      
      .color-swatch.active {
      width: 12px;
      height: 12px;
      /* border-color: #333; */
      /* border-width: 6px; */
      }
      
      /* Base slider styles */
      input[type="range"] {
      -webkit-appearance: none;
      width: 100px; /* Swap width and height for vertical layout */
      height: 8px;
      background: #d3d3d3;
      outline: none;
      opacity: 0.7;
      transition: opacity .2s;
      }
      
      input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      border-radius: 50%;
      background: var(--thumb-color, black);
      cursor: pointer;
      width: calc(var(--thumb-size, 2) * 2px); 
      height: calc(var(--thumb-size, 2) * 2px);
      }
      
      input[type="range"]::-moz-range-thumb {
      border: none;
      border-radius: 50%;
      background: var(--thumb-color, black);
      cursor: pointer;
      width: calc(var(--thumb-size, 2) * 2px);
      height: calc(var(--thumb-size, 2) * 2px);
      }
      
      /* Specific styles for the opacity slider */
      #opacity-selector {
      background: #fff;
      }
      
      #opacity-selector::-webkit-slider-thumb {
      width: 24px;
      height: 24px;
      backgroungd: #black;
      /* background: var(--thumb-color); */
      opacity: var(--thumb-opacity, 1);
      }
      
      #opacity-selector::-moz-range-thumb {
      width: 24px;
      height: 24px;
      backgroungd: #black;
      /* background: var(--thumb-color); */
      filter: opacity( var(--thumb-opacity, 1));
      }
      
      #debug-tools {
      margin-left: auto;
      }

      .app-container {
      display: flex;
      flex-grow: 1;
      }
      
      .sidebar {
      width: 50px; /* Reduced width for a more compact sidebar */
      background-color: #f0f0f0;
      /* border-right: 0px solid #ccc; */
      padding: 4px 0px;
      display: flex;
      flex-direction: column;
      align-items: center;
      }

      .sidebar-section {
      width: 100%;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      align-items: center; /* Center content within each section */
      padding: 4px 0px;
      margin-bottom: 1px;
      border-bottom: 1px solid #ddd;
      }
      
      .sidebar-section:last-child {
      border-bottom: none;
      }

      #width-selection, #opacity-selection {
      /* Apply styles to the individual slider sections */
      height: 120px; /* Give the containers enough space to hold the rotated sliders */
      justify-content: center;
      }
      
      #width-selector, #opacity-selector {
      transform: rotate(90deg); /* Rotate the sliders */
      transform-origin: 50% 50%; /* Ensure rotation is centered */
      }

      .main-content {
      flex-grow: 1;
      overflow: hidden;
      }
      
      #canvas-container {
      position: relative;
      width: 100%;
      height: 100%;
      }
      
      canvas {
      position: absolute;
      background-color: white;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      }

      .page-controls {
      display: flex;
      align-items: center;
      }
      
      #page-info {
      margin: 0 10px;
      }
      
      .error-banner {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background-color: #f44336;
      color: white;
      padding: 15px;
      text-align: center;
      z-index: 1000;
      display: none;
      }
      
      .error-banner button {
      margin-left: 15px;
      background-color: white;
      color: #f44336;
      border: none;
      padding: 5px 10px;
      cursor: pointer;
      border-radius: 4px;
      }

      .tooltip {
      position: relative;
      display: inline-block;
      }

      .tooltip .tooltiptext {
      visibility: hidden;
      width: 120px;
      background-color: #555;
      color: #fff;
      text-align: center;
      border-radius: 6px;
      padding: 5px;
      position: absolute;
      z-index: 1;
      bottom: 125%;
      left: 50%;
      margin-left: -60px;
      opacity: 0;
      transition: opacity 0.3s;
      font-size: 12px;
      }

      .tooltip:hover .tooltiptext {
      visibility: visible;
      opacity: 1;
      }

      /* Simple Color Picker Styles */
      #simple-color-picker {
      position: fixed;
      z-index: 1000;
      background: white;
      border: 1px solid #ccc;
      border-radius: 8px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
      padding: 10px;
      width: 260px;
      display: none;
      }
      
      #simple-color-picker-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      border-bottom: 1px solid #eee;
      padding-bottom: 5px;
      }
      
      #simple-color-picker-title {
      font-weight: bold;
      margin: 0;
      }
      
      #simple-color-picker-close {
      background: none;
      border: none;
      font-size: 18px;
      cursor: pointer;
      padding: 2px 5px;
      }
      
      #color-grid {
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      gap: 4px;
      margin-bottom: 10px;
      }
      
      .color-cell {
      width: 25px;
      height: 25px;
      border-radius: 3px;
      cursor: pointer;
      border: 1px solid #ccc;
      }
      
      .color-cell:hover {
      transform: scale(1.1);
      }
      
      #color-preview {
      height: 30px;
      border-radius: 4px;
      border: 1px solid #ccc;
      margin-bottom: 10px;
      display: flex;
      }
      
      #new-color {
      flex: 3;
      height: 100%;
      }
      
      #original-color {
      flex: 1;
      height: 100%;
      border-left: 1px solid #ccc;
      }
      
      #color-controls {
      display: flex;
      justify-content: space-between;
      margin-top: 10px;
      }
      
      #color-picker-actions {
      display: flex;
      gap: 5px;
      }
      
      #color-picker-actions button {
      padding: 5px 10px;
      border-radius: 4px;
      cursor: pointer;
      }
      
      #color-picker-apply {
      background-color: #4CAF50;
      color: white;
      border: none;
      }
      
      #color-picker-cancel {
      background-color: #f1f1f1;
      border: 1px solid #ccc;
      }
      
      #hex-input {
      padding: 5px;
      width: 80px;
      border: 1px solid #ccc;
      border-radius: 4px;
      }
    </style>
  </head>
  <body>
    <div class="error-banner" id="error-banner">
      <span id="error-message">Connection error</span>
      <button id="reconnect-button">Reconnect</button>
    </div>
    
    <div class="toolbar">
      <div class="tool-section" id="export-pdf">
        <button class="tool-btn" id="pdf-btn" title="export-pdf">üìÉ</button>
      </div>

      <div class="tool-section page-controls">
        <button class="tool-btn" id="prev-page">‚óÄÔ∏è</button>
        <span id="page-info">Page 1 of 1</span>
        <button class="tool-btn" id="next-page">‚ñ∂Ô∏è</button>
        <button class="tool-btn" id="add-page">‚ûï</button>
        <button class="tool-btn" id="delete-page">‚ûñ</button>
      </div>
      
      <div class="tool-section">
        <button class="tool-btn" id="zoom-out">-</button>
        <span id="zoom-level">100%</span>
        <button class="tool-btn" id="zoom-in">+</button>
      </div>
      
      <div class="tool-section">
        <button class="tool-btn tooltip" id="undo-btn" title="Undo" disabled>‚Ü©
          <span class="tooltiptext">Undo (Ctrl+Z)</span>
        </button>
        <button class="tool-btn tooltip" id="redo-btn" title="Redo" disabled>‚Ü™
          <span class="tooltiptext">Redo (Ctrl+Y)</span>
        </button>
      </div>
      
      <div class="tool-section">
        <button class="tool-btn" id="chalk-tool" title="Chalk"><span style="filter: grayscale(100%) invert(100%);">üñçÔ∏è</span></button>
        <button class="tool-btn active" id="pen-tool" title="Pen">‚úèÔ∏è</button>
        <button class="tool-btn" id="highlighter-tool" title="Highlighter">üñåÔ∏è</button>
        <button class="tool-btn" id="eraser-tool" title="Eraser">üßΩ</button>
      </div>
      
      <div class="tool-section" id="debug-tools">
        <button class="tool-btn" id="debug-btn" title="Debug">üêû</button>
        <span id="sync-status">‚úì</span>
      </div>
    </div>
    
    <div class="app-container">
      <div class="sidebar">
        <div class="tool-section sidebar-section" id="color-selection">
          <div class="color-swatch" style="background-color: black;" data-color="black"></div>
          <div class="color-swatch" style="background-color: red;" data-color="red"></div>
          <div class="color-swatch" style="background-color: green;" data-color="green"></div>
          <div class="color-swatch" style="background-color: blue;" data-color="blue"></div>
          <div class="color-swatch" style="background-color: yellow;" data-color="yellow"></div>
        </div>
        <div class="tool-section sidebar-section" id="width-selection">
          <input type="range" id="width-selector" min="1" max="20">
        </div>
        <div class="tool-section sidebar-section" id="opacity-selection">
          <input type="range" id="opacity-selector" min="0" max="128">
        </div>
        <div class="tool-section sidebar-section" id="timer-toggle">
          <button class="shape-btn" id="timer-btn" title="Timer">‚è≤</button>
        </div>
        <div class="tool-section sidebar-section" id="loop-toggle">
          <button class="shape-btn" id="loop-btn" title="open stroke / closed loop"></button>
        </div>
        <div class="tool-section sidebar-section" id="fill-toggle">
          <button class="shape-btn" id="fill-btn" title="draw / fill"></button>
        </div>
        <div class="tool-section sidebar-section" id="curve-selection">
          <button class="shape-btn" id="curve-btn" title="rectangle path">‚ö°</button>
        </div>
        <div class="tool-section sidebar-section" id="rectangle-selection">
          <button class="shape-btn" id="rectangle-btn" title="rectangle path">‚ñ≠</button>
        </div>
        <div class="tool-section sidebar-section" id="horizontal-selection">
          <button class="shape-btn" id="horizontal-btn" title="horizontal line">‚éØ</button>
        </div>
        <div class="tool-section sidebar-section" id="vertical-selection">
          <button class="shape-btn" id="vertical-btn" title="vertical line">‚èê</button>
        </div>
        <div class="tool-section sidebar-section" id="line-selection">
          <button class="shape-btn" id="line-btn" title="straight line">‚öû</button>
        </div>
      </div>
      
      <div class="main-content">
        <div id="canvas-container">
          <canvas id="canvas"></canvas>
        </div>
      </div>
    </div>

    <!-- Simple Color Picker -->
    <div id="simple-color-picker">
      <div id="simple-color-picker-header">
        <h4 id="simple-color-picker-title">Color Picker</h4>
        <button id="simple-color-picker-close">√ó</button>
      </div>
      
      <div id="color-preview">
        <div id="new-color"></div>
        <div id="original-color"></div>
      </div>
      
      <div id="color-grid">
        <!-- Standard Colors: First Row -->
        <div class="color-cell" style="background-color: #000000" data-color="#000000"></div>
        <div class="color-cell" style="background-color: #808080" data-color="#808080"></div>
        <div class="color-cell" style="background-color: #800000" data-color="#800000"></div>
        <div class="color-cell" style="background-color: #808000" data-color="#808000"></div>
        <div class="color-cell" style="background-color: #008000" data-color="#008000"></div>
        <div class="color-cell" style="background-color: #008080" data-color="#008080"></div>
        <div class="color-cell" style="background-color: #000080" data-color="#000080"></div>
        <div class="color-cell" style="background-color: #800080" data-color="#800080"></div>
        
        <!-- Standard Colors: Second Row -->
        <div class="color-cell" style="background-color: #FFFFFF" data-color="#FFFFFF"></div>
        <div class="color-cell" style="background-color: #C0C0C0" data-color="#C0C0C0"></div>
        <div class="color-cell" style="background-color: #FF0000" data-color="#FF0000"></div>
        <div class="color-cell" style="background-color: #FFFF00" data-color="#FFFF00"></div>
        <div class="color-cell" style="background-color: #00FF00" data-color="#00FF00"></div>
        <div class="color-cell" style="background-color: #00FFFF" data-color="#00FFFF"></div>
        <div class="color-cell" style="background-color: #0000FF" data-color="#0000FF"></div>
        <div class="color-cell" style="background-color: #FF00FF" data-color="#FF00FF"></div>
        
        <!-- More Blues -->
        <div class="color-cell" style="background-color: #000033" data-color="#000033"></div>
        <div class="color-cell" style="background-color: #003399" data-color="#003399"></div>
        <div class="color-cell" style="background-color: #0066CC" data-color="#0066CC"></div>
        <div class="color-cell" style="background-color: #0099FF" data-color="#0099FF"></div>
        <div class="color-cell" style="background-color: #66CCFF" data-color="#66CCFF"></div>
        <div class="color-cell" style="background-color: #99FFFF" data-color="#99FFFF"></div>
        <div class="color-cell" style="background-color: #CCFFFF" data-color="#CCFFFF"></div>
        <div class="color-cell" style="background-color: #EFFFFF" data-color="#EFFFFF"></div>
        
        <!-- More Greens -->
        <div class="color-cell" style="background-color: #003300" data-color="#003300"></div>
        <div class="color-cell" style="background-color: #009933" data-color="#009933"></div>
        <div class="color-cell" style="background-color: #33CC33" data-color="#33CC33"></div>
        <div class="color-cell" style="background-color: #66FF66" data-color="#66FF66"></div>
        <div class="color-cell" style="background-color: #99FF99" data-color="#99FF99"></div>
        <div class="color-cell" style="background-color: #CCFFCC" data-color="#CCFFCC"></div>
        <div class="color-cell" style="background-color: #EFFFEF" data-color="#EFFFEF"></div>
        <div class="color-cell" style="background-color: #F5FFF5" data-color="#F5FFF5"></div>
        
        <!-- More Reds -->
        <div class="color-cell" style="background-color: #330000" data-color="#330000"></div>
        <div class="color-cell" style="background-color: #990000" data-color="#990000"></div>
        <div class="color-cell" style="background-color: #CC3333" data-color="#CC3333"></div>
        <div class="color-cell" style="background-color: #FF6666" data-color="#FF6666"></div>
        <div class="color-cell" style="background-color: #FF9999" data-color="#FF9999"></div>
        <div class="color-cell" style="background-color: #FFCCCC" data-color="#FFCCCC"></div>
        <div class="color-cell" style="background-color: #FFEFEF" data-color="#FFEFEF"></div>
        <div class="color-cell" style="background-color: #FFF5F5" data-color="#FFF5F5"></div>

        <!-- Yellows and Browns -->
        <div class="color-cell" style="background-color: #333300" data-color="#333300"></div>
        <div class="color-cell" style="background-color: #999900" data-color="#999900"></div>
        <div class="color-cell" style="background-color: #CCCC33" data-color="#CCCC33"></div>
        <div class="color-cell" style="background-color: #FFFF66" data-color="#FFFF66"></div>
        <div class="color-cell" style="background-color: #FFFF99" data-color="#FFFF99"></div>
        <div class="color-cell" style="background-color: #FFFFCC" data-color="#FFFFCC"></div>
        <div class="color-cell" style="background-color: #FFFFEF" data-color="#FFFFEF"></div>
        <div class="color-cell" style="background-color: #FFFFF5" data-color="#FFFFF5"></div>
        
        <!-- Browns and Oranges -->
        <div class="color-cell" style="background-color: #663300" data-color="#663300"></div>
        <div class="color-cell" style="background-color: #996633" data-color="#996633"></div>
        <div class="color-cell" style="background-color: #CC9933" data-color="#CC9933"></div>
        <div class="color-cell" style="background-color: #FFCC66" data-color="#FFCC66"></div>
        <div class="color-cell" style="background-color: #FF9933" data-color="#FF9933"></div>
        <div class="color-cell" style="background-color: #FF6600" data-color="#FF6600"></div>
        <div class="color-cell" style="background-color: #FF3300" data-color="#FF3300"></div>
        <div class="color-cell" style="background-color: #CC3300" data-color="#CC3300"></div>
      </div>
      
      <div id="color-controls">
        <input type="text" id="hex-input" placeholder="#RRGGBB">
        <div id="color-picker-actions">
          <button id="color-picker-cancel">Cancel</button>
          <button id="color-picker-apply">Apply</button>
        </div>
      </div>
    </div>

    <script src="shared.js"></script>
    <script src="https://www.kubux.net/files/nodejs-libs/jspdf.umd.min.js"></script>
    <script>
      // Debug logging function
      function debugLog(msg, data) {
          console.log(`[DEBUG] ${msg}`, data || '');
      };

      const manifest = {
          "name": "Whiteboard App",
          "short_name": "Whiteboard",
          "start_url": ".",
          "display": "standalone",
          "background_color": "#ffffff",
          "theme_color": "#000000",
          "icons": [
              {
                  "src": "data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20viewBox%3D%220%200%20100%20100%22%3E%3Cpath%20d%3D%22M25%2075%20L75%2025%20M25%2025%20L75%2075%22%20stroke%3D%22black%22%20stroke-width%3D%2210%22%20%2F%3E%3C%2Fsvg%3E",
                  "sizes": "192x192",
                  "type": "image/svg+xml"
              }
          ]
      };
      
      const manifest_json = JSON.stringify(manifest);
      const encoded_manifest = encodeURIComponent(manifest_json);
      const data_uri = `data:application/manifest+json,${encoded_manifest}`;

      // settings
      let eraser_settings = {
          tool: "eraser",
          opacity: 0.3,
          color: "#ff0000",
          undo: false,
          fill: false,
          loop: false,
          shape: 'curve',
          width: 2
      };
      let pen_settings = {
          tool: "pen", 
          opacity: 1.0,
          width: 2,
          color: "blue",
          undo: false,
          fill: false,
          loop: false,
          shape: 'curve',
          stroke: shared.createStroke( shared.STROKE_STYLES.PEN )
      };
      let chalk_settings = {
          tool: "chalk",
          opacity: 1.0,
          width: 3,
          color: "black",
          undo: false,
          fill: false,
          loop: false,
          shape: 'curve',
          stroke: shared.createStroke( shared.STROKE_STYLES.CHALK )
      };
      let highlighter_settings = {
          tool: "highlighter",
          opacity: 0.2,
          width: 24,
          color: "yellow",
          undo: true,
          fill: false,
          loop: false,
          shape: 'curve',
          stroke: shared.createStroke( shared.STROKE_STYLES.HIGHLIGHTER )
      };

      let draw_settings = chalk_settings;

      function stroke_from_settings () {
          currentStroke = [...draw_settings.stroke];
          currentStroke[shared.ELEMENT.WIDTH] = draw_settings.width;
          currentStroke[shared.ELEMENT.COLOR] = draw_settings.color;
          currentStroke[shared.ELEMENT.OPACITY] = draw_settings.opacity;
      };

      function updateKnobs () {
          document.getElementById('chalk-tool').style.backgroundColor = chalk_settings.color;
          document.getElementById('pen-tool').style.backgroundColor = pen_settings.color;
          document.getElementById('highlighter-tool').style.backgroundColor = highlighter_settings.color;

          widthSelector.style.setProperty('--thumb-size', draw_settings.width);
          // widthSelector.style.setProperty('--thumb-color', draw_settings.color);
          widthSelector.value = draw_settings.width;
          opacitySelector.style.setProperty('--thumb-opacity', draw_settings.opacity);
          // opacitySelector.style.setProperty('--thumb-color', draw_settings.color);
          opacitySelector.value =  draw_settings.opacity * 128;
          if ( draw_settings.undo ) {
              document.getElementById('timer-btn').classList.add('active');
          } else {
              document.getElementById('timer-btn').classList.remove('active');
          }
          if ( draw_settings.fill ) { 
              document.getElementById('fill-btn').innerHTML = '‚¨§';
          } else {
              document.getElementById('fill-btn').innerHTML = '‚óØ';
          }
          if ( draw_settings.loop ) { 
              document.getElementById('loop-btn').innerHTML = 'D';
          } else {
              document.getElementById('loop-btn').innerHTML = 'S';
          }
          update_shape_buttons();
      }
      
      // updateKnobs();

      function switch_settings ( the_settings ) {
          draw_settings = the_settings;
          updateKnobs();
          switch (draw_settings.tool) {
          case 'pen':
          case 'chalk':
          case 'highlighter':
              colorSelectionDiv.style.display = 'flex';
              widthSelectionDiv.style.display = 'flex';
              opacitySelectionDiv .style.display = 'flex';
              timerToggleDiv.style.display = 'flex';
              fillToggleDiv.style.display = 'flex';
              loopToggleDiv.style.display = 'flex';
              curveSelectionDiv.style.display = 'flex';
              rectangleSelectionDiv.style.display = 'flex';
              horizontalSelectionDiv.style.display = 'flex';
              verticalSelectionDiv.style.display = 'flex';
              lineSelectionDiv.style.display = 'flex';
              break;
          case 'eraser':
              colorSelectionDiv.style.display = 'none';
              widthSelectionDiv.style.display = 'flex';
              opacitySelectionDiv .style.display = 'none';
              timerToggleDiv.style.display = 'none';
              fillToggleDiv.style.display = 'none';
              loopToggleDiv.style.display = 'none';
              curveSelectionDiv.style.display = 'none';
              rectangleSelectionDiv.style.display = 'none';
              horizontalSelectionDiv.style.display = 'none';
              verticalSelectionDiv.style.display = 'none';
              lineSelectionDiv.style.display = 'none';
              break;
          }
      };

      // Globals for board state
      let ws = null;
      let boardId = null;
      let passwd = null; // needed for edits
      let clientId = shared.generateUuid(); // Unique client identifier
      let currentPageUuid = null;
      let pageNr = 1;
      let totalPages = 1;
      let connectionEstablished = false;
      
      // Drawing state
      let isDrawing = false;
      let isErasing = false;
      let currentPath = [];
      let currentStroke = null;
      
      // Timeline state with complete hash chain
      let history = [];          // All actions in timeline
      let present = 0;           // Current position in timeline
      let hashes = [];           // Hash chain for all states
      let verifiedIndex = 0;     // Last index confirmed by server
      
      // Visual state
      let visualState = shared.createEmptyVisualState();
      
      // Zoom state
      let zoomLevel = 1;
      
      // Tool state
      let currentTool = 'chalk';
      let eraserRadius = 20;
      let currentColor = '#000000';
      let currentWidth = 2;
      let currentOpacity = 1.0;
      
      // DOM elements
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');
      const container = document.getElementById('canvas-container');
      const widthSelector = document.getElementById('width-selector');
      // const widthValue = document.getElementById('width-value');
      const opacitySelector = document.getElementById('opacity-selector');
      // const opacityValue = document.getElementById('opacity-value');
      const zoomLevelDisplay = document.getElementById('zoom-level');
      const pageInfo = document.getElementById('page-info');
      const errorBanner = document.getElementById('error-banner');
      const errorMessage = document.getElementById('error-message');
      const reconnectButton = document.getElementById('reconnect-button');
      const undoBtn = document.getElementById('undo-btn');
      const redoBtn = document.getElementById('redo-btn');
      const syncStatus = document.getElementById('sync-status');

      const colorSelectionDiv = document.getElementById('color-selection');
      const widthSelectionDiv = document.getElementById('width-selection');
      const opacitySelectionDiv = document.getElementById('opacity-selection');
      const timerToggleDiv = document.getElementById('timer-toggle');
      const fillToggleDiv = document.getElementById('fill-toggle');
      const loopToggleDiv = document.getElementById('loop-toggle');
      const curveSelectionDiv = document.getElementById('curve-selection');
      const rectangleSelectionDiv = document.getElementById('rectangle-selection');
      const horizontalSelectionDiv = document.getElementById('horizontal-selection');
      const verticalSelectionDiv = document.getElementById('vertical-selection');
      const lineSelectionDiv = document.getElementById('line-selection');

      // Simple Color Picker elements
      const colorPicker = document.getElementById('simple-color-picker');
      const closeColorPickerBtn = document.getElementById('simple-color-picker-close');
      const applyColorBtn = document.getElementById('color-picker-apply');
      const cancelColorBtn = document.getElementById('color-picker-cancel');
      const newColorPreview = document.getElementById('new-color');
      const originalColorPreview = document.getElementById('original-color');
      const hexInput = document.getElementById('hex-input');
      const colorCells = document.querySelectorAll('.color-cell');

      // Color picker state
      let currentEditingSwatch = null;
      let currentSelectedColor = '#000000';
      let originalColor = '#000000';

      // settings
      const force_stylus = true;

      // Initialize 
      function init() {
          setupCanvas();
          setupWebSocket();
          setupEventListeners();
          setupColorPicker();
          debugStylusEvents(); // Add stylus debugging
      }
      
      // Set up canvas size
      function setupCanvas() {
          resizeCanvas();
          window.addEventListener('resize', resizeCanvas);
      }
      
      // Resize canvas to fit window
      function resizeCanvas() {
          canvas.width = container.clientWidth;
          canvas.height = container.clientHeight;
          applyZoom();
          redrawCanvas();
      }
      
      // Apply zoom transform
      function applyZoom() {
          ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset transform
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.setTransform(zoomLevel, 0, 0, zoomLevel, 0, 0);
      }
      
      // Show error message
      function showError(message) {
          errorMessage.textContent = message;
          errorBanner.style.display = 'block';
      }
      
      // Hide error message
      function hideError() {
          errorBanner.style.display = 'none';
      }
      
      function createRequestId() {
          return shared.generateUuid();
      }
      
      // Show synchronization status
      function updateSyncStatus() {
          if (present > verifiedIndex) {
              // Some actions not yet confirmed by server
              syncStatus.textContent = "‚ü≥";
              syncStatus.style.color = "#ff9800";
          } else {
              // All actions confirmed
              syncStatus.textContent = "‚úì";
              syncStatus.style.color = "#4caf50";
          }
      }
      
      // Reconnect WebSocket
      function reconnectWebSocket() {
          if (ws) {
              ws.close();
          }
          setupWebSocket();
          hideError();
      }
      
      function setupWebSocket() {
          const urlParams = new URLSearchParams(window.location.search);
          const credential = urlParams.get('credential');
          boardId = urlParams.get('board');
          passwd = urlParams.get('passwd');

          // Determine if we're creating or registering
          const isCreating = !!credential;
          const isEditing = !!passwd;
          
          // If neither board nor credential provided, show error
          if (!boardId && !isCreating) {
              showError('Please provide credentials to create a new board.');
              return; // Don't attempt to connect
          }
          
          const hostname = window.location.hostname || 'localhost';
          const wsUrl = `ws://${hostname}:${shared.PORT}/ws`;
          
          debugLog('Connecting to WebSocket:', wsUrl);
          
          ws = new WebSocket(wsUrl);
          connectionEstablished = false;
          
          ws.onopen = () => {
              debugLog('WebSocket connection established');
              
              if (isCreating) {
                  // Send board creation request
                  createBoard(credential);
              } else if (boardId) {
                  // Register with existing board
                  registerBoard(boardId);
              }
          };
          
          ws.onclose = () => {
              debugLog('Disconnected from server');
              connectionEstablished = false;
              showError('Connection to server lost. Please reconnect.');
          };
          
          ws.onerror = (error) => {
              console.error('WebSocket error:', error);
              connectionEstablished = false;
              showError('Failed to connect to server. Please check your connection.');
          };
          
          ws.onmessage = (event) => {
              try {
                  const data = shared.deserialize(event.data);
                  debugLog('Received message:', data);
                  
                  // Handle message based on type
                  switch (data.type) {
                  case shared.MESSAGES.SERVER_TO_CLIENT.BOARD_CREATED.TYPE:
                      handleBoardCreated(data);
                      break;
                  case shared.MESSAGES.SERVER_TO_CLIENT.BOARD_REGISTERED.TYPE:
                      handleBoardRegistered(data);
                      break;
                  case shared.MESSAGES.SERVER_TO_CLIENT.FULL_PAGE.TYPE:
                      handleFullPageMessage(data);
                      break;
                  case shared.MESSAGES.SERVER_TO_CLIENT.ACCEPT.TYPE:
                      handleAcceptMessage(data);
                      break;
                  case shared.MESSAGES.SERVER_TO_CLIENT.DECLINE.TYPE:
                      handleDeclineMessage(data);
                      break;
                  case shared.MESSAGES.SERVER_TO_CLIENT.REPLAY.TYPE:
                      handleReplayMessage(data);
                      break;
                  case shared.MESSAGES.SERVER_TO_CLIENT.PING.TYPE:
                      handlePingMessage(data);
                      break;
                  case "error":
                      handleErrorMessage(data);
                      break;
                  default:
                      console.error('Unknown message type:', data.type);
                  }
              } catch (error) {
                  console.error('Error processing message:', error);
                  showError(`Error processing message: ${error.message}`);
              }
          };
      }
      
      // Handle server error message
      function handleErrorMessage(data) {
          console.error(`[SERVER ERROR] ${data.message}`, data.stack);
          showError(`Server error: ${data.message}`);
      }
      
      // Create a new board with credentials
      function createBoard(credential) {
          const requestId = createRequestId();
          
          const createMessage = {
              type: shared.MESSAGES.CLIENT_TO_SERVER.CREATE_BOARD.TYPE,
              [shared.MESSAGES.CLIENT_TO_SERVER.CREATE_BOARD.PASSWORD]: credential,
              [shared.MESSAGES.CLIENT_TO_SERVER.CREATE_BOARD.CLIENT_ID]: clientId,
              [shared.MESSAGES.CLIENT_TO_SERVER.CREATE_BOARD.REQUEST_ID]: requestId
          };
          
          debugLog('Sending board creation request:', createMessage);
          ws.send(shared.serialize(createMessage));
      }
      
      // Handle board creation response
      function handleBoardCreated(data) {
          debugLog('Board created successfully');
          connectionEstablished = true;
          hideError();
          
          const requestId = data[shared.MESSAGES.SERVER_TO_CLIENT.BOARD_CREATED.REQUEST_ID];
          
          // Reset local state
          history = [];
          present = 0;
          hashes = [];
          verifiedIndex = 0;
          visualState = shared.createEmptyVisualState();
          
          boardId = data[shared.MESSAGES.SERVER_TO_CLIENT.BOARD_CREATED.BOARD_ID];
          passwd = data[shared.MESSAGES.SERVER_TO_CLIENT.BOARD_CREATED.PASSWORD];
          const urlParams = new URLSearchParams(window.location.search);
          window.history.replaceState(null, null, `?board=${boardId}&passwd=${passwd}`);
      }
      
      // Register with an existing board
      function registerBoard(boardId) {
          const requestId = createRequestId();
          
          const registerMessage = {
              type: shared.MESSAGES.CLIENT_TO_SERVER.REGISTER_BOARD.TYPE,
              [shared.MESSAGES.CLIENT_TO_SERVER.REGISTER_BOARD.BOARD_ID]: boardId,
              [shared.MESSAGES.CLIENT_TO_SERVER.REGISTER_BOARD.CLIENT_ID]: clientId,
              [shared.MESSAGES.CLIENT_TO_SERVER.REGISTER_BOARD.REQUEST_ID]: requestId
          };
          
          debugLog('Sending board registration:', registerMessage);
          ws.send(shared.serialize(registerMessage));
      }
      
      // Handle board registration response
      function handleBoardRegistered(data) {
          debugLog('Board registered successfully');
          connectionEstablished = true;
          hideError();
          
          const requestId = data[shared.MESSAGES.SERVER_TO_CLIENT.BOARD_REGISTERED.REQUEST_ID];
          
          // Reset local state
          history = [];
          present = 0;
          hashes = [];
          verifiedIndex = 0;
          visualState = shared.createEmptyVisualState();
          
          // Update board ID and URL if necessary
          boardId = data[shared.MESSAGES.SERVER_TO_CLIENT.BOARD_REGISTERED.BOARD_ID];
          const urlParams = new URLSearchParams(window.location.search);
          
          if (urlParams.get('credential')) {
              // If we created a board, update URL to use board ID instead
              window.history.replaceState(null, null, `?board=${boardId}`);
          } else if (urlParams.get('board') !== boardId) {
              // If the board ID changed for some reason, update URL
              window.history.replaceState(null, null, `?board=${boardId}`);
          }
          
          // The server will send a full page message next, so we do not need
          // to request one explicitly
      }
      
      // Handle ping message from server

      function adjustVerfiedIndex ( snapshots ) {
          index = 0;
          the_index = 0;
          alt_index = 0;
          the_hash = hashes[ the_index ];
          alt_hash = snapshots[ alt_index ];
          while ( ( the_index <= verifiedIndex ) && ( alt_index < snapshots.length ) ) {
              if ( the_hash != alt_hash ) {
                  ++ the_index;
                  the_hash = hashes[ the_index ];
              } else {
                  index = the_index;
                  ++ alt_index;
                  ++ the_index;
              }
          }
          verifiedIndex = index;
      }

      function handlePingMessage(data) {
          const pingPageUuid = data[shared.MESSAGES.SERVER_TO_CLIENT.PING.UUID];
          const pingPageHash = data[shared.MESSAGES.SERVER_TO_CLIENT.PING.HASH];
          const pingPageNr = data[shared.MESSAGES.SERVER_TO_CLIENT.PING.PAGE_NR];
          const pingTotalPages = data[shared.MESSAGES.SERVER_TO_CLIENT.PING.TOTAL_PAGES];
          const pingSnapshots = data[shared.MESSAGES.SERVER_TO_CLIENT.PING.SNAPSHOTS];
          
          debugLog('Received ping', {
              serverPageUuid: pingPageUuid, 
              serverPageHash: pingPageHash, 
              serverPageNr: pingPageNr, 
              serverTotalPages: pingTotalPages,
              currentPageUuid: currentPageUuid,
              verifiedHash: hashes[ verifiedIndex ]
          });
          
          // Check if we are on the wrong page
          if (currentPageUuid !== pingPageUuid) {
              debugLog('Server indicates we should be on a different page');
              requestFullPage(pingPageUuid);
              return;
          }
          
          // Update page info if needed
          if (pageNr !== pingPageNr || totalPages !== pingTotalPages) {
              pageNr = pingPageNr;
              totalPages = pingTotalPages;
              updatePageInfo();
          }
          
          // Check if our hash is out of sync with server
          // Look for matching hash in our hash chain
          let matchingIndex = hashes.indexOf( pingPageHash );
          
          if (matchingIndex === -1) {
              // Server hash not found in our hash chain
              debugLog('Hash not found in our chain, requesting replay');
              adjustVerfiedIndex( pingSnapshots );
              requestReplay();
          } else if (matchingIndex !== present) {
              debugLog(`Server is at position ${matchingIndex}, we're at ${present}`);
              present = matchingIndex;
              verifiedIndex = present;
              updateVisualState();
          } else {
              // We're in sync with server
              verifiedIndex = matchingIndex;
              updateSyncStatus();
          }
      }

      // Handle accept message from server
      function handleAcceptMessage(data) {
          const acceptedActionUuid = data[shared.MESSAGES.SERVER_TO_CLIENT.ACCEPT.ACTION_UUID];
          const beforeHash = data[shared.MESSAGES.SERVER_TO_CLIENT.ACCEPT.BEFORE_HASH];
          const afterHash = data[shared.MESSAGES.SERVER_TO_CLIENT.ACCEPT.AFTER_HASH];
          
          // Check if this action is in our history
          const actionIndex = history.findIndex(action => action.uuid === acceptedActionUuid);
          
          if (actionIndex === -1) {
              // Action not found in our history - request replay
              debugLog(`Accepted action ${acceptedActionUuid} not found in our history`);
              requestReplay();
              return;
          }
          
          if (afterHash !== hashes[actionIndex+1]) {
              // Hash mismatch - request replay
              debugLog(`Hash mismatch for action ${acceptedActionUuid}`);
              requestReplay();
              return;
          }

          if (verifiedIndex <= actionIndex) {
              verifiedIndex = actionIndex + 1;
          }
          
          // Update page info
          pageNr = data[shared.MESSAGES.SERVER_TO_CLIENT.ACCEPT.CURRENT_PAGE_NR];
          totalPages = data[shared.MESSAGES.SERVER_TO_CLIENT.ACCEPT.CURRENT_TOTAL_PAGES];
          updatePageInfo();
          
          // Update UI
          updateSyncStatus();
          updateUndoRedoButtons();
      }
      
      // Handle decline message from server
      function handleDeclineMessage(data) {
          const declinedActionUuid = data[shared.MESSAGES.SERVER_TO_CLIENT.DECLINE.ACTION_UUID];
          const reason = data[shared.MESSAGES.SERVER_TO_CLIENT.DECLINE.REASON];
          
          console.error(`Server declined action ${declinedActionUuid}: ${reason}`);
          
          // Find the declined action in our history
          const actionIndex = history.findIndex(action => action.uuid === declinedActionUuid);
          
          if (actionIndex !== -1) {
              // If the action is in our history, we need to remove it and all subsequent actions
              if (actionIndex >= verifiedIndex) {
                  // Only remove unverified actions
                  history = history.slice(0, verifiedIndex);
                  hashes = hashes.slice(0, verifiedIndex + 1);
                  present = verifiedIndex;
                  
                  // Update visual state
                  updateVisualState();
                  updateUndoRedoButtons();
              }
          }
          
          // Request replay to ensure we're in sync
          requestReplay();
      }
      
      // Handle replay message from server
      function handleReplayMessage(data) {
          const pageUuid = data[shared.MESSAGES.SERVER_TO_CLIENT.REPLAY.UUID];
          const beforeHash = data[shared.MESSAGES.SERVER_TO_CLIENT.REPLAY.BEFORE_HASH];
          const afterHash = data[shared.MESSAGES.SERVER_TO_CLIENT.REPLAY.AFTER_HASH];
          const replaySequence = data[shared.MESSAGES.SERVER_TO_CLIENT.REPLAY.SEQUENCE];
          const serverPresent = data[shared.MESSAGES.SERVER_TO_CLIENT.REPLAY.PRESENT];
          const currentHash = data[shared.MESSAGES.SERVER_TO_CLIENT.REPLAY.CURRENT_HASH];
          
          // Find index where replay should start (matching beforeHash)
          let startIndex = -1;
          for (let i = 0; i < hashes.length; i++) {
              if (hashes[i] === beforeHash) {
                  startIndex = i;
                  break;
              }
          }
          
          if (startIndex === -1) {
              // Cannot find matching hash - need full page refresh
              debugLog("Replay hash not found in our chain, requesting full page", {
                  beforeHash,
                  ourHashes: hashes
              });
              requestFullPage(pageUuid);
              return;
          }
          
          // Apply replay edits to the history
          if (replaySequence && replaySequence.length > 0) {
              // Remove any conflicting history after the replay point
              history = history.slice(0, startIndex);
              hashes = hashes.slice(0, startIndex + 1);
              
              // Add the replayed actions to history
              for (let i = 0; i < replaySequence.length; i++) {
                  const action = replaySequence[i];
                  history.push(action);
                  
                  // Calculate new hash for each action
                  const lastHash = hashes[hashes.length - 1];
                  const newHash = shared.hashNext(lastHash, action);
                  hashes.push(newHash);
              }
              
              // Verify final hash matches afterHash
              const finalHash = hashes[hashes.length - 1];
              if (finalHash !== afterHash) {
                  debugLog("Hash mismatch after replay", {
                      calculatedHash: finalHash,
                      expectedHash: afterHash
                  });
                  requestFullPage(pageUuid);
                  return;
              }
          }
          
          // Update present position
          present = serverPresent;
          
          // Update verified index to match present after replay
          verifiedIndex = present;
          
          if (hashes[present] !== currentHash) {
              debugLog("Current hash mismatch after replay", {
                  ourHash: hashes[present],
                  serverHash: currentHash
              });
              requestFullPage(pageUuid);
              return;
          }
          
          // Recompile visual state
          updateVisualState();
          
          // Update page info
          pageNr = data[shared.MESSAGES.SERVER_TO_CLIENT.REPLAY.PAGE_NR];
          totalPages = data[shared.MESSAGES.SERVER_TO_CLIENT.REPLAY.TOTAL_PAGES];
          updatePageInfo();
          
          // Update UI
          updateSyncStatus();
          updateUndoRedoButtons();
          
          debugLog("Replay applied successfully", {
              historyLength: history.length,
              present: present,
              verifiedIndex: verifiedIndex
          });
      }
      
      // Handle full page message from server
      function handleFullPageMessage(data) {
          currentPageUuid = data[shared.MESSAGES.SERVER_TO_CLIENT.FULL_PAGE.UUID];
          history = data[shared.MESSAGES.SERVER_TO_CLIENT.FULL_PAGE.HISTORY];
          present = data[shared.MESSAGES.SERVER_TO_CLIENT.FULL_PAGE.PRESENT];
          hashes = [ hashAny( currentPageUuid ) ];
          for ( let i = 0; i < history.length; ++ i ) {
              hashes.push( shared.hashNext( hashes[ i ], history[ i ] ) );
          }
          debugLog( "hashes = ", `${hashes}`);
          
          // Set verified index to present
          verifiedIndex = present;
          
          // Recompile visual state
          updateVisualState();
          
          // Update page info
          pageNr = data[shared.MESSAGES.SERVER_TO_CLIENT.FULL_PAGE.PAGE_NR];
          totalPages = data[shared.MESSAGES.SERVER_TO_CLIENT.FULL_PAGE.TOTAL_PAGES];
          updatePageInfo();
          
          // Update UI
          updateSyncStatus();
          updateUndoRedoButtons();
      }
      
      // Request a full page from the server
      function requestFullPage(pageId, delta = 0) {
          const requestId = createRequestId();
          
          const request = {
              type: shared.MESSAGES.CLIENT_TO_SERVER.FULL_PAGE_REQUESTS.TYPE,
              [shared.MESSAGES.CLIENT_TO_SERVER.FULL_PAGE_REQUESTS.BOARD_UUID]: boardId
          };
          
          if (pageId) {
              request[shared.MESSAGES.CLIENT_TO_SERVER.FULL_PAGE_REQUESTS.PAGE_ID] = pageId;
          }
          
          request[shared.MESSAGES.CLIENT_TO_SERVER.FULL_PAGE_REQUESTS.DELTA] = delta;
          request[shared.MESSAGES.CLIENT_TO_SERVER.FULL_PAGE_REQUESTS.REQUEST_ID] = requestId;
          
          debugLog('Requesting full page', request);
          sendMessage(request);
      }
      
      // Request a replay from the server
      function requestReplay() {
          const requestId = createRequestId();
          
          const request = {
              type: shared.MESSAGES.CLIENT_TO_SERVER.REPLAY_REQUESTS.TYPE,
              [shared.MESSAGES.CLIENT_TO_SERVER.REPLAY_REQUESTS.PAGE_UUID]: currentPageUuid,
              [shared.MESSAGES.CLIENT_TO_SERVER.REPLAY_REQUESTS.PRESENT]: verifiedIndex,
              [shared.MESSAGES.CLIENT_TO_SERVER.REPLAY_REQUESTS.PRESENT_HASH]: hashes[verifiedIndex],
              [shared.MESSAGES.CLIENT_TO_SERVER.REPLAY_REQUESTS.REQUEST_ID]: requestId
          };
          
          debugLog('Requesting replay', request);
          sendMessage(request);
      }
      
      // Send a message to the server
      function sendMessage(message) {
          if (!connectionEstablished) {
              showError('Not connected to server');
              return false;
          }
          
          debugLog('Sending message', message);
          ws.send(shared.serialize(message));
          return true;
      }
      
      // Update visual state based on history up to present
      function updateVisualState() {
          // Create a fresh visual state
          visualState = shared.createEmptyVisualState();
          
          // Apply actions up to present
          const activeActions = history.slice(0, present);
          
          // Apply all actions to visual state
          for (const action of activeActions) {
              applyActionToVisualState(action);
          }
          
          // Redraw the canvas
          redrawCanvas();
      }
      
      // Apply a single action to the visual state
      function applyActionToVisualState(action) {
          if (!action) return;
          shared.commitEdit( visualState, action );
          return;
          
          switch (action.type) {
          case shared.MOD_ACTIONS.DRAW.TYPE:
              const stroke = action[shared.MOD_ACTIONS.DRAW.STROKE] || action.stroke;
              shared.addElement(visualState, action.uuid, stroke);
              shared.showElement(visualState, action.uuid);
              break;
              
          case shared.MOD_ACTIONS.ERASE.TYPE:
              const targetUuid = action[shared.MOD_ACTIONS.ERASE.TARGET_ACTION] || action.targetAction;
              shared.hideElement(visualState, targetUuid);
              break;
              
          case shared.MOD_ACTIONS.GROUP.TYPE:
              const actions = action[shared.MOD_ACTIONS.GROUP.ACTIONS] || action.actions;
              if (Array.isArray(actions)) {
                  for (const subAction of actions) {
                      applyActionToVisualState(subAction);
                  }
              }
              break;
          }
      }
      
      // Add stylus debugging function
      function debugStylusEvents() {
          canvas.addEventListener('pointerdown', logStylusEvent);
          canvas.addEventListener('pointermove', logStylusEvent);
          canvas.addEventListener('pointerup', logStylusEvent);
      }

      function logStylusEvent(event) {
          if (event.pointerType === 'pen') {
              console.log('Stylus Event:', {
                  type: event.type,
                  pointerType: event.pointerType,
                  pressure: event.pressure,
                  tiltX: event.tiltX,
                  tiltY: event.tiltY,
                  twist: event.twist,
                  isPrimary: event.isPrimary,
                  tool: currentTool
              });
          }
      }
      
      // Width selection
      function selectWidth () {
          const penRadius = widthSelector.value;
          draw_settings.width = parseInt(penRadius);
          // widthValue.textContent = currentWidth;
          // Update the CSS custom property on the input element
          widthSelector.style.setProperty('--thumb-size', draw_settings.width);
      };
      
      // Opacity selection
      function selectOpacity () {
          draw_settings.opacity = parseInt( opacitySelector.value ) / 128;
          opacitySelector.style.setProperty('--thumb-opacity', draw_settings.opacity);
      };
      
      // Setup Simple Color Picker
      function setupColorPicker() {
          // Setup color cell click events
          colorCells.forEach(cell => {
              cell.addEventListener('click', () => {
                  const color = cell.getAttribute('data-color');
                  selectColorInPicker(color);
              });
          });
          
          // Setup hex input
          hexInput.addEventListener('input', function() {
              let hex = this.value;
              if (hex.charAt(0) !== '#') {
                  hex = '#' + hex;
              }
              
              // Basic validation for hex format
              if (/^#([0-9A-F]{3}){1,2}$/i.test(hex)) {
                  selectColorInPicker(hex);
              }
          });
          
          // Setup buttons
          closeColorPickerBtn.addEventListener('click', closeColorPicker);
          cancelColorBtn.addEventListener('click', closeColorPicker);
          applyColorBtn.addEventListener('click', applySelectedColor);
          
          // Close picker when clicking outside
          document.addEventListener('mousedown', function(e) {
              if (colorPicker.style.display === 'block') {
                  const isClickInside = colorPicker.contains(e.target);
                  if (!isClickInside && e.target.className !== 'color-swatch') {
                      closeColorPicker();
                  }
              }
          });
      }
      
      function selectColorInPicker(color) {
          currentSelectedColor = color;
          newColorPreview.style.backgroundColor = color;
          
          // Update hex input without triggering the input event
          hexInput.value = color.toUpperCase();
      }
      
      function openColorPicker(swatch) {
          currentEditingSwatch = swatch;
          originalColor = swatch.style.backgroundColor;
          
          // Set original color preview
          originalColorPreview.style.backgroundColor = originalColor;
          
          // Set initial selected color to match the swatch
          currentSelectedColor = swatch.dataset.color;
          newColorPreview.style.backgroundColor = currentSelectedColor;
          
          // Set hex input value
          hexInput.value = currentSelectedColor;
          
          // Position the picker near the swatch
          const swatchRect = swatch.getBoundingClientRect();
          colorPicker.style.left = (swatchRect.right + 10) + 'px';
          colorPicker.style.top = swatchRect.top + 'px';
          
          // Show the picker
          colorPicker.style.display = 'block';
          
          // Make sure the picker is fully visible
          const pickerRect = colorPicker.getBoundingClientRect();
          const viewportWidth = window.innerWidth;
          const viewportHeight = window.innerHeight;
          
          // Adjust horizontal position if needed
          if (pickerRect.right > viewportWidth) {
              colorPicker.style.left = (swatchRect.left - pickerRect.width - 10) + 'px';
          }
          
          // Adjust vertical position if needed
          if (pickerRect.bottom > viewportHeight) {
              colorPicker.style.top = (viewportHeight - pickerRect.height - 10) + 'px';
          }
      }
      
      function closeColorPicker() {
          colorPicker.style.display = 'none';
          currentEditingSwatch = null;
      }
      
      function applySelectedColor() {
          if (currentEditingSwatch) {
              // Update the swatch with the new color
              currentEditingSwatch.style.backgroundColor = currentSelectedColor;
              currentEditingSwatch.dataset.color = currentSelectedColor;
              
              // If this is the active swatch, update the current tool settings
              if (currentEditingSwatch.classList.contains('active')) {
                  draw_settings.color = currentSelectedColor;
                  updateKnobs();
              }
              
              // Close the picker
              closeColorPicker();
          }
      }
      
      // Set up event listeners
      function setupEventListeners() {
          // Reconnect button
          reconnectButton.addEventListener('click', reconnectWebSocket);
          
          // Tool selection
          document.getElementById('chalk-tool').addEventListener('click', () => setTool('chalk'));
          document.getElementById('pen-tool').addEventListener('click', () => setTool('pen'));
          document.getElementById('highlighter-tool').addEventListener('click', () => setTool('highlighter'));
          document.getElementById('eraser-tool').addEventListener('click', () => setTool('eraser'));
          
          // Color selection
          const colorSwatches = document.querySelectorAll('.color-swatch');
          colorSwatches.forEach(swatch => {
              // For normal click - select color
              swatch.addEventListener('click', function() {
                  document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('active'));
                  this.classList.add('active');
                  draw_settings.color = this.dataset.color;
                  updateKnobs();
              });
              
              // For long press - open color picker
              let pressTimer;
              swatch.addEventListener('pointerdown', function(e) {
                  pressTimer = setTimeout(() => {
                      openColorPicker(this);
                  }, 500); // 500ms for long press
              });
              
              swatch.addEventListener('pointerup', function() {
                  clearTimeout(pressTimer);
              });
              
              swatch.addEventListener('pointerleave', function() {
                  clearTimeout(pressTimer);
              });
          });
          
          widthSelector.addEventListener('input', selectWidth);
          opacitySelector.addEventListener('input', selectOpacity);

          document.getElementById('timer-btn').addEventListener('click', () => {
              draw_settings.undo = ( draw_settings.tool != "eraser" ) && ! draw_settings.undo;
              updateKnobs();
          });
          
          document.getElementById('loop-btn').addEventListener('click', () => {
              draw_settings.loop = ( ! draw_settings.loop );
              updateKnobs();
          });
          
          document.getElementById('fill-btn').addEventListener('click', () => {
              draw_settings.fill = ( ! draw_settings.fill );
              updateKnobs();
          });
          
          document.getElementById('curve-btn').addEventListener('click', () => {
              set_shape_tool( 'curve' );
              update_shape_buttons();
          });
          
          document.getElementById('rectangle-btn').addEventListener('click', () => {
              set_shape_tool( 'rectangle' );
              update_shape_buttons();
          });
          
          document.getElementById('horizontal-btn').addEventListener('click', () => {
              set_shape_tool( 'horizontal' );
              update_shape_buttons();
          });
          
          document.getElementById('vertical-btn').addEventListener('click', () => {
              set_shape_tool( 'vertical' );
              update_shape_buttons();
          });
          
          document.getElementById('line-btn').addEventListener('click', () => {
              set_shape_tool( 'line' );
              update_shape_buttons();
          });
          
          // Page navigation
          document.getElementById('prev-page').addEventListener('click', () => navigatePage(-1));
          document.getElementById('next-page').addEventListener('click', () => navigatePage(1));
          document.getElementById('add-page').addEventListener('click', addNewPage);
          document.getElementById('delete-page').addEventListener('click', deletePage);
          
          // Zoom controls
          document.getElementById('zoom-in').addEventListener('click', () => adjustZoom(0.1));
          document.getElementById('zoom-out').addEventListener('click', () => adjustZoom(-0.1));
          
          // Undo/Redo buttons
          undoBtn.addEventListener('click', handleUndo);
          redoBtn.addEventListener('click', handleRedo);
          
          // Debug button
          document.getElementById('debug-btn').addEventListener('click', showDebugInfo);
          
          // Export PDF button
          document.getElementById('pdf-btn').addEventListener('click', exportPageToPDF);
          
          // Canvas events
          canvas.addEventListener('pointerdown', handlePointerDown);
          canvas.addEventListener('pointermove', handlePointerMove);
          canvas.addEventListener('pointerup', handlePointerUp);
          canvas.addEventListener('pointerleave', handlePointerUp);
          
          // Prevent default touch behaviors
          canvas.addEventListener('touchstart', e => e.preventDefault());
          canvas.addEventListener('touchmove', e => e.preventDefault());
          canvas.addEventListener('touchend', e => e.preventDefault());
          
          // Keyboard shortcuts
          document.addEventListener('keydown', handleKeyDown);
      }
      
      // Show debug information
      function showDebugInfo() {
          console.log('=== DEBUG INFO ===');
          console.log('Page UUID:', currentPageUuid);
          console.log('History Length:', history.length);
          console.log('Present:', present);
          console.log('Verified Index:', verifiedIndex);
          console.log('Hashes:', hashes);
          console.log('Visual State:', visualState);
          
          alert(`Debug info in console.\nHistory: ${history.length} actions\nPresent: ${present}\nVerified: ${verifiedIndex}`);
      }
      
      // Handle keyboard shortcuts
      function handleKeyDown(e) {
          // Undo: Ctrl+Z
          if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
              e.preventDefault();
              if (!undoBtn.disabled) {
                  handleUndo();
              }
          }
          // Redo: Ctrl+Y or Ctrl+Shift+Z
          else if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
              e.preventDefault();
              if (!redoBtn.disabled) {
                  handleRedo();
              }
          }
      }
      
      // Update undo/redo button states
      function updateUndoRedoButtons() {
          // Undo is available if we have actions in history before our present position
          undoBtn.disabled = present === 0;
          
          // Redo is available if we have actions in history after our present position
          redoBtn.disabled = present >= history.length;
      }
      
      // Handle undo action
      function handleUndo() {
          if (present === 0) return;
          
          const actionToUndo = history[present - 1];
          const undoUuid = shared.generateUuid();
          
          const undoAction = {
              type: shared.MOD_ACTIONS.UNDO.TYPE,
              [shared.MOD_ACTIONS.UUID]: undoUuid,
              [shared.MOD_ACTIONS.UNDO.TARGET_ACTION]: actionToUndo[shared.MOD_ACTIONS.UUID]
          };
          
          // Create proposal
          const proposal = {
              type: shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.TYPE,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PASSWORD]: passwd,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAGE_UUID]: currentPageUuid,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD]: undoAction,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.BEFORE_HASH]: hashes[present]
          };
          
          // Apply locally first (optimistic update)
          present--;
          
          // Update visual state and UI
          updateVisualState();
          updateUndoRedoButtons();
          updateSyncStatus();
          
          // Send to server
          sendMessage(proposal);
      }
      
      // Handle redo action
      function handleRedo() {
          if (present >= history.length) return;
          
          const actionToRedo = history[present];
          const redoUuid = shared.generateUuid();
          
          const redoAction = {
              type: shared.MOD_ACTIONS.REDO.TYPE,
              [shared.MOD_ACTIONS.UUID]: redoUuid,
              [shared.MOD_ACTIONS.REDO.TARGET_ACTION]: actionToRedo[shared.MOD_ACTIONS.UUID]
          };
          
          // Create proposal
          const proposal = {
              type: shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.TYPE,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PASSWORD]: passwd,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAGE_UUID]: currentPageUuid,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD]: redoAction,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.BEFORE_HASH]: hashes[present]
          };
          
          // Apply locally first (optimistic update)
          present++;
          
          // Update visual state and UI
          updateVisualState();
          updateUndoRedoButtons();
          updateSyncStatus();
          
          // Send to server
          sendMessage(proposal);
      }
      
      // Set current tool
      function setTool(tool) {
          currentTool = tool;
          
          // Update UI
          // document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
          document.getElementById('chalk-tool').classList.remove('active');
          document.getElementById('pen-tool').classList.remove('active');
          document.getElementById('highlighter-tool').classList.remove('active');
          document.getElementById('eraser-tool').classList.remove('active');
          document.getElementById(`${tool}-tool`).classList.add('active');
          
          // Update cursor
          switch (tool) {
          case 'chalk':
              canvas.style.cursor = 'crosshair';
              switch_settings( chalk_settings );
              set_pointer_handler( shape_to_ph( chalk_settings.shape ) );
              break;
          case 'pen':
              canvas.style.cursor = 'crosshair';
              switch_settings( pen_settings );
              set_pointer_handler( shape_to_ph( pen_settings.shape ) );
              break;
          case 'highlighter':
              canvas.style.cursor = 'crosshair';
              switch_settings( highlighter_settings );
              set_pointer_handler( shape_to_ph( highlighter_settings.shape ) );
              break;
          case 'eraser':
              canvas.style.cursor = 'cell';
              switch_settings( eraser_settings );
              set_pointer_handler( erase_path_pointer_handler );
              break;
          }
      }
      
      // Adjust zoom level
      function adjustZoom(delta) {
          zoomLevel = Math.max(0.5, Math.min(3, zoomLevel + delta));
          zoomLevelDisplay.textContent = `${Math.round(zoomLevel * 100)}%`;
          applyZoom();
          redrawCanvas();
      }
      
      // Update page info display
      function updatePageInfo() {
          pageInfo.textContent = `Page ${pageNr} of ${totalPages}`;
      }
      
      const draw_path_pointer_handler = {
          down: () => {
              if ( force_stylus && event.pointerType === "touch" ) { return; }
              const rect = canvas.getBoundingClientRect();
              const x = (event.clientX - rect.left) / zoomLevel;
              const y = (event.clientY - rect.top) / zoomLevel;
              const pressure = event.pressure !== undefined ? event.pressure : 0.5;
              currentPath = [];
              const point = shared.createPoint(x, y, pressure);
              currentPath.push(point);
              isDrawing = true;
              currentStroke = shared.createStroke( draw_settings.stroke );
              if ( draw_settings.loop ) {
                  currentStroke[shared.ELEMENT.PATH] = shared.DRAWABLE.PATH.CLOSED_PIECEWISE_LINEAR;
              } else {
                  currentStroke[shared.ELEMENT.PATH] = shared.DRAWABLE.PATH.OPEN_PIECEWISE_LINEAR;
              }
              if ( draw_settings.fill ) {
                  currentStroke[shared.ELEMENT.TYPE] = shared.DRAWABLE.TYPE.FILL;
              } else {
                  currentStroke[shared.ELEMENT.TYPE] = shared.DRAWABLE.TYPE.STROKE;
              }
              currentStroke[shared.ELEMENT.COLOR] = draw_settings.color;
              currentStroke[shared.ELEMENT.WIDTH] = draw_settings.width;
              currentStroke[shared.ELEMENT.OPACITY] = draw_settings.opacity;
              currentStroke[shared.ELEMENT.POINTS] = currentPath;
          },
          move: () => {
              if ( force_stylus && event.pointerType === "touch" ) { return; }
              if (!isDrawing) return;
              const rect = canvas.getBoundingClientRect();
              const x = (event.clientX - rect.left) / zoomLevel;
              const y = (event.clientY - rect.top) / zoomLevel;
              const pressure = event.pressure !== undefined ? event.pressure : 0.5;
              const point = shared.createPoint(x, y, pressure);
              currentPath.push(point);
              currentStroke[shared.ELEMENT.POINTS] = currentPath;
              redrawCanvas();
          },
          up: () => {
              if ( force_stylus && event.pointerType === "touch" ) { return; }
              if (isDrawing) {
                  isDrawing = false;
                  if (currentPath.length >= 1) {
                      const actionId = sendDrawAction(currentStroke);
                      if ( draw_settings.undo ) {
                          setTimeout( sendGroupEraseAction, 3000, [ actionId ] );
                      }
                  }
              }
              currentPath = [];
              currentStroke = null;
          }
      };

      const erase_path_pointer_handler = {
          down: () => {
              if ( force_stylus && event.pointerType === "touch" ) { return; }
              const rect = canvas.getBoundingClientRect();
              const x = (event.clientX - rect.left) / zoomLevel;
              const y = (event.clientY - rect.top) / zoomLevel;
              const pressure = event.pressure !== undefined ? event.pressure : 0.5;
              currentPath = [];
              const point = shared.createPoint(x, y, pressure);
              currentPath.push(point);
              isErasing = true;
              currentStroke = shared.createStroke( shared.STROKE_STYLES.PEN );
              currentStroke[shared.ELEMENT.WIDTH] = draw_settings.width;
              currentStroke[shared.ELEMENT.COLOR] = '#FF0000'; // Red for visibility during erasing
              currentStroke[shared.ELEMENT.OPACITY] = 0.3; // Transparent so we can see what is being erased
              currentStroke[shared.ELEMENT.POINTS] = currentPath;
          },
          move: () => {
              if ( force_stylus && event.pointerType === "touch" ) { return; }
              if (!isErasing) return;
              const rect = canvas.getBoundingClientRect();
              const x = (event.clientX - rect.left) / zoomLevel;
              const y = (event.clientY - rect.top) / zoomLevel;
              const pressure = event.pressure !== undefined ? event.pressure : 0.5;
              const point = shared.createPoint(x, y, pressure);
              currentPath.push(point);
              currentStroke[shared.ELEMENT.POINTS] = currentPath;
              redrawCanvas();
          },
          up: () => {
              if ( force_stylus && event.pointerType === "touch" ) { return; }
              if (isErasing) {
                  isErasing = false;
                  if (currentPath.length >= 1) {
                      const elementsToErase = findElementsIntersectingPath(currentStroke);
                      if (elementsToErase.length > 0) {
                          sendGroupEraseAction(elementsToErase);
                      } else {
                          updateVisualState();
                      }
                  }
              }
              currentPath = [];
              currentStroke = null;
          }
      };

      let A = [ 0, 0, 0, 0 ];
      let B = [ 0, 0, 0, 0 ];
      
      function bbox_path ( A, B ) {
          const xmin = Math.min( A[0], B[0] );
          const xmax = Math.max( A[0], B[0] );
          const ymin = Math.min( A[1], B[1] );
          const ymax = Math.max( A[1], B[1] );
          return [ shared.createPoint( xmin, ymax, 0.5 ),
                   shared.createPoint( xmin, ymin, 0.5 ),
                   shared.createPoint( xmax, ymin, 0.5 ),
                   shared.createPoint( xmax, ymax, 0.5 ) ];                   
      }

      function vertical_path ( A, B ) {
          return [ shared.createPoint( B[0], A[1], 0.5 ),
                   shared.createPoint( B[0], B[1], 0.5 ) ];
      }

      function horizontal_path ( A, B ) {
          return [ shared.createPoint( A[0], B[1], 0.5 ),
                   shared.createPoint( B[0], B[1], 0.5 ) ];
      }

      function straight_path ( A, B ) {
          return [ shared.createPoint( A[0], A[1], A[2] ),
                   shared.createPoint( B[0], B[1], B[2] ) ];
      }

      function draw_shape_pointer_handler ( make_path ) {
          const result = {
              down: () => {
                  if ( force_stylus && event.pointerType === "touch" ) { return; }
                  const rect = canvas.getBoundingClientRect();
                  const x = (event.clientX - rect.left) / zoomLevel;
                  const y = (event.clientY - rect.top) / zoomLevel;
                  const pressure = event.pressure !== undefined ? event.pressure : 0.5;
                  currentPath = [];
                  const point = shared.createPoint(x, y, pressure);
                  currentPath.push(point);
                  isDrawing = true;
                  currentStroke = shared.createStroke( draw_settings.stroke );
                  currentStroke[shared.ELEMENT.PATH] = shared.DRAWABLE.PATH.CLOSED_PIECEWISE_LINEAR;
                  if ( draw_settings.fill ) {
                      currentStroke[shared.ELEMENT.TYPE] = shared.DRAWABLE.TYPE.FILL;
                  } else {
                      currentStroke[shared.ELEMENT.TYPE] = shared.DRAWABLE.TYPE.STROKE;
                  }
                  currentStroke[shared.ELEMENT.COLOR] = draw_settings.color;
                  currentStroke[shared.ELEMENT.WIDTH] = draw_settings.width;
                  currentStroke[shared.ELEMENT.OPACITY] = draw_settings.opacity;
                  currentStroke[shared.ELEMENT.POINTS] = [ point, point, point, point ];
                  A = point;
              },
              move: () => {
                  if ( force_stylus && event.pointerType === "touch" ) { return; }
                  if (!isDrawing) return;
                  const rect = canvas.getBoundingClientRect();
                  const x = (event.clientX - rect.left) / zoomLevel;
                  const y = (event.clientY - rect.top) / zoomLevel;
                  const pressure = event.pressure !== undefined ? event.pressure : 0.5;
                  const point = shared.createPoint(x, y, pressure);
                  B = point;
                  currentPath = make_path( A, B );
                  currentStroke[shared.ELEMENT.POINTS] = currentPath;
                  redrawCanvas();
              },
              up: () => {
                  if ( force_stylus && event.pointerType === "touch" ) { return; }
                  if (isDrawing) {
                      isDrawing = false;
                      if (currentPath.length >= 1) {
                          const actionId = sendDrawAction(currentStroke);
                          if ( draw_settings.undo ) {
                              setTimeout( sendGroupEraseAction, 3000, [ actionId ] );
                          }
                      }
                  }
                  currentPath = [];
                  currentStroke = null;
              }
          };
          return result;
      }

      const draw_rectangle_pointer_handler = draw_shape_pointer_handler( bbox_path );
      const draw_horizontal_pointer_handler = draw_shape_pointer_handler( horizontal_path );
      const draw_vertical_pointer_handler = draw_shape_pointer_handler( vertical_path );
      const draw_line_pointer_handler = draw_shape_pointer_handler( straight_path );

      let pointer_handler = draw_path_pointer_handler;

      function set_pointer_handler ( ph ) {
          pointer_handler = ph;
      };


      function handlePointerDown(event) {
          pointer_handler.down();
      }
      
      function handlePointerMove(event) {
          pointer_handler.move();
      }

      function handlePointerUp() {
          pointer_handler.up();
      }

      function update_shape_buttons () {
          switch ( draw_settings.shape ) {
          case 'curve':
              document.getElementById('curve-btn').classList.add('active');
              document.getElementById('rectangle-btn').classList.remove('active');
              document.getElementById('horizontal-btn').classList.remove('active');
              document.getElementById('vertical-btn').classList.remove('active');
              document.getElementById('line-btn').classList.remove('active');
              break;
          case 'rectangle':
              document.getElementById('curve-btn').classList.remove('active');
              document.getElementById('rectangle-btn').classList.add('active');
              document.getElementById('horizontal-btn').classList.remove('active');
              document.getElementById('vertical-btn').classList.remove('active');
              document.getElementById('line-btn').classList.remove('active');
              break;
          case 'horizontal':
              document.getElementById('curve-btn').classList.remove('active');
              document.getElementById('rectangle-btn').classList.remove('active');
              document.getElementById('horizontal-btn').classList.add('active');
              document.getElementById('vertical-btn').classList.remove('active');
              document.getElementById('line-btn').classList.remove('active');
              break;
          case 'vertical':
              document.getElementById('curve-btn').classList.remove('active');
              document.getElementById('rectangle-btn').classList.remove('active');
              document.getElementById('horizontal-btn').classList.remove('active');
              document.getElementById('vertical-btn').classList.add('active');
              document.getElementById('line-btn').classList.remove('active');
              break;
          case 'line':
              document.getElementById('curve-btn').classList.remove('active');
              document.getElementById('rectangle-btn').classList.remove('active');
              document.getElementById('horizontal-btn').classList.remove('active');
              document.getElementById('vertical-btn').classList.remove('active');
              document.getElementById('line-btn').classList.add('active');
              break;
          }
      }

      function shape_to_ph ( shape ) {
          switch ( shape ) {
          case 'curve':
              return draw_path_pointer_handler;
          case 'rectangle':
              return draw_rectangle_pointer_handler;
          case 'horizontal':
              return draw_horizontal_pointer_handler;
          case 'vertical':
              return draw_vertical_pointer_handler;
          case 'line':
              return draw_line_pointer_handler;
          }
      }

      function set_shape_tool ( shape ) {
          draw_settings.shape = shape;
          set_pointer_handler( shape_to_ph( draw_settings.shape ) );
          update_shape_buttons();
      }

      
      // Find elements that intersect with a complete eraser path
      function findElementsIntersectingPath(eraserStroke) {
          const result = shared.findIntersectingElements(visualState, eraserStroke, eraserRadius/2, 10);
          console.log("erasing:", serialize( result ) );
          return result;
      }
      
      // Send a draw action to the server
      function sendDrawAction(stroke) {
          const actionUuid = shared.generateUuid();
          
          const drawAction = {
              type: shared.MOD_ACTIONS.DRAW.TYPE,
              [shared.MOD_ACTIONS.UUID]: actionUuid,
              [shared.MOD_ACTIONS.DRAW.STROKE]: stroke
          };
          
          // If we're in the middle of history (after undoing), truncate future actions
          if (present < history.length) {
              history = history.slice(0, present);
              hashes = hashes.slice(0, present + 1);
          }
          
          // Add to history and advance present
          history.push(drawAction);
          present++;
          
          // Calculate placeholder hash
          const placeholderHash = shared.generateUuid(); // Will be replaced with server hash when confirmed
          hashes.push(placeholderHash);
          
          // Create proposal
          const proposal = {
              type: shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.TYPE,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PASSWORD]: passwd,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAGE_UUID]: currentPageUuid,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD]: drawAction,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.BEFORE_HASH]: hashes[present - 1]
          };
          
          // Update visual state
          updateVisualState();
          
          // Update UI
          updateUndoRedoButtons();
          updateSyncStatus();
          
          // Send to server
          sendMessage(proposal);
          return actionUuid;
      }
      
      // Create a single erase action for a target
      function createEraseAction(targetUuid) {
          const actionUuid = shared.generateUuid();
          return {
              type: shared.MOD_ACTIONS.ERASE.TYPE,
              [shared.MOD_ACTIONS.UUID]: actionUuid,
              [shared.MOD_ACTIONS.ERASE.TARGET_ACTION]: targetUuid
          };
      }
      
      // Send a group of erase actions as a single group action
      function sendGroupEraseAction(targetUuids) {
          if (targetUuids.length === 0) return;
          
          const groupUuid = shared.generateUuid();
          
          // Create individual erase actions for each target
          const eraseActions = targetUuids.map(targetUuid => createEraseAction(targetUuid));
          
          // Create a group action containing all erase actions
          const groupAction = {
              type: shared.MOD_ACTIONS.GROUP.TYPE,
              [shared.MOD_ACTIONS.UUID]: groupUuid,
              [shared.MOD_ACTIONS.GROUP.ACTIONS]: eraseActions
          };
          
          // If we're in the middle of history (after undoing), truncate future actions
          if (present < history.length) {
              history = history.slice(0, present);
              hashes = hashes.slice(0, present + 1);
          }
          
          // Add to history and advance present
          history.push(groupAction);
          present++;
          
          // Calculate placeholder hash
          const placeholderHash = shared.generateUuid(); // Will be replaced with server hash when confirmed
          hashes.push(placeholderHash);
          
          // Create proposal
          const proposal = {
              type: shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.TYPE,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PASSWORD]: passwd,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAGE_UUID]: currentPageUuid,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD]: groupAction,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.BEFORE_HASH]: hashes[present - 1]
          };
          
          // Update visual state and UI
          updateVisualState();
          updateUndoRedoButtons();
          updateSyncStatus();
          
          // Send to server
          sendMessage(proposal);
      }
      
      // Add a new page
      function addNewPage() {
          const actionUuid = shared.generateUuid();
          
          const newPageAction = {
              type: shared.MOD_ACTIONS.NEW_PAGE.TYPE,
              [shared.MOD_ACTIONS.UUID]: actionUuid
          };
          
          // Create proposal
          const proposal = {
              type: shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.TYPE,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PASSWORD]: passwd,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAGE_UUID]: currentPageUuid,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD]: newPageAction,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.BEFORE_HASH]: hashes[present]
          };
          
          // Send to server - no optimistic update for page operations
          sendMessage(proposal);
      }
      
      // Delete current page
      function deletePage() {
          const actionUuid = shared.generateUuid();
          const deletePageAction = {
              type: shared.MOD_ACTIONS.DELETE_PAGE.TYPE,
              [shared.MOD_ACTIONS.UUID]: actionUuid
          };
          const proposal = {
              type: shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.TYPE,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PASSWORD]: passwd,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAGE_UUID]: currentPageUuid,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD]: deletePageAction,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.BEFORE_HASH]: hashes[present]
          };
          sendMessage(proposal);
      }
      
      // Navigate to next/previous page
      function navigatePage(delta) {
          // Request full page with delta
          requestFullPage(currentPageUuid, delta);
      }
      
      // Redraw the canvas
      function redrawCanvas() {
          ctx.save();
          ctx.setTransform(1, 0, 0, 1, 0, 0);
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.restore();

          function push_settings(element) {
              const transform = element[shared.ELEMENT.TRANSFORM];
              ctx.transform(
                  transform[shared.TRANSFORM.A],
                  transform[shared.TRANSFORM.B],
                  transform[shared.TRANSFORM.C],
                  transform[shared.TRANSFORM.D],
                  transform[shared.TRANSFORM.E],
                  transform[shared.TRANSFORM.F]
              );

              // style
              ctx.strokeStyle = element[shared.ELEMENT.COLOR];
              ctx.fillStyle = element[shared.ELEMENT.COLOR];
              ctx.lineWidth = element[shared.ELEMENT.WIDTH];
              ctx.globalAlpha = element[shared.ELEMENT.OPACITY];
              
              // Cap and join styles
              ctx.lineCap = shared.CAP_STYLE_STRINGS[element[shared.ELEMENT.CAP_STYLE]];
              ctx.lineJoin = shared.JOIN_STYLE_STRINGS[element[shared.ELEMENT.JOIN_STYLE]];
              
              // Dash pattern
              const dashPattern = element[shared.ELEMENT.DASH_PATTERN];
              if (dashPattern && dashPattern.length > 1) {
                  ctx.setLineDash(dashPattern);
              } else {
                  ctx.setLineDash([]);
              }
          }

          function lay_path(element) {
              const points = element[shared.ELEMENT.POINTS];
              ctx.beginPath();
              ctx.moveTo(points[0][shared.POINT.X], points[0][shared.POINT.Y]);
              for (let i = 1; i < points.length; i++) {
                  const point = points[i];
                  ctx.lineTo(point[shared.POINT.X], point[shared.POINT.Y]);
              }
          }

          function draw_open(element) {
              const points = element[shared.ELEMENT.POINTS];
              ctx.miterLimit = 2;
              if ( 1 == points.length ) {
                  ctx.beginPath();
                  ctx.moveTo(points[0][shared.POINT.X], points[0][shared.POINT.Y]);
                  ctx.lineWidth = element[shared.ELEMENT.WIDTH] * ( 1 + element[shared.ELEMENT.SENSITIVITY] / 2 );
                  ctx.lineTo(points[0][shared.POINT.X]+0.0001, points[0][shared.POINT.Y]);
                  ctx.stroke();
              } else if ( 0.03 > element[shared.ELEMENT.SENSITIVITY] ) {
                  ctx.beginPath();
                  ctx.moveTo(points[0][shared.POINT.X], points[0][shared.POINT.Y]);
                  ctx.lineWidth = element[shared.ELEMENT.WIDTH];
                  for (let i = 1; i < points.length; i++) {
                      const point = points[i];
                      ctx.lineTo(point[shared.POINT.X], point[shared.POINT.Y]);
                  }
                  ctx.stroke();
              } else {
                  for (let i = 1; i < points.length; i++) {
                      ctx.beginPath();
                      ctx.moveTo(points[i-1][shared.POINT.X], points[i-1][shared.POINT.Y]);
                      const point = points[i];
                      const pressure = point[shared.POINT.PRESSURE];
                      const pressureEffect = ( 1 + pressure * element[shared.ELEMENT.SENSITIVITY] );
                      ctx.lineWidth = element[shared.ELEMENT.WIDTH] * pressureEffect;
                      ctx.lineTo(point[shared.POINT.X], point[shared.POINT.Y]);
                      ctx.stroke();
                  }
              }
          }

          function draw_closed(element) {
              lay_path(element);
              ctx.closePath();
              ctx.lineWidth = element[shared.ELEMENT.WIDTH];
              ctx.stroke();
          }

          
          // Custom render function for shared.render_all_visible_elements
          function renderElement(element) {
              if (!element) return;
              ctx.save();
              push_settings(element);
              const type = element[ELEMENT.TYPE];
              const path = element[ELEMENT.PATH];
              const is_closed = ( path == DRAWABLE.PATH.CLOSED_PIECEWISE_LINEAR || path == DRAWABLE.PATH.CLOSED_BEZIER_CURVE );
              lay_path(element);
              if ( type == DRAWABLE.TYPE.FILL ) {
                  if ( ! is_closed ) {
                      console.error('Only closed paths can be filled.',"");
                      throw new Error('Only closed paths can be filled.');
                  }
                  lay_path(element);
                  ctx.closePath();
                  ctx.fill()
              } else if ( type == DRAWABLE.TYPE.STROKE ) {
                  if ( is_closed ) {
                      draw_closed(element);
                  } else {
                      draw_open(element);
                  }
              } else {
                  // If we get here, it is a bug - assertion would fail in production code
                  console.error('Unknown drawable type:', type);
                  throw new Error('Invalid drawable type');
              }
              ctx.restore();
          }
          
          // Render all visible elements
          shared.render_all_visible_elements(visualState, renderElement);
          
          // Draw current stroke if we're drawing or erasing
          if ((isDrawing || isErasing) && currentStroke) {
              renderElement(currentStroke);
          }
      }

      
      /**
       * Generates a timestamp string suitable for a filename.
       * Format: YYYY-MM-DD_HH-MM-SS
       * @returns {string} The formatted timestamp string.
       */
      function getTimestampForFilename() {
          const now = new Date();
          const year = now.getFullYear();
          const month = (now.getMonth() + 1).toString().padStart(2, '0');
          const day = now.getDate().toString().padStart(2, '0');
          const hours = now.getHours().toString().padStart(2, '0');
          const minutes = now.getMinutes().toString().padStart(2, '0');
          const seconds = now.getSeconds().toString().padStart(2, '0');
          
          return `${year}-${month}-${day}_${hours}-${minutes}-${seconds}`;
      }
      

      // export current page to pdf

      function exportPageToPDF () {
          try {
              const timestamp = getTimestampForFilename();
              const doc = new window.jspdf.jsPDF('l', 'px', [canvas.width, canvas.height]);
              doc.addImage(canvas.toDataURL('image/png', 1.0), 'PNG', 0, 0, canvas.width, canvas.height);
              doc.save(`board_${boardId}_page_${pageNr}_${timestamp}.pdf`);
          } catch (err) {
              throw new Error(`PDF export failed: ${err.message}`);
          }
      };

      
      // Initialize the app
      window.addEventListener('DOMContentLoaded', init);

      updateKnobs();
      update_shape_buttons();
    </script>
  </body>
</html>
