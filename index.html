<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Xournal++ Clone</title>
    <link rel="manifest" href="data:application/manifest+json,%7B%22name%22%3A%22Whiteboard%20App%22%2C%22short_name%22%3A%22Whiteboard%22%2C%22start_url%22%3A%22.%22%2C%22display%22%3A%22standalone%22%2C%22background_color%22%3A%22%23ffffff%22%2C%22theme_color%22%3A%22%23000000%22%2C%22icons%22%3A%5B%7B%22src%22%3A%22data%3Aimage%2Fsvg%2Bxml%2C%253Csvg%2520xmlns%253D%2522http%253A%252F%252Fwww.w3.org%252F2000%252Fsvg%2522%2520viewBox%253D%25220%25200%2520100%2520100%2522%253E%253Cpath%2520d%253D%2522M25%252075%2520L75%252025%2520M25%252025%2520L75%252075%22%2520stroke%253D%2522black%2522%2520stroke-width%253D%252210%2522%2520%252F%253E%253C%252Fsvg%253E%22%2C%22sizes%22%3A%22192x192%22%2C%22type%22%3A%22image%2Fsvg%2Bxml%22%7D%5D%7D">
    <style>
      body {
          margin: 0;
          padding: 0;
          font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
          overflow: hidden;
          display: flex; /* Make body a flex container */
          flex-direction: column; /* Stack children vertically */
          height: 100vh;
      }
      
      .toolbar {
          display: flex;
          background-color: #f0f0f0;
          padding: 5px;
          border-bottom: 1px solid #ccc;
      }
      
      .tool-section {
          display: flex;
          align-items: center;
          margin-right: 10px;
          padding-right: 10px;
          border-right: 1px solid #ddd;
      }

      .tool-btn {
          width: 30px;
          height: 30px;
          margin: 0 2px;
          cursor: pointer;
          border: 1px solid transparent;
          background-color: transparent;
          border-radius: 4px;
      }
      
      .tool-btn:hover {
          background-color: #e0e0e0;
      }

      .tool-btn:disabled {
          opacity: 0.5;
          cursor: not-allowed;
      }
      
      .tool-btn.active {
          border-color: #3498db;
          background-color: #ebf5fb;
      }
      
      .color-swatch {
          width: 12px;
          height: 12px;
          border-radius: 50%;
          margin: 3px;
          cursor: pointer;
          border: 1px solid #ccc;
      }
      
      .color-swatch.active {
          width: 18px;
          height: 18px;
          /* border-color: #333; */
          /* border-width: 6px; */
      }
      
      /* Base slider styles */
      input[type="range"] {
          -webkit-appearance: none;
          width: 100px; /* Swap width and height for vertical layout */
          height: 8px;
          background: #d3d3d3;
          outline: none;
          opacity: 0.7;
          transition: opacity .2s;
      }
      
      input[type="range"]::-webkit-slider-thumb {
          -webkit-appearance: none;
          appearance: none;
          border-radius: 50%;
          background: var(--thumb-color, black);
          cursor: pointer;
          width: calc(var(--thumb-size, 2) * 2px); 
          height: calc(var(--thumb-size, 2) * 2px);
      }
      
      input[type="range"]::-moz-range-thumb {
          border: none;
          border-radius: 50%;
          background: var(--thumb-color, black);
          cursor: pointer;
          width: calc(var(--thumb-size, 2) * 2px);
          height: calc(var(--thumb-size, 2) * 2px);
      }
      
      /* Specific styles for the opacity slider */
      #opacity-selector {
          background: #fff;
      }
      
      #opacity-selector::-webkit-slider-thumb {
          width: 24px;
          height: 24px;
          background: var(--thumb-color);
          opacity: var(--thumb-opacity, 1);
      }
      
      #opacity-selector::-moz-range-thumb {
          width: 24px;
          height: 24px;
          background: var(--thumb-color);
          filter: opacity( var(--thumb-opacity, 1));
      }
      
      #debug-tools {
          margin-left: auto;
      }

      .app-container {
          display: flex;
          flex-grow: 1;
      }
      
      .sidebar {
          width: 50px; /* Reduced width for a more compact sidebar */
          background-color: #f0f0f0;
          border-right: 1px solid #ccc;
          padding: 4px 0px;
          display: flex;
          flex-direction: column;
          align-items: center;
      }

      .sidebar-section {
          width: 100%;
          box-sizing: border-box;
          display: flex;
          flex-direction: column;
          align-items: center; /* Center content within each section */
          padding: 4px 0px;
          margin-bottom: 10px;
          border-bottom: 1px solid #ddd;
      }
      
      .sidebar-section:last-child {
          border-bottom: none;
      }

      #width-selection, #opacity-selection {
          /* Apply styles to the individual slider sections */
          height: 120px; /* Give the containers enough space to hold the rotated sliders */
          justify-content: center;
      }
      
      #width-selector, #opacity-selector {
          transform: rotate(90deg); /* Rotate the sliders */
          transform-origin: 50% 50%; /* Ensure rotation is centered */
      }

      .main-content {
          flex-grow: 1;
          overflow: hidden;
      }
      
      #canvas-container {
          position: relative;
          width: 100%;
          height: 100%;
      }
      
      canvas {
          position: absolute;
          background-color: white;
          box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
      }

      .page-controls {
          display: flex;
          align-items: center;
      }
      
      #page-info {
          margin: 0 10px;
      }
      
      .error-banner {
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          background-color: #f44336;
          color: white;
          padding: 15px;
          text-align: center;
          z-index: 1000;
          display: none;
      }
      
      .error-banner button {
          margin-left: 15px;
          background-color: white;
          color: #f44336;
          border: none;
          padding: 5px 10px;
          cursor: pointer;
          border-radius: 4px;
      }

      .tooltip {
          position: relative;
          display: inline-block;
      }

      .tooltip .tooltiptext {
          visibility: hidden;
          width: 120px;
          background-color: #555;
          color: #fff;
          text-align: center;
          border-radius: 6px;
          padding: 5px;
          position: absolute;
          z-index: 1;
          bottom: 125%;
          left: 50%;
          margin-left: -60px;
          opacity: 0;
          transition: opacity 0.3s;
          font-size: 12px;
      }

      .tooltip:hover .tooltiptext {
          visibility: visible;
          opacity: 1;
      }

      /* Custom Color Picker Styles */
      #color-picker-overlay {
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background-color: rgba(0, 0, 0, 0.5);
          z-index: 1000;
          display: none;
          justify-content: center;
          align-items: center;
      }

      #color-picker {
          background-color: white;
          border-radius: 8px;
          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
          padding: 16px;
          width: 300px;
          max-width: 90vw;
          display: flex;
          flex-direction: column;
          position: relative;
      }

      #color-picker-header {
          display: flex;
          justify-content: space-between;
          align-items: center;
          margin-bottom: 12px;
      }

      #color-picker-title {
          font-weight: bold;
          margin: 0;
      }

      #color-picker-close {
          background: none;
          border: none;
          font-size: 18px;
          cursor: pointer;
          padding: 4px;
      }

      #color-preview {
          display: flex;
          margin-bottom: 12px;
          height: 40px;
          border-radius: 4px;
          overflow: hidden;
      }

      #new-color-preview {
          flex: 3;
      }

      #original-color-preview {
          flex: 1;
          border-left: 1px solid #ccc;
      }

      .color-selection-area {
          margin-bottom: 16px;
      }

      #hue-canvas, #saturation-canvas {
          width: 100%;
          border-radius: 4px;
          cursor: crosshair;
      }

      #hue-canvas {
          height: 20px;
          margin-bottom: 12px;
      }

      #saturation-canvas {
          height: 150px;
      }

      .color-input-group {
          display: flex;
          margin-bottom: 12px;
      }

      .color-input {
          display: flex;
          flex-direction: column;
          margin-right: 8px;
          flex: 1;
      }

      .color-input:last-child {
          margin-right: 0;
      }

      .color-input label {
          font-size: 12px;
          margin-bottom: 4px;
      }

      .color-input input {
          width: 100%;
          padding: 4px;
          border: 1px solid #ccc;
          border-radius: 4px;
      }

      #color-picker-actions {
          display: flex;
          justify-content: flex-end;
      }

      #color-picker-actions button {
          padding: 8px 16px;
          border-radius: 4px;
          cursor: pointer;
          margin-left: 8px;
      }

      #color-picker-cancel {
          background-color: #f1f1f1;
          border: 1px solid #ccc;
      }

      #color-picker-apply {
          background-color: #3498db;
          color: white;
          border: none;
      }

      /* Opacity slider in color picker */
      #opacity-container {
          margin-bottom: 12px;
      }

      #opacity-slider {
          width: 100%;
          height: 20px;
          background: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAIAAADZF8uwAAAAGUlEQVQYV2M4gwH+YwCGIasIUwhT25BVBADtzYNYrHvv4gAAAABJRU5ErkJggg==');
          background-repeat: repeat;
          border-radius: 4px;
          position: relative;
      }

      #opacity-gradient {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          border-radius: 4px;
      }

      #opacity-input {
          -webkit-appearance: none;
          width: 100%;
          height: 20px;
          background: transparent;
          outline: none;
          margin: 0;
          padding: 0;
          position: relative;
          z-index: 2;
      }

      #opacity-input::-webkit-slider-thumb {
          -webkit-appearance: none;
          appearance: none;
          width: 20px;
          height: 20px;
          background: white;
          cursor: pointer;
          border: 1px solid #ccc;
          border-radius: 50%;
      }

      #opacity-input::-moz-range-thumb {
          width: 20px;
          height: 20px;
          background: white;
          cursor: pointer;
          border: 1px solid #ccc;
          border-radius: 50%;
      }
    </style>
  </head>
  <body>
    <div class="error-banner" id="error-banner">
      <span id="error-message">Connection error</span>
      <button id="reconnect-button">Reconnect</button>
    </div>
    
    <div class="toolbar">
      <div class="tool-section" id="export-pdf">
        <button class="tool-btn" id="pdf-btn" title="export-pdf">📃</button>
      </div>

      <div class="tool-section page-controls">
        <button class="tool-btn" id="prev-page">◀️</button>
        <span id="page-info">Page 1 of 1</span>
        <button class="tool-btn" id="next-page">▶️</button>
        <button class="tool-btn" id="add-page">➕</button>
        <button class="tool-btn" id="delete-page">➖</button>
      </div>
      
      <div class="tool-section">
        <button class="tool-btn" id="zoom-out">-</button>
        <span id="zoom-level">100%</span>
        <button class="tool-btn" id="zoom-in">+</button>
      </div>
      
      <div class="tool-section">
        <button class="tool-btn tooltip" id="undo-btn" title="Undo" disabled>↩
          <span class="tooltiptext">Undo (Ctrl+Z)</span>
        </button>
        <button class="tool-btn tooltip" id="redo-btn" title="Redo" disabled>↪
          <span class="tooltiptext">Redo (Ctrl+Y)</span>
        </button>
      </div>
      
      <div class="tool-section">
        <button class="tool-btn" id="chalk-tool" title="Chalk"><span style="filter: grayscale(100%) invert(100%);">🖍️</span></button>
        <button class="tool-btn active" id="pen-tool" title="Pen">✏️</button>
        <button class="tool-btn" id="highlighter-tool" title="Highlighter">🖌️</button>
        <button class="tool-btn" id="eraser-tool" title="Eraser">🧽</button>
      </div>
      
      <div class="tool-section" id="debug-tools">
        <button class="tool-btn" id="debug-btn" title="Debug">🐞</button>
        <span id="sync-status">✓</span>
      </div>
    </div>
    
    <div class="app-container">
      <div class="sidebar">
        <div class="tool-section sidebar-section" id="color-selection">
          <div class="color-swatch" style="background-color: black;" data-color="black"></div>
          <div class="color-swatch" style="background-color: red;" data-color="red"></div>
          <div class="color-swatch" style="background-color: green;" data-color="green"></div>
          <div class="color-swatch" style="background-color: blue;" data-color="blue"></div>
          <div class="color-swatch" style="background-color: yellow;" data-color="yellow"></div>
          <div class="color-swatch" style="background-color: cyan;" data-color="cyan"></div>
          <div class="color-swatch" style="background-color: magenta;" data-color="magenta"></div>
          <div class="color-swatch" style="background-color: white;" data-color="white"></div>
        </div>
        <div class="tool-section sidebar-section" id="width-selection">
          <input type="range" id="width-selector" min="1" max="20">
        </div>
        <div class="tool-section sidebar-section" id="opacity-selection">
          <input type="range" id="opacity-selector" min="0" max="128">
        </div>
        <div class="tool-section sidebar-section" id="timer-toggle">
          <button class="tool-btn" id="timer-btn" title="Timer">⏲</button>
        </div>
      </div>
      
      <div class="main-content">
        <div id="canvas-container">
          <canvas id="canvas"></canvas>
        </div>
      </div>
    </div>

    <!-- Custom Color Picker -->
    <div id="color-picker-overlay">
      <div id="color-picker">
        <div id="color-picker-header">
          <h3 id="color-picker-title">Color Picker</h3>
          <button id="color-picker-close">×</button>
        </div>
        
        <div id="color-preview">
          <div id="new-color-preview"></div>
          <div id="original-color-preview"></div>
        </div>
        
        <div class="color-selection-area">
          <canvas id="hue-canvas" height="20"></canvas>
          <canvas id="saturation-canvas" height="150"></canvas>
        </div>
        
        <div id="opacity-container">
          <div id="opacity-slider">
            <div id="opacity-gradient"></div>
            <input type="range" id="opacity-input" min="0" max="100" value="100">
          </div>
        </div>
        
        <div class="color-input-group">
          <div class="color-input">
            <label for="hex-input">Hex</label>
            <input type="text" id="hex-input" maxlength="9">
          </div>
        </div>
        
        <div class="color-input-group">
          <div class="color-input">
            <label for="r-input">R</label>
            <input type="number" id="r-input" min="0" max="255">
          </div>
          <div class="color-input">
            <label for="g-input">G</label>
            <input type="number" id="g-input" min="0" max="255">
          </div>
          <div class="color-input">
            <label for="b-input">B</label>
            <input type="number" id="b-input" min="0" max="255">
          </div>
        </div>
        
        <div id="color-picker-actions">
          <button id="color-picker-cancel">Cancel</button>
          <button id="color-picker-apply">Apply</button>
        </div>
      </div>
    </div>

    <script src="shared.js"></script>
    <script src="https://www.kubux.net/files/nodejs-libs/jspdf.umd.min.js"></script>
    <script>
      // Debug logging function
      function debugLog(msg, data) {
          console.log(`[DEBUG] ${msg}`, data || '');
      };

      const manifest = {
          "name": "Whiteboard App",
          "short_name": "Whiteboard",
          "start_url": ".",
          "display": "standalone",
          "background_color": "#ffffff",
          "theme_color": "#000000",
          "icons": [
              {
                  "src": "data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20viewBox%3D%220%200%20100%20100%22%3E%3Cpath%20d%3D%22M25%2075%20L75%2025%20M25%2025%20L75%2075%22%20stroke%3D%22black%22%20stroke-width%3D%2210%22%20%2F%3E%3C%2Fsvg%3E",
                  "sizes": "192x192",
                  "type": "image/svg+xml"
              }
          ]
      };
      
      const manifest_json = JSON.stringify(manifest);
      const encoded_manifest = encodeURIComponent(manifest_json);
      const data_uri = `data:application/manifest+json,${encoded_manifest}`;

      // settings
      let eraser_settings = {
          tool: "eraser",
          opacity: 0.3,
          color: "#ff0000",
          undo: false,
          width: 2
      };
      let pen_settings = {
          tool: "pen", 
          opacity: 1.0,
          width: 2,
          color: "#000000",
          undo: false,
          stroke: shared.createStroke( shared.STROKE_STYLES.PEN )
      };
      let chalk_settings = {
          tool: "chalk",
          opacity: 1.0,
          width: 3,
          color: "#000000",
          undo: false,
          stroke: shared.createStroke( shared.STROKE_STYLES.CHALK )
      };
      let highlighter_settings = {
          tool: "highlighter",
          opacity: 0.2,
          width: 24,
          color: "yellow",
          undo: true,
          stroke: shared.createStroke( shared.STROKE_STYLES.HIGHLIGHTER )
      };

      let draw_settings = chalk_settings;

      function stroke_from_settings () {
          currentStroke = [...draw_settings.stroke];
          currentStroke[shared.ELEMENT.WIDTH] = draw_settings.width;
          currentStroke[shared.ELEMENT.COLOR] = draw_settings.color;
          currentStroke[shared.ELEMENT.OPACITY] = draw_settings.opacity;
      };

      function updateKnobs () {
          widthSelector.style.setProperty('--thumb-size', draw_settings.width);
          widthSelector.style.setProperty('--thumb-color', draw_settings.color);
          widthSelector.value = draw_settings.width;
          opacitySelector.style.setProperty('--thumb-opacity', draw_settings.opacity);
          opacitySelector.style.setProperty('--thumb-color', draw_settings.color);
          opacitySelector.value =  draw_settings.opacity * 128;
          if ( draw_settings.undo ) {
              document.getElementById('timer-btn').classList.add('active');
          } else {
              document.getElementById('timer-btn').classList.remove('active');
          }
      }

      function switch_settings ( the_settings ) {
          draw_settings = the_settings;
          updateKnobs();
          switch (draw_settings.tool) {
          case 'pen':
          case 'chalk':
          case 'highlighter':
              colorSelectionDiv.style.display = 'flex';
              widthSelectionDiv.style.display = 'flex';
              opacitySelectionDiv .style.display = 'flex';
              timerToggleDiv.style.display = 'flex';
              break;
          case 'eraser':
              colorSelectionDiv.style.display = 'none';
              widthSelectionDiv.style.display = 'flex';
              opacitySelectionDiv .style.display = 'none';
              timerToggleDiv.style.display = 'none';
              break;
          }
      };

      // Globals for board state
      let ws = null;
      let boardId = null;
      let passwd = null; // needed for edits
      let clientId = shared.generateUuid(); // Unique client identifier
      let currentPageUuid = null;
      let pageNr = 1;
      let totalPages = 1;
      let connectionEstablished = false;
      
      // Drawing state
      let isDrawing = false;
      let isErasing = false;
      let currentPath = [];
      let currentStroke = null;
      
      // Timeline state with complete hash chain
      let history = [];          // All actions in timeline
      let present = 0;           // Current position in timeline
      let hashes = [];           // Hash chain for all states
      let verifiedIndex = 0;     // Last index confirmed by server
      
      // Visual state
      let visualState = shared.createEmptyVisualState();
      
      // Zoom state
      let zoomLevel = 1;
      
      // Tool state
      let currentTool = 'pen';
      let eraserRadius = 20;
      let currentColor = '#000000';
      let currentWidth = 2;
      let currentOpacity = 1.0;
      
      // DOM elements
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');
      const container = document.getElementById('canvas-container');
      const widthSelector = document.getElementById('width-selector');
      // const widthValue = document.getElementById('width-value');
      const opacitySelector = document.getElementById('opacity-selector');
      // const opacityValue = document.getElementById('opacity-value');
      const zoomLevelDisplay = document.getElementById('zoom-level');
      const pageInfo = document.getElementById('page-info');
      const errorBanner = document.getElementById('error-banner');
      const errorMessage = document.getElementById('error-message');
      const reconnectButton = document.getElementById('reconnect-button');
      const undoBtn = document.getElementById('undo-btn');
      const redoBtn = document.getElementById('redo-btn');
      const syncStatus = document.getElementById('sync-status');

      const colorSelectionDiv = document.getElementById('color-selection');
      const widthSelectionDiv = document.getElementById('width-selection');
      const opacitySelectionDiv = document.getElementById('opacity-selection');
      const timerToggleDiv = document.getElementById('timer-toggle');

      // Custom Color Picker Elements
      const colorPickerOverlay = document.getElementById('color-picker-overlay');
      const colorPicker = document.getElementById('color-picker');
      const hueCanvas = document.getElementById('hue-canvas');
      const saturationCanvas = document.getElementById('saturation-canvas');
      const opacityInput = document.getElementById('opacity-input');
      const opacityGradient = document.getElementById('opacity-gradient');
      const hexInput = document.getElementById('hex-input');
      const rInput = document.getElementById('r-input');
      const gInput = document.getElementById('g-input');
      const bInput = document.getElementById('b-input');
      const newColorPreview = document.getElementById('new-color-preview');
      const originalColorPreview = document.getElementById('original-color-preview');
      const applyButton = document.getElementById('color-picker-apply');
      const cancelButton = document.getElementById('color-picker-cancel');
      const closeButton = document.getElementById('color-picker-close');

      // settings
      const force_stylus = true;
      
      // Initialize 
      function init() {
          setupCanvas();
          setupWebSocket();
          setupEventListeners();
          setupColorPicker();
          debugStylusEvents(); // Add stylus debugging
      }
      
      // Set up canvas size
      function setupCanvas() {
          resizeCanvas();
          window.addEventListener('resize', resizeCanvas);
      }
      
      // Resize canvas to fit window
      function resizeCanvas() {
          canvas.width = container.clientWidth;
          canvas.height = container.clientHeight;
          applyZoom();
          redrawCanvas();
      }
      
      // Apply zoom transform
      function applyZoom() {
          ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset transform
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.setTransform(zoomLevel, 0, 0, zoomLevel, 0, 0);
      }
      
      // Show error message
      function showError(message) {
          errorMessage.textContent = message;
          errorBanner.style.display = 'block';
      }
      
      // Hide error message
      function hideError() {
          errorBanner.style.display = 'none';
      }
      
      function createRequestId() {
          return shared.generateUuid();
      }
      
      // Show synchronization status
      function updateSyncStatus() {
          if (present > verifiedIndex) {
              // Some actions not yet confirmed by server
              syncStatus.textContent = "⟳";
              syncStatus.style.color = "#ff9800";
          } else {
              // All actions confirmed
              syncStatus.textContent = "✓";
              syncStatus.style.color = "#4caf50";
          }
      }
      
      // Reconnect WebSocket
      function reconnectWebSocket() {
          if (ws) {
              ws.close();
          }
          setupWebSocket();
          hideError();
      }
      
      function setupWebSocket() {
          const urlParams = new URLSearchParams(window.location.search);
          const credential = urlParams.get('credential');
          boardId = urlParams.get('board');
          passwd = urlParams.get('passwd');

          // Determine if we're creating or registering
          const isCreating = !!credential;
          const isEditing = !!passwd;
          
          // If neither board nor credential provided, show error
          if (!boardId && !isCreating) {
              showError('Please provide credentials to create a new board.');
              return; // Don't attempt to connect
          }
          
          const hostname = window.location.hostname || 'localhost';
          const wsUrl = `ws://${hostname}:${shared.PORT}/ws`;
          
          debugLog('Connecting to WebSocket:', wsUrl);
          
          ws = new WebSocket(wsUrl);
          connectionEstablished = false;
          
          ws.onopen = () => {
              debugLog('WebSocket connection established');
              
              if (isCreating) {
                  // Send board creation request
                  createBoard(credential);
              } else if (boardId) {
                  // Register with existing board
                  registerBoard(boardId);
              }
          };
          
          ws.onclose = () => {
              debugLog('Disconnected from server');
              connectionEstablished = false;
              showError('Connection to server lost. Please reconnect.');
          };
          
          ws.onerror = (error) => {
              console.error('WebSocket error:', error);
              connectionEstablished = false;
              showError('Failed to connect to server. Please check your connection.');
          };
          
          ws.onmessage = (event) => {
              try {
                  const data = shared.deserialize(event.data);
                  debugLog('Received message:', data);
                  
                  // Handle message based on type
                  switch (data.type) {
                  case shared.MESSAGES.SERVER_TO_CLIENT.BOARD_CREATED.TYPE:
                      handleBoardCreated(data);
                      break;
                  case shared.MESSAGES.SERVER_TO_CLIENT.BOARD_REGISTERED.TYPE:
                      handleBoardRegistered(data);
                      break;
                  case shared.MESSAGES.SERVER_TO_CLIENT.FULL_PAGE.TYPE:
                      handleFullPageMessage(data);
                      break;
                  case shared.MESSAGES.SERVER_TO_CLIENT.ACCEPT.TYPE:
                      handleAcceptMessage(data);
                      break;
                  case shared.MESSAGES.SERVER_TO_CLIENT.DECLINE.TYPE:
                      handleDeclineMessage(data);
                      break;
                  case shared.MESSAGES.SERVER_TO_CLIENT.REPLAY.TYPE:
                      handleReplayMessage(data);
                      break;
                  case shared.MESSAGES.SERVER_TO_CLIENT.PING.TYPE:
                      handlePingMessage(data);
                      break;
                  case "error":
                      handleErrorMessage(data);
                      break;
                  default:
                      console.error('Unknown message type:', data.type);
                  }
              } catch (error) {
                  console.error('Error processing message:', error);
                  showError(`Error processing message: ${error.message}`);
              }
          };
      }
      
      // Handle server error message
      function handleErrorMessage(data) {
          console.error(`[SERVER ERROR] ${data.message}`, data.stack);
          showError(`Server error: ${data.message}`);
      }
      
      // Create a new board with credentials
      function createBoard(credential) {
          const requestId = createRequestId();
          
          const createMessage = {
              type: shared.MESSAGES.CLIENT_TO_SERVER.CREATE_BOARD.TYPE,
              [shared.MESSAGES.CLIENT_TO_SERVER.CREATE_BOARD.PASSWORD]: credential,
              [shared.MESSAGES.CLIENT_TO_SERVER.CREATE_BOARD.CLIENT_ID]: clientId,
              [shared.MESSAGES.CLIENT_TO_SERVER.CREATE_BOARD.REQUEST_ID]: requestId
          };
          
          debugLog('Sending board creation request:', createMessage);
          ws.send(shared.serialize(createMessage));
      }
      
      // Handle board creation response
      function handleBoardCreated(data) {
          debugLog('Board created successfully');
          connectionEstablished = true;
          hideError();
          
          const requestId = data[shared.MESSAGES.SERVER_TO_CLIENT.BOARD_CREATED.REQUEST_ID];
          
          // Reset local state
          history = [];
          present = 0;
          hashes = [];
          verifiedIndex = 0;
          visualState = shared.createEmptyVisualState();
          
          boardId = data[shared.MESSAGES.SERVER_TO_CLIENT.BOARD_CREATED.BOARD_ID];
          passwd = data[shared.MESSAGES.SERVER_TO_CLIENT.BOARD_CREATED.PASSWORD];
          const urlParams = new URLSearchParams(window.location.search);
          window.history.replaceState(null, null, `?board=${boardId}&passwd=${passwd}`);
      }
      
      // Register with an existing board
      function registerBoard(boardId) {
          const requestId = createRequestId();
          
          const registerMessage = {
              type: shared.MESSAGES.CLIENT_TO_SERVER.REGISTER_BOARD.TYPE,
              [shared.MESSAGES.CLIENT_TO_SERVER.REGISTER_BOARD.BOARD_ID]: boardId,
              [shared.MESSAGES.CLIENT_TO_SERVER.REGISTER_BOARD.CLIENT_ID]: clientId,
              [shared.MESSAGES.CLIENT_TO_SERVER.REGISTER_BOARD.REQUEST_ID]: requestId
          };
          
          debugLog('Sending board registration:', registerMessage);
          ws.send(shared.serialize(registerMessage));
      }
      
      // Handle board registration response
      function handleBoardRegistered(data) {
          debugLog('Board registered successfully');
          connectionEstablished = true;
          hideError();
          
          const requestId = data[shared.MESSAGES.SERVER_TO_CLIENT.BOARD_REGISTERED.REQUEST_ID];
          
          // Reset local state
          history = [];
          present = 0;
          hashes = [];
          verifiedIndex = 0;
          visualState = shared.createEmptyVisualState();
          
          // Update board ID and URL if necessary
          boardId = data[shared.MESSAGES.SERVER_TO_CLIENT.BOARD_REGISTERED.BOARD_ID];
          const urlParams = new URLSearchParams(window.location.search);
          
          if (urlParams.get('credential')) {
              // If we created a board, update URL to use board ID instead
              window.history.replaceState(null, null, `?board=${boardId}`);
          } else if (urlParams.get('board') !== boardId) {
              // If the board ID changed for some reason, update URL
              window.history.replaceState(null, null, `?board=${boardId}`);
          }
          
          // The server will send a full page message next, so we do not need
          // to request one explicitly
      }
      
      // Handle ping message from server

      function adjustVerfiedIndex ( snapshots ) {
          index = 0;
          the_index = 0;
          alt_index = 0;
          the_hash = hashes[ the_index ];
          alt_hash = snapshots[ alt_index ];
          while ( ( the_index <= verifiedIndex ) && ( alt_index < snapshots.length ) ) {
              if ( the_hash != alt_hash ) {
                  ++ the_index;
                  the_hash = hashes[ the_index ];
              } else {
                  index = the_index;
                  ++ alt_index;
                  ++ the_index;
              }
          }
          verifiedIndex = index;
      }

      function handlePingMessage(data) {
          const pingPageUuid = data[shared.MESSAGES.SERVER_TO_CLIENT.PING.UUID];
          const pingPageHash = data[shared.MESSAGES.SERVER_TO_CLIENT.PING.HASH];
          const pingPageNr = data[shared.MESSAGES.SERVER_TO_CLIENT.PING.PAGE_NR];
          const pingTotalPages = data[shared.MESSAGES.SERVER_TO_CLIENT.PING.TOTAL_PAGES];
          const pingSnapshots = data[shared.MESSAGES.SERVER_TO_CLIENT.PING.SNAPSHOTS];
          
          debugLog('Received ping', {
              serverPageUuid: pingPageUuid, 
              serverPageHash: pingPageHash, 
              serverPageNr: pingPageNr, 
              serverTotalPages: pingTotalPages,
              currentPageUuid: currentPageUuid,
              verifiedHash: hashes[ verifiedIndex ]
          });
          
          // Check if we are on the wrong page
          if (currentPageUuid !== pingPageUuid) {
              debugLog('Server indicates we should be on a different page');
              requestFullPage(pingPageUuid);
              return;
          }
          
          // Update page info if needed
          if (pageNr !== pingPageNr || totalPages !== pingTotalPages) {
              pageNr = pingPageNr;
              totalPages = pingTotalPages;
              updatePageInfo();
          }
          
          // Check if our hash is out of sync with server
          // Look for matching hash in our hash chain
          let matchingIndex = hashes.indexOf( pingPageHash );
          
          if (matchingIndex === -1) {
              // Server hash not found in our hash chain
              debugLog('Hash not found in our chain, requesting replay');
              adjustVerfiedIndex( pingSnapshots );
              requestReplay();
          } else if (matchingIndex !== present) {
              debugLog(`Server is at position ${matchingIndex}, we're at ${present}`);
              present = matchingIndex;
              verifiedIndex = present;
              updateVisualState();
          } else {
              // We're in sync with server
              verifiedIndex = matchingIndex;
              updateSyncStatus();
          }
      }

      // Handle accept message from server
      function handleAcceptMessage(data) {
          const acceptedActionUuid = data[shared.MESSAGES.SERVER_TO_CLIENT.ACCEPT.ACTION_UUID];
          const beforeHash = data[shared.MESSAGES.SERVER_TO_CLIENT.ACCEPT.BEFORE_HASH];
          const afterHash = data[shared.MESSAGES.SERVER_TO_CLIENT.ACCEPT.AFTER_HASH];
          
          // Check if this action is in our history
          const actionIndex = history.findIndex(action => action.uuid === acceptedActionUuid);
          
          if (actionIndex === -1) {
              // Action not found in our history - request replay
              debugLog(`Accepted action ${acceptedActionUuid} not found in our history`);
              requestReplay();
              return;
          }
          
          if (afterHash !== hashes[actionIndex+1]) {
              // Hash mismatch - request replay
              debugLog(`Hash mismatch for action ${acceptedActionUuid}`);
              requestReplay();
              return;
          }

          if (verifiedIndex <= actionIndex) {
              verifiedIndex = actionIndex + 1;
          }
          
          // Update page info
          pageNr = data[shared.MESSAGES.SERVER_TO_CLIENT.ACCEPT.CURRENT_PAGE_NR];
          totalPages = data[shared.MESSAGES.SERVER_TO_CLIENT.ACCEPT.CURRENT_TOTAL_PAGES];
          updatePageInfo();
          
          // Update UI
          updateSyncStatus();
          updateUndoRedoButtons();
      }
      
      // Handle decline message from server
      function handleDeclineMessage(data) {
          const declinedActionUuid = data[shared.MESSAGES.SERVER_TO_CLIENT.DECLINE.ACTION_UUID];
          const reason = data[shared.MESSAGES.SERVER_TO_CLIENT.DECLINE.REASON];
          
          console.error(`Server declined action ${declinedActionUuid}: ${reason}`);
          
          // Find the declined action in our history
          const actionIndex = history.findIndex(action => action.uuid === declinedActionUuid);
          
          if (actionIndex !== -1) {
              // If the action is in our history, we need to remove it and all subsequent actions
              if (actionIndex >= verifiedIndex) {
                  // Only remove unverified actions
                  history = history.slice(0, verifiedIndex);
                  hashes = hashes.slice(0, verifiedIndex + 1);
                  present = verifiedIndex;
                  
                  // Update visual state
                  updateVisualState();
                  updateUndoRedoButtons();
              }
          }
          
          // Request replay to ensure we're in sync
          requestReplay();
      }
      
      // Handle replay message from server
      function handleReplayMessage(data) {
          const pageUuid = data[shared.MESSAGES.SERVER_TO_CLIENT.REPLAY.UUID];
          const beforeHash = data[shared.MESSAGES.SERVER_TO_CLIENT.REPLAY.BEFORE_HASH];
          const afterHash = data[shared.MESSAGES.SERVER_TO_CLIENT.REPLAY.AFTER_HASH];
          const replaySequence = data[shared.MESSAGES.SERVER_TO_CLIENT.REPLAY.SEQUENCE];
          const serverPresent = data[shared.MESSAGES.SERVER_TO_CLIENT.REPLAY.PRESENT];
          const currentHash = data[shared.MESSAGES.SERVER_TO_CLIENT.REPLAY.CURRENT_HASH];
          
          // Find index where replay should start (matching beforeHash)
          let startIndex = -1;
          for (let i = 0; i < hashes.length; i++) {
              if (hashes[i] === beforeHash) {
                  startIndex = i;
                  break;
              }
          }
          
          if (startIndex === -1) {
              // Cannot find matching hash - need full page refresh
              debugLog("Replay hash not found in our chain, requesting full page", {
                  beforeHash,
                  ourHashes: hashes
              });
              requestFullPage(pageUuid);
              return;
          }
          
          // Apply replay edits to the history
          if (replaySequence && replaySequence.length > 0) {
              // Remove any conflicting history after the replay point
              history = history.slice(0, startIndex);
              hashes = hashes.slice(0, startIndex + 1);
              
              // Add the replayed actions to history
              for (let i = 0; i < replaySequence.length; i++) {
                  const action = replaySequence[i];
                  history.push(action);
                  
                  // Calculate new hash for each action
                  const lastHash = hashes[hashes.length - 1];
                  const newHash = shared.hashNext(lastHash, action);
                  hashes.push(newHash);
              }
              
              // Verify final hash matches afterHash
              const finalHash = hashes[hashes.length - 1];
              if (finalHash !== afterHash) {
                  debugLog("Hash mismatch after replay", {
                      calculatedHash: finalHash,
                      expectedHash: afterHash
                  });
                  requestFullPage(pageUuid);
                  return;
              }
          }
          
          // Update present position
          present = serverPresent;
          
          // Update verified index to match present after replay
          verifiedIndex = present;
          
          if (hashes[present] !== currentHash) {
              debugLog("Current hash mismatch after replay", {
                  ourHash: hashes[present],
                  serverHash: currentHash
              });
              requestFullPage(pageUuid);
              return;
          }
          
          // Recompile visual state
          updateVisualState();
          
          // Update page info
          pageNr = data[shared.MESSAGES.SERVER_TO_CLIENT.REPLAY.PAGE_NR];
          totalPages = data[shared.MESSAGES.SERVER_TO_CLIENT.REPLAY.TOTAL_PAGES];
          updatePageInfo();
          
          // Update UI
          updateSyncStatus();
          updateUndoRedoButtons();
          
          debugLog("Replay applied successfully", {
              historyLength: history.length,
              present: present,
              verifiedIndex: verifiedIndex
          });
      }
      
      // Handle full page message from server
      function handleFullPageMessage(data) {
          currentPageUuid = data[shared.MESSAGES.SERVER_TO_CLIENT.FULL_PAGE.UUID];
          history = data[shared.MESSAGES.SERVER_TO_CLIENT.FULL_PAGE.HISTORY];
          present = data[shared.MESSAGES.SERVER_TO_CLIENT.FULL_PAGE.PRESENT];
          hashes = [ hashAny( currentPageUuid ) ];
          for ( let i = 0; i < history.length; ++ i ) {
              hashes.push( shared.hashNext( hashes[ i ], history[ i ] ) );
          }
          debugLog( "hashes = ", `${hashes}`);
          
          // Set verified index to present
          verifiedIndex = present;
          
          // Recompile visual state
          updateVisualState();
          
          // Update page info
          pageNr = data[shared.MESSAGES.SERVER_TO_CLIENT.FULL_PAGE.PAGE_NR];
          totalPages = data[shared.MESSAGES.SERVER_TO_CLIENT.FULL_PAGE.TOTAL_PAGES];
          updatePageInfo();
          
          // Update UI
          updateSyncStatus();
          updateUndoRedoButtons();
      }
      
      // Request a full page from the server
      function requestFullPage(pageId, delta = 0) {
          const requestId = createRequestId();
          
          const request = {
              type: shared.MESSAGES.CLIENT_TO_SERVER.FULL_PAGE_REQUESTS.TYPE,
              [shared.MESSAGES.CLIENT_TO_SERVER.FULL_PAGE_REQUESTS.BOARD_UUID]: boardId
          };
          
          if (pageId) {
              request[shared.MESSAGES.CLIENT_TO_SERVER.FULL_PAGE_REQUESTS.PAGE_ID] = pageId;
          }
          
          request[shared.MESSAGES.CLIENT_TO_SERVER.FULL_PAGE_REQUESTS.DELTA] = delta;
          request[shared.MESSAGES.CLIENT_TO_SERVER.FULL_PAGE_REQUESTS.REQUEST_ID] = requestId;
          
          debugLog('Requesting full page', request);
          sendMessage(request);
      }
      
      // Request a replay from the server
      function requestReplay() {
          const requestId = createRequestId();
          
          const request = {
              type: shared.MESSAGES.CLIENT_TO_SERVER.REPLAY_REQUESTS.TYPE,
              [shared.MESSAGES.CLIENT_TO_SERVER.REPLAY_REQUESTS.PAGE_UUID]: currentPageUuid,
              [shared.MESSAGES.CLIENT_TO_SERVER.REPLAY_REQUESTS.PRESENT]: verifiedIndex,
              [shared.MESSAGES.CLIENT_TO_SERVER.REPLAY_REQUESTS.PRESENT_HASH]: hashes[verifiedIndex],
              [shared.MESSAGES.CLIENT_TO_SERVER.REPLAY_REQUESTS.REQUEST_ID]: requestId
          };
          
          debugLog('Requesting replay', request);
          sendMessage(request);
      }
      
      // Send a message to the server
      function sendMessage(message) {
          if (!connectionEstablished) {
              showError('Not connected to server');
              return false;
          }
          
          debugLog('Sending message', message);
          ws.send(shared.serialize(message));
          return true;
      }
      
      // Update visual state based on history up to present
      function updateVisualState() {
          // Create a fresh visual state
          visualState = shared.createEmptyVisualState();
          
          // Apply actions up to present
          const activeActions = history.slice(0, present);
          
          // Apply all actions to visual state
          for (const action of activeActions) {
              applyActionToVisualState(action);
          }
          
          // Redraw the canvas
          redrawCanvas();
      }
      
      // Apply a single action to the visual state
      function applyActionToVisualState(action) {
          if (!action) return;
          shared.commitEdit( visualState, action );
          return;
          
          switch (action.type) {
          case shared.MOD_ACTIONS.DRAW.TYPE:
              const stroke = action[shared.MOD_ACTIONS.DRAW.STROKE] || action.stroke;
              shared.addElement(visualState, action.uuid, stroke);
              shared.showElement(visualState, action.uuid);
              break;
              
          case shared.MOD_ACTIONS.ERASE.TYPE:
              const targetUuid = action[shared.MOD_ACTIONS.ERASE.TARGET_ACTION] || action.targetAction;
              shared.hideElement(visualState, targetUuid);
              break;
              
          case shared.MOD_ACTIONS.GROUP.TYPE:
              const actions = action[shared.MOD_ACTIONS.GROUP.ACTIONS] || action.actions;
              if (Array.isArray(actions)) {
                  for (const subAction of actions) {
                      applyActionToVisualState(subAction);
                  }
              }
              break;
          }
      }
      
      // Add stylus debugging function
      function debugStylusEvents() {
          canvas.addEventListener('pointerdown', logStylusEvent);
          canvas.addEventListener('pointermove', logStylusEvent);
          canvas.addEventListener('pointerup', logStylusEvent);
      }

      function logStylusEvent(event) {
          if (event.pointerType === 'pen') {
              console.log('Stylus Event:', {
                  type: event.type,
                  pointerType: event.pointerType,
                  pressure: event.pressure,
                  tiltX: event.tiltX,
                  tiltY: event.tiltY,
                  twist: event.twist,
                  isPrimary: event.isPrimary,
                  tool: currentTool
              });
          }
      }
      
      // Width selection
      function selectWidth () {
          const penRadius = widthSelector.value;
          draw_settings.width = parseInt(penRadius);
          // widthValue.textContent = currentWidth;
          // Update the CSS custom property on the input element
          widthSelector.style.setProperty('--thumb-size', draw_settings.width);
      };
      
      // Opacity selection
      function selectOpacity () {
          draw_settings.opacity = parseInt( opacitySelector.value ) / 128;
          opacitySelector.style.setProperty('--thumb-opacity', draw_settings.opacity);
      };
      
      // Set up event listeners
      function setupEventListeners() {
          // Reconnect button
          reconnectButton.addEventListener('click', reconnectWebSocket);
          
          // Tool selection
          document.getElementById('chalk-tool').addEventListener('click', () => setTool('chalk'));
          document.getElementById('pen-tool').addEventListener('click', () => setTool('pen'));
          document.getElementById('highlighter-tool').addEventListener('click', () => setTool('highlighter'));
          document.getElementById('eraser-tool').addEventListener('click', () => setTool('eraser'));
          
          // Color selection
          const colorSwatches = document.querySelectorAll('.color-swatch');
          colorSwatches.forEach(swatch => {
              swatch.addEventListener('pointerdown', (e) => handleColorSwatchEvent(e));
          });
          
          widthSelector.addEventListener('input', selectWidth);
          opacitySelector.addEventListener('input', selectOpacity);

          document.getElementById('timer-btn').addEventListener('click', () => {
              draw_settings.undo = ( draw_settings.tool != "eraser" ) && ! draw_settings.undo;
              updateKnobs();
          });
          
          // Page navigation
          document.getElementById('prev-page').addEventListener('click', () => navigatePage(-1));
          document.getElementById('next-page').addEventListener('click', () => navigatePage(1));
          document.getElementById('add-page').addEventListener('click', addNewPage);
          document.getElementById('delete-page').addEventListener('click', deletePage);
          
          // Zoom controls
          document.getElementById('zoom-in').addEventListener('click', () => adjustZoom(0.1));
          document.getElementById('zoom-out').addEventListener('click', () => adjustZoom(-0.1));
          
          // Undo/Redo buttons
          undoBtn.addEventListener('click', handleUndo);
          redoBtn.addEventListener('click', handleRedo);
          
          // Debug button
          document.getElementById('debug-btn').addEventListener('click', showDebugInfo);
          
          // Export PDF button
          document.getElementById('pdf-btn').addEventListener('click', exportPageToPDF);
          
          // Canvas events
          canvas.addEventListener('pointerdown', handlePointerDown);
          canvas.addEventListener('pointermove', handlePointerMove);
          canvas.addEventListener('pointerup', handlePointerUp);
          canvas.addEventListener('pointerleave', handlePointerUp);
          
          // Prevent default touch behaviors
          canvas.addEventListener('touchstart', e => e.preventDefault());
          canvas.addEventListener('touchmove', e => e.preventDefault());
          canvas.addEventListener('touchend', e => e.preventDefault());
          
          // Keyboard shortcuts
          document.addEventListener('keydown', handleKeyDown);

          // Close color picker when clicking outside
          colorPickerOverlay.addEventListener('click', (e) => {
              if (e.target === colorPickerOverlay) {
                  closeColorPicker();
              }
          });
      }
      
      // Color swatch handling
      let currentEditingSwatch = null;
      let colorPickerState = {
          hue: 0,
          saturation: 100,
          lightness: 50,
          opacity: 100,
          rgbColor: { r: 0, g: 0, b: 0 },
          originalColor: '#000000'
      };

      function handleColorSwatchEvent(event) {
          const swatch = event.currentTarget;
          
          // Set the current swatch as active
          document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('active'));
          swatch.classList.add('active');
          
          // Set the current color
          draw_settings.color = swatch.dataset.color;
          updateKnobs();
          
          // Long press detection - open color picker after 500ms
          if (event.type === 'pointerdown') {
              currentEditingSwatch = swatch;
              colorPickerState.originalColor = swatch.dataset.color;
              
              // Create a timer for long press
              setTimeout(() => {
                  if (currentEditingSwatch === swatch) {
                      openColorPicker(swatch);
                  }
              }, 500);
              
              // Add listeners to detect if the pointer is released or moved away
              document.addEventListener('pointerup', clearSwatchLongPress);
              document.addEventListener('pointermove', clearSwatchLongPress);
          }
      }

      function clearSwatchLongPress() {
          currentEditingSwatch = null;
          document.removeEventListener('pointerup', clearSwatchLongPress);
          document.removeEventListener('pointermove', clearSwatchLongPress);
      }

      // Custom Color Picker Implementation
      function setupColorPicker() {
          // Set up color picker canvases
          initializeHueCanvas();
          initializeSaturationCanvas();
          
          // Set up color picker inputs
          hexInput.addEventListener('input', handleHexInput);
          rInput.addEventListener('input', handleRgbInput);
          gInput.addEventListener('input', handleRgbInput);
          bInput.addEventListener('input', handleRgbInput);
          opacityInput.addEventListener('input', handleOpacityInput);
          
          // Set up color picker buttons
          applyButton.addEventListener('click', applyColorSelection);
          cancelButton.addEventListener('click', closeColorPicker);
          closeButton.addEventListener('click', closeColorPicker);
      }

      function initializeHueCanvas() {
          const ctx = hueCanvas.getContext('2d');
          const width = hueCanvas.width;
          const height = hueCanvas.height;
          
          // Create hue gradient
          const gradient = ctx.createLinearGradient(0, 0, width, 0);
          for (let i = 0; i <= 360; i += 60) {
              gradient.addColorStop(i / 360, `hsl(${i}, 100%, 50%)`);
          }
          
          ctx.fillStyle = gradient;
          ctx.fillRect(0, 0, width, height);
          
          // Add event listeners for hue selection
          hueCanvas.addEventListener('pointerdown', handleHueSelection);
          hueCanvas.addEventListener('pointermove', (e) => {
              if (e.buttons > 0) {
                  handleHueSelection(e);
              }
          });
      }

      function initializeSaturationCanvas() {
          // This will be updated dynamically based on the selected hue
          updateSaturationCanvas(0); // Default hue is red (0°)
          
          // Add event listeners for saturation-lightness selection
          saturationCanvas.addEventListener('pointerdown', handleSaturationSelection);
          saturationCanvas.addEventListener('pointermove', (e) => {
              if (e.buttons > 0) {
                  handleSaturationSelection(e);
              }
          });
      }

      function updateSaturationCanvas(hue) {
          const ctx = saturationCanvas.getContext('2d');
          const width = saturationCanvas.width;
          const height = saturationCanvas.height;
          
          // Clear canvas
          ctx.clearRect(0, 0, width, height);
          
          // Create saturation gradient (horizontal, from white to full color)
          const saturationGradient = ctx.createLinearGradient(0, 0, width, 0);
          saturationGradient.addColorStop(0, `hsl(${hue}, 0%, 50%)`);
          saturationGradient.addColorStop(1, `hsl(${hue}, 100%, 50%)`);
          ctx.fillStyle = saturationGradient;
          ctx.fillRect(0, 0, width, height);
          
          // Create lightness gradient (vertical, from black to transparent to white)
          const lightnessGradient = ctx.createLinearGradient(0, 0, 0, height);
          lightnessGradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
          lightnessGradient.addColorStop(0.5, 'rgba(255, 255, 255, 0)');
          lightnessGradient.addColorStop(1, 'rgba(0, 0, 0, 1)');
          ctx.fillStyle = lightnessGradient;
          ctx.fillRect(0, 0, width, height);
      }

      function handleHueSelection(e) {
          const rect = hueCanvas.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const width = hueCanvas.width;
          
          // Calculate hue (0-360)
          colorPickerState.hue = Math.round((x / width) * 360);
          if (colorPickerState.hue < 0) colorPickerState.hue = 0;
          if (colorPickerState.hue > 360) colorPickerState.hue = 360;
          
          // Update saturation canvas with new hue
          updateSaturationCanvas(colorPickerState.hue);
          
          // Update color display
          updateColorFromHSL();
      }

      function handleSaturationSelection(e) {
          const rect = saturationCanvas.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;
          const width = saturationCanvas.width;
          const height = saturationCanvas.height;
          
          // Calculate saturation (0-100)
          colorPickerState.saturation = Math.round((x / width) * 100);
          if (colorPickerState.saturation < 0) colorPickerState.saturation = 0;
          if (colorPickerState.saturation > 100) colorPickerState.saturation = 100;
          
          // Calculate lightness (0-100, inverted because 0,0 is top-left)
          // Map from 0-100 to 100-0 for lightness (0% at bottom = black, 100% at top = white)
          colorPickerState.lightness = Math.round(100 - (y / height) * 100);
          if (colorPickerState.lightness < 0) colorPickerState.lightness = 0;
          if (colorPickerState.lightness > 100) colorPickerState.lightness = 100;
          
          // Update color display
          updateColorFromHSL();
      }

      function handleOpacityInput() {
          colorPickerState.opacity = parseInt(opacityInput.value);
          updateColorDisplay();
      }

      function handleHexInput() {
          let hex = hexInput.value.trim();
          
          // Add # if missing
          if (hex.charAt(0) !== '#') {
              hex = '#' + hex;
          }
          
          // Validate hex format
          const validHex = /^#([0-9A-F]{3}){1,2}$/i;
          if (!validHex.test(hex)) {
              return;
          }
          
          // Convert hex to RGB
          const rgb = hexToRgb(hex);
          if (!rgb) return;
          
          colorPickerState.rgbColor = rgb;
          
          // Update RGB inputs
          rInput.value = rgb.r;
          gInput.value = rgb.g;
          bInput.value = rgb.b;
          
          // Convert to HSL and update state
          const hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);
          colorPickerState.hue = hsl.h;
          colorPickerState.saturation = hsl.s;
          colorPickerState.lightness = hsl.l;
          
          // Update saturation canvas
          updateSaturationCanvas(colorPickerState.hue);
          
          // Update color display
          updateColorDisplay();
      }

      function handleRgbInput() {
          const r = parseInt(rInput.value) || 0;
          const g = parseInt(gInput.value) || 0;
          const b = parseInt(bInput.value) || 0;
          
          // Clamp values
          const rgb = {
              r: Math.max(0, Math.min(255, r)),
              g: Math.max(0, Math.min(255, g)),
              b: Math.max(0, Math.min(255, b))
          };
          
          colorPickerState.rgbColor = rgb;
          
          // Update hex input
          hexInput.value = rgbToHex(rgb.r, rgb.g, rgb.b);
          
          // Convert to HSL and update state
          const hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);
          colorPickerState.hue = hsl.h;
          colorPickerState.saturation = hsl.s;
          colorPickerState.lightness = hsl.l;
          
          // Update saturation canvas
          updateSaturationCanvas(colorPickerState.hue);
          
          // Update color display
          updateColorDisplay();
      }

      function updateColorFromHSL() {
          // Convert HSL to RGB
          const rgb = hslToRgb(
              colorPickerState.hue, 
              colorPickerState.saturation, 
              colorPickerState.lightness
          );
          
          colorPickerState.rgbColor = rgb;
          
          // Update RGB inputs
          rInput.value = rgb.r;
          gInput.value = rgb.g;
          bInput.value = rgb.b;
          
          // Update hex input
          hexInput.value = rgbToHex(rgb.r, rgb.g, rgb.b);
          
          // Update color display
          updateColorDisplay();
      }

      function updateColorDisplay() {
          const { r, g, b } = colorPickerState.rgbColor;
          const { opacity } = colorPickerState;
          
          // Update color preview
          newColorPreview.style.backgroundColor = `rgba(${r}, ${g}, ${b}, ${opacity / 100})`;
          
          // Update opacity gradient
          opacityGradient.style.background = `linear-gradient(to right, rgba(${r}, ${g}, ${b}, 0), rgba(${r}, ${g}, ${b}, 1))`;
      }

      function openColorPicker(swatch) {
          currentEditingSwatch = swatch;
          
          // Parse the current color
          const currentColor = swatch.dataset.color;
          let rgb;
          
          // Handle named colors
          if (currentColor.indexOf('#') !== 0) {
              // Create a temporary element to get the computed color
              const tempEl = document.createElement('div');
              tempEl.style.color = currentColor;
              document.body.appendChild(tempEl);
              const computedColor = window.getComputedStyle(tempEl).color;
              document.body.removeChild(tempEl);
              
              // Parse the computed color (format: "rgb(r, g, b)" or "rgba(r, g, b, a)")
              const match = computedColor.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([0-9.]+))?\)/);
              if (match) {
                  rgb = {
                      r: parseInt(match[1]),
                      g: parseInt(match[2]),
                      b: parseInt(match[3])
                  };
                  colorPickerState.opacity = match[4] ? Math.round(parseFloat(match[4]) * 100) : 100;
              } else {
                  // Default to black if parsing fails
                  rgb = { r: 0, g: 0, b: 0 };
                  colorPickerState.opacity = 100;
              }
          } else {
              // Handle hex colors
              rgb = hexToRgb(currentColor);
              colorPickerState.opacity = 100; // Assume full opacity for hex colors
          }
          
          // Update color picker state
          colorPickerState.rgbColor = rgb;
          const hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);
          colorPickerState.hue = hsl.h;
          colorPickerState.saturation = hsl.s;
          colorPickerState.lightness = hsl.l;
          colorPickerState.originalColor = currentColor;
          
          // Update UI elements
          originalColorPreview.style.backgroundColor = currentColor;
          rInput.value = rgb.r;
          gInput.value = rgb.g;
          bInput.value = rgb.b;
          hexInput.value = rgbToHex(rgb.r, rgb.g, rgb.b);
          opacityInput.value = colorPickerState.opacity;
          
          // Update saturation canvas and color display
          updateSaturationCanvas(colorPickerState.hue);
          updateColorDisplay();
          
          // Show the color picker
          colorPickerOverlay.style.display = 'flex';
      }

      function closeColorPicker() {
          colorPickerOverlay.style.display = 'none';
          currentEditingSwatch = null;
      }

      function applyColorSelection() {
          if (!currentEditingSwatch) {
              closeColorPicker();
              return;
          }
          
          const { r, g, b } = colorPickerState.rgbColor;
          const { opacity } = colorPickerState;
          
          // Format the color based on opacity
          let colorValue;
          if (opacity < 100) {
              colorValue = `rgba(${r}, ${g}, ${b}, ${opacity / 100})`;
          } else {
              colorValue = rgbToHex(r, g, b);
          }
          
          // Update the swatch
          currentEditingSwatch.style.backgroundColor = colorValue;
          currentEditingSwatch.dataset.color = colorValue;
          
          // Update the current tool if this swatch is active
          if (currentEditingSwatch.classList.contains('active')) {
              draw_settings.color = colorValue;
              updateKnobs();
          }
          
          closeColorPicker();
      }

      // Color conversion utilities
      function hexToRgb(hex) {
          // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
          const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
          hex = hex.replace(shorthandRegex, (m, r, g, b) => r + r + g + g + b + b);
          
          const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
          return result ? {
              r: parseInt(result[1], 16),
              g: parseInt(result[2], 16),
              b: parseInt(result[3], 16)
          } : null;
      }

      function rgbToHex(r, g, b) {
          return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase();
      }

      function rgbToHsl(r, g, b) {
          r /= 255;
          g /= 255;
          b /= 255;
          
          const max = Math.max(r, g, b);
          const min = Math.min(r, g, b);
          let h, s, l = (max + min) / 2;
          
          if (max === min) {
              h = s = 0; // achromatic
          } else {
              const d = max - min;
              s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
              
              switch (max) {
              case r: h = (g - b) / d + (g < b ? 6 : 0); break;
              case g: h = (b - r) / d + 2; break;
              case b: h = (r - g) / d + 4; break;
              }
              
              h /= 6;
          }
          
          return {
              h: Math.round(h * 360),
              s: Math.round(s * 100),
              l: Math.round(l * 100)
          };
      }

      function hslToRgb(h, s, l) {
          h /= 360;
          s /= 100;
          l /= 100;
          
          let r, g, b;
          
          if (s === 0) {
              r = g = b = l; // achromatic
          } else {
              const hue2rgb = (p, q, t) => {
                  if (t < 0) t += 1;
                  if (t > 1) t -= 1;
                  if (t < 1/6) return p + (q - p) * 6 * t;
                  if (t < 1/2) return q;
                  if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                  return p;
              };
              
              const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
              const p = 2 * l - q;
              
              r = hue2rgb(p, q, h + 1/3);
              g = hue2rgb(p, q, h);
              b = hue2rgb(p, q, h - 1/3);
          }
          
          return {
              r: Math.round(r * 255),
              g: Math.round(g * 255),
              b: Math.round(b * 255)
          };
      }
      
      let pressTimer;
      let isLongPress = false;

      function selectColor(swatch) {
          document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('active'));
          swatch.classList.add('active');
          draw_settings.color = swatch.dataset.color;
          updateKnobs();
      }

      // Show debug information
      function showDebugInfo() {
          console.log('=== DEBUG INFO ===');
          console.log('Page UUID:', currentPageUuid);
          console.log('History Length:', history.length);
          console.log('Present:', present);
          console.log('Verified Index:', verifiedIndex);
          console.log('Hashes:', hashes);
          console.log('Visual State:', visualState);
          
          alert(`Debug info in console.\nHistory: ${history.length} actions\nPresent: ${present}\nVerified: ${verifiedIndex}`);
      }
      
      // Handle keyboard shortcuts
      function handleKeyDown(e) {
          // Undo: Ctrl+Z
          if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
              e.preventDefault();
              if (!undoBtn.disabled) {
                  handleUndo();
              }
          }
          // Redo: Ctrl+Y or Ctrl+Shift+Z
          else if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
              e.preventDefault();
              if (!redoBtn.disabled) {
                  handleRedo();
              }
          }
      }
      
      // Update undo/redo button states
      function updateUndoRedoButtons() {
          // Undo is available if we have actions in history before our present position
          undoBtn.disabled = present === 0;
          
          // Redo is available if we have actions in history after our present position
          redoBtn.disabled = present >= history.length;
      }
      
      // Handle undo action
      function handleUndo() {
          if (present === 0) return;
          
          const actionToUndo = history[present - 1];
          const undoUuid = shared.generateUuid();
          
          const undoAction = {
              type: shared.MOD_ACTIONS.UNDO.TYPE,
              [shared.MOD_ACTIONS.UUID]: undoUuid,
              [shared.MOD_ACTIONS.UNDO.TARGET_ACTION]: actionToUndo[shared.MOD_ACTIONS.UUID]
          };
          
          // Create proposal
          const proposal = {
              type: shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.TYPE,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PASSWORD]: passwd,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAGE_UUID]: currentPageUuid,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD]: undoAction,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.BEFORE_HASH]: hashes[present]
          };
          
          // Apply locally first (optimistic update)
          present--;
          
          // Update visual state and UI
          updateVisualState();
          updateUndoRedoButtons();
          updateSyncStatus();
          
          // Send to server
          sendMessage(proposal);
      }
      
      // Handle redo action
      function handleRedo() {
          if (present >= history.length) return;
          
          const actionToRedo = history[present];
          const redoUuid = shared.generateUuid();
          
          const redoAction = {
              type: shared.MOD_ACTIONS.REDO.TYPE,
              [shared.MOD_ACTIONS.UUID]: redoUuid,
              [shared.MOD_ACTIONS.REDO.TARGET_ACTION]: actionToRedo[shared.MOD_ACTIONS.UUID]
          };
          
          // Create proposal
          const proposal = {
              type: shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.TYPE,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PASSWORD]: passwd,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAGE_UUID]: currentPageUuid,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD]: redoAction,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.BEFORE_HASH]: hashes[present]
          };
          
          // Apply locally first (optimistic update)
          present++;
          
          // Update visual state and UI
          updateVisualState();
          updateUndoRedoButtons();
          updateSyncStatus();
          
          // Send to server
          sendMessage(proposal);
      }
      
      // Set current tool
      function setTool(tool) {
          currentTool = tool;
          
          // Update UI
          document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
          document.getElementById(`${tool}-tool`).classList.add('active');
          
          // Update cursor
          switch (tool) {
          case 'chalk':
              canvas.style.cursor = 'crosshair';
              switch_settings( chalk_settings );
              set_pointer_handler( draw_path_pointer_handler );
              break;
          case 'pen':
              canvas.style.cursor = 'crosshair';
              switch_settings( pen_settings );
              set_pointer_handler( draw_path_pointer_handler );
              break;
          case 'highlighter':
              canvas.style.cursor = 'crosshair';
              switch_settings( highlighter_settings );
              set_pointer_handler( draw_path_pointer_handler );
              break;
          case 'eraser':
              canvas.style.cursor = 'cell';
              switch_settings( eraser_settings );
              set_pointer_handler( erase_path_pointer_handler );
              break;
          }
      }
      
      // Adjust zoom level
      function adjustZoom(delta) {
          zoomLevel = Math.max(0.5, Math.min(3, zoomLevel + delta));
          zoomLevelDisplay.textContent = `${Math.round(zoomLevel * 100)}%`;
          applyZoom();
          redrawCanvas();
      }
      
      // Update page info display
      function updatePageInfo() {
          pageInfo.textContent = `Page ${pageNr} of ${totalPages}`;
      }
      
      const draw_path_pointer_handler = {
          down: () => {
              if ( force_stylus && event.pointerType === "touch" ) { return; }
              const rect = canvas.getBoundingClientRect();
              const x = (event.clientX - rect.left) / zoomLevel;
              const y = (event.clientY - rect.top) / zoomLevel;
              const pressure = event.pressure !== undefined ? event.pressure : 0.5;
              currentPath = [];
              const point = shared.createPoint(x, y, pressure);
              currentPath.push(point);
              isDrawing = true;
              currentStroke = shared.createStroke( draw_settings.stroke);
              currentStroke[shared.ELEMENT.COLOR] = draw_settings.color;
              currentStroke[shared.ELEMENT.WIDTH] = draw_settings.width;
              currentStroke[shared.ELEMENT.OPACITY] = draw_settings.opacity;
              currentStroke[shared.ELEMENT.POINTS] = currentPath;
          },
          move: () => {
              if ( force_stylus && event.pointerType === "touch" ) { return; }
              if (!isDrawing) return;
              const rect = canvas.getBoundingClientRect();
              const x = (event.clientX - rect.left) / zoomLevel;
              const y = (event.clientY - rect.top) / zoomLevel;
              const pressure = event.pressure !== undefined ? event.pressure : 0.5;
              const point = shared.createPoint(x, y, pressure);
              currentPath.push(point);
              currentStroke[shared.ELEMENT.POINTS] = currentPath;
              redrawCanvas();
          },
          up: () => {
              if ( force_stylus && event.pointerType === "touch" ) { return; }
              if (isDrawing) {
                  isDrawing = false;
                  if (currentPath.length >= 1) {
                      const actionId = sendDrawAction(currentStroke);
                      if ( draw_settings.undo ) {
                          setTimeout( sendGroupEraseAction, 3000, [ actionId ] );
                      }
                  }
              }
              currentPath = [];
              currentStroke = null;
          }
      };

      const erase_path_pointer_handler = {
          down: () => {
              if ( force_stylus && event.pointerType === "touch" ) { return; }
              const rect = canvas.getBoundingClientRect();
              const x = (event.clientX - rect.left) / zoomLevel;
              const y = (event.clientY - rect.top) / zoomLevel;
              const pressure = event.pressure !== undefined ? event.pressure : 0.5;
              currentPath = [];
              const point = shared.createPoint(x, y, pressure);
              currentPath.push(point);
              isErasing = true;
              currentStroke = shared.createStroke( shared.STROKE_STYLES.PEN );
              currentStroke[shared.ELEMENT.WIDTH] = draw_settings.width;
              currentStroke[shared.ELEMENT.COLOR] = '#FF0000'; // Red for visibility during erasing
              currentStroke[shared.ELEMENT.OPACITY] = 0.3; // Transparent so we can see what is being erased
              currentStroke[shared.ELEMENT.POINTS] = currentPath;
          },
          move: () => {
              if ( force_stylus && event.pointerType === "touch" ) { return; }
              if (!isErasing) return;
              const rect = canvas.getBoundingClientRect();
              const x = (event.clientX - rect.left) / zoomLevel;
              const y = (event.clientY - rect.top) / zoomLevel;
              const pressure = event.pressure !== undefined ? event.pressure : 0.5;
              const point = shared.createPoint(x, y, pressure);
              currentPath.push(point);
              currentStroke[shared.ELEMENT.POINTS] = currentPath;
              redrawCanvas();
          },
          up: () => {
              if ( force_stylus && event.pointerType === "touch" ) { return; }
              if (isErasing) {
                  isErasing = false;
                  if (currentPath.length >= 1) {
                      const elementsToErase = findElementsIntersectingPath(currentStroke);
                      if (elementsToErase.length > 0) {
                          sendGroupEraseAction(elementsToErase);
                      } else {
                          updateVisualState();
                      }
                  }
              }
              currentPath = [];
              currentStroke = null;
          }
      };

      let pointer_handler = draw_path_pointer_handler;

      function set_pointer_handler ( ph ) {
          pointer_handler = ph;
      };


      function handlePointerDown(event) {
          pointer_handler.down();
      }
      
      function handlePointerMove(event) {
          pointer_handler.move();
      }

      function handlePointerUp() {
          pointer_handler.up();
      }
      
      // Find elements that intersect with a complete eraser path
      function findElementsIntersectingPath(eraserStroke) {
          const result = shared.findIntersectingElements(visualState, eraserStroke, eraserRadius/2, 10);
          console.log("erasing:", serialize( result ) );
          return result;
      }
      
      // Send a draw action to the server
      function sendDrawAction(stroke) {
          const actionUuid = shared.generateUuid();
          
          const drawAction = {
              type: shared.MOD_ACTIONS.DRAW.TYPE,
              [shared.MOD_ACTIONS.UUID]: actionUuid,
              [shared.MOD_ACTIONS.DRAW.STROKE]: stroke
          };
          
          // If we're in the middle of history (after undoing), truncate future actions
          if (present < history.length) {
              history = history.slice(0, present);
              hashes = hashes.slice(0, present + 1);
          }
          
          // Add to history and advance present
          history.push(drawAction);
          present++;
          
          // Calculate placeholder hash
          const placeholderHash = shared.generateUuid(); // Will be replaced with server hash when confirmed
          hashes.push(placeholderHash);
          
          // Create proposal
          const proposal = {
              type: shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.TYPE,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PASSWORD]: passwd,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAGE_UUID]: currentPageUuid,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD]: drawAction,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.BEFORE_HASH]: hashes[present - 1]
          };
          
          // Update visual state
          updateVisualState();
          
          // Update UI
          updateUndoRedoButtons();
          updateSyncStatus();
          
          // Send to server
          sendMessage(proposal);
          return actionUuid;
      }
      
      // Create a single erase action for a target
      function createEraseAction(targetUuid) {
          const actionUuid = shared.generateUuid();
          return {
              type: shared.MOD_ACTIONS.ERASE.TYPE,
              [shared.MOD_ACTIONS.UUID]: actionUuid,
              [shared.MOD_ACTIONS.ERASE.TARGET_ACTION]: targetUuid
          };
      }
      
      // Send a group of erase actions as a single group action
      function sendGroupEraseAction(targetUuids) {
          if (targetUuids.length === 0) return;
          
          const groupUuid = shared.generateUuid();
          
          // Create individual erase actions for each target
          const eraseActions = targetUuids.map(targetUuid => createEraseAction(targetUuid));
          
          // Create a group action containing all erase actions
          const groupAction = {
              type: shared.MOD_ACTIONS.GROUP.TYPE,
              [shared.MOD_ACTIONS.UUID]: groupUuid,
              [shared.MOD_ACTIONS.GROUP.ACTIONS]: eraseActions
          };
          
          // If we're in the middle of history (after undoing), truncate future actions
          if (present < history.length) {
              history = history.slice(0, present);
              hashes = hashes.slice(0, present + 1);
          }
          
          // Add to history and advance present
          history.push(groupAction);
          present++;
          
          // Calculate placeholder hash
          const placeholderHash = shared.generateUuid(); // Will be replaced with server hash when confirmed
          hashes.push(placeholderHash);
          
          // Create proposal
          const proposal = {
              type: shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.TYPE,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PASSWORD]: passwd,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAGE_UUID]: currentPageUuid,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD]: groupAction,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.BEFORE_HASH]: hashes[present - 1]
          };
          
          // Update visual state and UI
          updateVisualState();
          updateUndoRedoButtons();
          updateSyncStatus();
          
          // Send to server
          sendMessage(proposal);
      }
      
      // Add a new page
      function addNewPage() {
          const actionUuid = shared.generateUuid();
          
          const newPageAction = {
              type: shared.MOD_ACTIONS.NEW_PAGE.TYPE,
              [shared.MOD_ACTIONS.UUID]: actionUuid
          };
          
          // Create proposal
          const proposal = {
              type: shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.TYPE,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PASSWORD]: passwd,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAGE_UUID]: currentPageUuid,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD]: newPageAction,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.BEFORE_HASH]: hashes[present]
          };
          
          // Send to server - no optimistic update for page operations
          sendMessage(proposal);
      }
      
      // Delete current page
      function deletePage() {
          if (totalPages <= 1) {
              alert("Cannot delete the only page");
              return;
          }
          
          const actionUuid = shared.generateUuid();
          
          const deletePageAction = {
              type: shared.MOD_ACTIONS.DELETE_PAGE.TYPE,
              [shared.MOD_ACTIONS.UUID]: actionUuid
          };
          
          // Create proposal
          const proposal = {
              type: shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.TYPE,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PASSWORD]: passwd,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAGE_UUID]: currentPageUuid,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.PAYLOAD]: deletePageAction,
              [shared.MESSAGES.CLIENT_TO_SERVER.MOD_ACTION_PROPOSALS.BEFORE_HASH]: hashes[present]
          };
          
          // Send to server - no optimistic update for page operations
          sendMessage(proposal);
      }
      
      // Navigate to next/previous page
      function navigatePage(delta) {
          // Request full page with delta
          requestFullPage(currentPageUuid, delta);
      }
      
      // Redraw the canvas
      function redrawCanvas() {
          ctx.save();
          ctx.setTransform(1, 0, 0, 1, 0, 0);
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.restore();

          function push_settings(element) {
              const transform = element[shared.ELEMENT.TRANSFORM];
              ctx.transform(
                  transform[shared.TRANSFORM.A],
                  transform[shared.TRANSFORM.B],
                  transform[shared.TRANSFORM.C],
                  transform[shared.TRANSFORM.D],
                  transform[shared.TRANSFORM.E],
                  transform[shared.TRANSFORM.F]
              );

              // Apply style
              ctx.strokeStyle = element[shared.ELEMENT.COLOR];
              ctx.lineWidth = element[shared.ELEMENT.WIDTH];
              ctx.globalAlpha = element[shared.ELEMENT.OPACITY];
              
              // Cap and join styles
              ctx.lineCap = shared.CAP_STYLE_STRINGS[element[shared.ELEMENT.CAP_STYLE]];
              ctx.lineJoin = shared.JOIN_STYLE_STRINGS[element[shared.ELEMENT.JOIN_STYLE]];
              
              // Dash pattern
              const dashPattern = element[shared.ELEMENT.DASH_PATTERN];
              if (dashPattern && dashPattern.length > 1) {
                  ctx.setLineDash(dashPattern);
              } else {
                  ctx.setLineDash([]);
              }
          }

          function lay_path(element) {
              const points = element[shared.ELEMENT.POINTS];
              ctx.beginPath();
              ctx.moveTo(points[0][shared.POINT.X], points[0][shared.POINT.Y]);
              for (let i = 1; i < points.length; i++) {
                  const point = points[i];
                  ctx.lineTo(point[shared.POINT.X], point[shared.POINT.Y]);
              }
          }

          function draw_open(element) {
              const points = element[shared.ELEMENT.POINTS];
              ctx.miterLimit = 2;
              if ( 1 == points.length ) {
                  ctx.beginPath();
                  ctx.moveTo(points[0][shared.POINT.X], points[0][shared.POINT.Y]);
                  ctx.lineWidth = element[shared.ELEMENT.WIDTH] * ( 1 + element[shared.ELEMENT.SENSITIVITY] / 2 );
                  ctx.lineTo(points[0][shared.POINT.X]+0.0001, points[0][shared.POINT.Y]);
                  ctx.stroke();
              } else if ( 0.03 > element[shared.ELEMENT.SENSITIVITY] ) {
                  ctx.beginPath();
                  ctx.moveTo(points[0][shared.POINT.X], points[0][shared.POINT.Y]);
                  ctx.lineWidth = element[shared.ELEMENT.WIDTH];
                  for (let i = 1; i < points.length; i++) {
                      const point = points[i];
                      ctx.lineTo(point[shared.POINT.X], point[shared.POINT.Y]);
                  }
                  ctx.stroke();
              } else {
                  for (let i = 1; i < points.length; i++) {
                      ctx.beginPath();
                      ctx.moveTo(points[i-1][shared.POINT.X], points[i-1][shared.POINT.Y]);
                      const point = points[i];
                      const pressure = point[shared.POINT.PRESSURE];
                      const pressureEffect = ( 1 + pressure * element[shared.ELEMENT.SENSITIVITY] );
                      ctx.lineWidth = element[shared.ELEMENT.WIDTH] * pressureEffect;
                      ctx.lineTo(point[shared.POINT.X], point[shared.POINT.Y]);
                      ctx.stroke();
                  }
              }
          }

          function draw_closed(element) {
              lay_path(element);
              ctx.lineWidth = element[shared.ELEMENT.WIDTH];
              ctx.stroke();
          }

          
          // Custom render function for shared.render_all_visible_elements
          function renderElement(element) {
              if (!element) return;
              ctx.save();
              push_settings(element);
              const type = element[ELEMENT.TYPE];
              const path = element[ELEMENT.PATH];
              const is_closed = ( path == DRAWABLE.CLOSED_PIECEWISE_LINEAR || path == DRAWABLE.CLOSED_BEZIER_CURVE );
              lay_path(element);
              if ( type == DRAWABLE.TYPE.FILL ) {
                  if ( ! is_closed ) {
                      console.error('Only closed paths can be filled.',"");
                      throw new Error('Only closed paths can be filled.');
                  }
                  lay_path(element);
                  ctx.closePath();
                  ctx.fill()
              } else if ( type == DRAWABLE.TYPE.STROKE ) {
                  if ( is_closed ) {
                      draw_closed(element);
                  } else {
                      draw_open(element);
                  }
              } else {
                  // If we get here, it is a bug - assertion would fail in production code
                  console.error('Unknown drawable type:', type);
                  throw new Error('Invalid drawable type');
              }
              ctx.restore();
          }
          
          // Render all visible elements
          shared.render_all_visible_elements(visualState, renderElement);
          
          // Draw current stroke if we're drawing or erasing
          if ((isDrawing || isErasing) && currentStroke) {
              renderElement(currentStroke);
          }
      }

      
      /**
       * Generates a timestamp string suitable for a filename.
       * Format: YYYY-MM-DD_HH-MM-SS
       * @returns {string} The formatted timestamp string.
       */
      function getTimestampForFilename() {
          const now = new Date();
          const year = now.getFullYear();
          const month = (now.getMonth() + 1).toString().padStart(2, '0');
          const day = now.getDate().toString().padStart(2, '0');
          const hours = now.getHours().toString().padStart(2, '0');
          const minutes = now.getMinutes().toString().padStart(2, '0');
          const seconds = now.getSeconds().toString().padStart(2, '0');
          
          return `${year}-${month}-${day}_${hours}-${minutes}-${seconds}`;
      }
      

      // export current page to pdf

      function exportPageToPDF () {
          try {
              const timestamp = getTimestampForFilename();
              const doc = new window.jspdf.jsPDF('l', 'px', [canvas.width, canvas.height]);
              doc.addImage(canvas.toDataURL('image/png', 1.0), 'PNG', 0, 0, canvas.width, canvas.height);
              doc.save(`board_${boardId}_page_${pageNr}_${timestamp}.pdf`);
          } catch (err) {
              throw new Error(`PDF export failed: ${err.message}`);
          }
      };

      
      // Initialize the app
      window.addEventListener('DOMContentLoaded', init);
    </script>
  </body>
</html>
